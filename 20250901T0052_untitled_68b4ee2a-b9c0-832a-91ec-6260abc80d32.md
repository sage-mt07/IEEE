---
conversation_id: "68b4ee2a-b9c0-832a-91ec-6260abc80d32"
title: "スキーマ自動登録の仕組み"
create_time: 1756687943.363498
update_time: 1756782819.010207
language_guess: "en"
num_messages: 16
part_index: 1
part_count: 1
---

### user — 2025-09-01T00:52:23.038929+00:00

Produce時のスキーマ自動登録の仕組み

### system — 2025-09-01T00:52:23.363498+00:00

_(empty)_

### user — 2025-09-01T00:52:23.363498+00:00

_(empty)_

### system — 2025-09-01T00:52:23.363498+00:00

_(empty)_

### system — 2025-09-01T00:52:26.366074+00:00

_(empty)_

### system — 2025-09-01T00:52:26.376880+00:00

_(empty)_

### assistant — 2025-09-01T00:52:26.406427+00:00

_(empty)_

### assistant — 2025-09-01T00:52:26.568064+00:00

_(empty)_

### assistant — 2025-09-01T00:52:29.559239+00:00

やあ、いらっしゃい！  
「Produce時のスキーマ自動登録（auto-registration）の仕組み」を、.NET/Confluent 目線で要点→実務ノウハウの順でまとめます。

# 仕組みの全体像（Avro/JSON Schema/Protobuf 共通の基本）
1) **シリアライザがワイヤ形式で送る**  
   先頭 1 バイトの *magic byte (=0)* ＋ **Schema ID(4バイト, big-endian)** ＋ 本体データ。  
   → コンシューマ/ksqlDB は **Schema Registry** で `Schema ID → スキーマ` を引き直してデコードします。

2) **自動登録のトリガ**（プロデューサ側）  
   - 送信直前、シリアライザが次を行います：  
     a. 対象サブジェクト（例：`<topic>-value`）を決定（※後述の SubjectNameStrategy）。  
     b. そのサブジェクトに**同一スキーマが既に登録**されていないか **fingerprint** で照合。  
     c. なければ **Schema Registry に新規登録** → 発番された **Schema ID** を取得。  
     d. 以降のメッセージでその Schema ID をヘッダに埋め込んで送信。  
   - 既存一致が見つかれば **再登録はせず**、既存の Schema ID を使います。

3) **互換性チェック**  
   Schema Registry の互換性（BACKWARD, FULL など）は **サブジェクト単位**。  
   自動登録時に **互換性違反** があると **登録エラー**（= 送信失敗）になります。

---

# サブジェクト名（SubjectNameStrategy）が核心
同じトピックを**誰が/どう登録したか**でつまづきがちです。代表は次の 3 つ：

- **TopicName**：`<topic>-key` / `<topic>-value` に登録  
  - *ksqlDB と相性がよく無難*。トピック単位でスキーマを管理したい時に最適。
- **RecordName**（= RecordOnly）：`<recordFullyQualifiedName>` に登録  
  - レコード型単位で共有したい場合に使う（複数トピックで同じ型を共有）。
- **TopicRecordName**（= TopicRecord）：`<topic>-<recordFullyQualifiedName>`  
  - トピックとレコードの複合。細かく分けられるが設計が複雑になりがち。

> **実務指針**：ksqlDB を使うなら **TopicName を基本**に揃えるのが一番トラブルが少ないです（`CREATE STREAM/TABLE … VALUE_FORMAT='AVRO'` 等で **`<topic>-value` の最新スキーマ**を取りに行くため）。

---

# .NET（Confluent.Kafka + Confluent.SchemaRegistry.Serdes）での典型設定

```csharp
var srConfig = new SchemaRegistryConfig {
    Url = "http://schemaregistry:8081",
    // 認証が必要なら Basic.Auth.UserInfo なども設定
};

var avroSerConfig = new AvroSerializerConfig {
    // ★ 自動登録をON
    AutoRegisterSchemas = true,
    // 既存最新バージョンを常に使いたいなら（再登録せず ID を取り直す）：
    // UseLatestVersion = true,
    // ★ SubjectNameStrategy は ksqlDB 基本運用なら Topic
    SubjectNameStrategy = SubjectNameStrategy.Topic
    // 例：Record にするときは SubjectNameStrategy = SubjectNameStrategy.Record
};
```

キー/バリューで *別の戦略* にしたい場合は、`IAsyncSerializer<TKey>`/`IAsyncSerializer<TValue>` の生成時に個別設定を渡します（**キーは `<topic>-key`、バリューは `<topic>-value`** で揃えるのが ksqlDB では定番）。

---

# 送出フロー（シリアライザ内部のざっくり擬似シーケンス）

```
Produce<TValue>(topic, value):
  subject = ResolveSubject(topic, value, strategy=TopicName or RecordName...)
  schema = ExtractSchemaFrom(value) // Avroならレコード型のSchema
  if AutoRegisterSchemas:
       id = SR.LookupIdBySchema(subject, schema)
       if not found:
           EnsureCompatibility(subject, schema)  // SR側で実施
           id = SR.Register(subject, schema)     // バージョン+ID採番
  else:
       // 登録しない方針の場合：既存前提
       id = SR.LookupIdBySchema(subject, schema) // 見つからなければエラー

  payload = [0x00] + Int32BE(id) + SerializeBody(schema, value)
  KafkaProducer.Produce(topic, payload)
```

- `UseLatestVersion=true` の場合：**登録せず**「サブジェクトの最新スキーマID」を毎回取得して使う挙動に切り替わります（スキーマ内容は SR 側の最新に依存）。

---

# ksqlDB との関係（ここがハマりどころ）
- ksqlDB の `CREATE STREAM/TABLE` を **カラム省略**＋`VALUE_FORMAT='AVRO'` 等で作ると、**`<topic>-value` の最新スキーマ**を **SR から引いてカラムを推論**します。  
  → **サブジェクトが TopicName で登録されていること**が前提になります。
- 逆に **カラムを明示定義**した場合は、ksqlDB は SR に頼らずその定義で作ります（ただし `FORMAT` によっては互換性が必要）。
- **「スキーマIDをDDLに埋め込む」ことはできません。** ksqlDB の DDL は *ID 指定ではなく* サブジェクトの最新や直接のカラム定義で決まります。
- **同じトピックに異なる登録方針が混在**（例：片方が RecordName、片方が TopicName）すると、ksqlDB が見に行く `<topic>-value` に適切なスキーマが無くて **解決不能**になりがちです。

> **結論**：同一トピックを使う系は **全プロデューサで SubjectNameStrategy を統一**（通常は `TopicName`）し、ksqlDB の DDL もそれに合わせる。

---

# よくある失敗と対処
1) **互換性違反で登録失敗**  
   - Schema Registry の **Compatibility** を見直す（BACKWARD など）。  
   - 互換性が保てない変更（必須フィールドの追加等）は**別サブジェクト**または**別トピック**で設計する。

2) **同一トピックに複数の登録方式が混在**  
   - 全サービスの **SubjectNameStrategy を揃える**。  
   - 既存サブジェクトのスキーマが ksqlDB DDL とズレていないか確認。

3) **AutoRegisterSchemas=false で「ID見つからず」**  
   - 先に **手動登録（sr-cli/REST）** するか、起動時に **ウォームアップ登録**を行う。

4) **レコード名/namespace のブレで別物登録**  
   - Avro の **`[Namespace]`**/型名が変わると**別スキーマ**扱い。  
   - OSS/DSL 側で **統一プレフィックス**や **型配置規約**を決める。

5) **ksqlDB のコマンドトピック遅延/未稼働で DDL がタイムアウト**  
   - 起動順序と **再試行（指数バックオフ）**を入れる。  
   - 「辞書テーブルを最初に1件 INSERT まで通す」ウォームアップは有効（SR 経路と ksqlDB の command flow を**強制通過**させる）。

---

# 推奨運用（あなたの OSS/DSL 向け）
- **デフォルト**：`SubjectNameStrategy = Topic`、`AutoRegisterSchemas = true`。  
- **運用/本番**：  
  - スキーマ変更は **PR/CI でバリデーション** → 互換性OKなら **手前で先行登録**、本番は `AutoRegisterSchemas=false` で**登録不可**を早期検知、もアリ。  
- **ksqlDB DDL 方針**：  
  - 可能なら **カラム省略 + FORMAT 指定**で **SR から推論**（ズレが起きにくい）。  
  - 明示定義する場合は **SRと完全一致**させる（フィールド順・必須/オプションに注意）。  
- **マルチ登録回避**：  
  - Avro の **レコード名/namespace を固定規約化**（例：`Company.Project.Contracts.<Area>`）。  
  - 同一トピックを複数アプリが触る場合でも **SubjectNameStrategy を統一**。

---

# 最小コード例（C# Avro・TopicName・自動登録ON）

```csharp
using Confluent.Kafka;
using Confluent.SchemaRegistry;
using Confluent.SchemaRegistry.Serdes;

var producerConfig = new ProducerConfig {
    BootstrapServers = "kafka:9092",
    EnableIdempotence = true
};

var srConfig = new SchemaRegistryConfig { Url = "http://schemaregistry:8081" };

using var sr = new CachedSchemaRegistryClient(srConfig);
var valueSer = new AvroSerializer<MyEvent>(sr, new AvroSerializerConfig {
    AutoRegisterSchemas = true,
    SubjectNameStrategy = SubjectNameStrategy.Topic
});

using var producer = new ProducerBuilder<string, MyEvent>(producerConfig)
    .SetValueSerializer(valueSer)
    .Build();

await producer.ProduceAsync("orders", new Message<string, MyEvent> {
    Key = "k1",
    Value = new MyEvent { /* ... */ }
});
await producer.FlushAsync();
```

---

必要なら、**ksqlDB DDL と SR の突合せチェック手順**や、**SubjectNameStrategy 混在検出のための監査スクリプト**（サブジェクト一覧→topic に正規化して差分抽出）も用意できます。声かけてください。

— 送信日時（日本時間）: [[REDACTED_PHONE]]:52

### assistant — 2025-09-01T00:52:35.407987+00:00

_(empty)_

### assistant — 2025-09-01T00:52:35.717236+00:00

_(empty)_

### user — 2025-09-01T00:53:57.627892+00:00

同一判断ロジックを説明

### system — 2025-09-01T00:53:57.777181+00:00

_(empty)_

### assistant — 2025-09-01T00:53:57.796233+00:00

やあ、いらっしゃい！  
「Produce時のスキーマ自動登録で“同一判断”をどうやってるか」の仕組みを整理しますね。  

---

# 🔎 同一判断ロジックの流れ

Schema Registry とクライアントライブラリ（AvroSerializer など）は、**「このスキーマは既に登録済みか？」** を判断するために、次のロジックを使っています。

## 1. サブジェクトの決定
- まず `SubjectNameStrategy`（TopicName, RecordName, TopicRecordName など）に基づいて「このスキーマが紐づくサブジェクト名」を決定します。  
  例: トピック `orders` の value → `orders-value`

## 2. スキーマの正規化
- Avro や JSON Schema の場合、クライアント側で **スキーマ定義を文字列化（canonical form）** します。
  - Avro → [Canonical Form](https://avro.apache.org/docs/current/spec.html#canonical_form) に準拠した JSON。
  - JSON Schema / Protobuf も似た仕組みで正規化。

## 3. Fingerprint（ハッシュ化）
- 正規化したスキーマを **SHA-256 などの fingerprint** に変換。  
- **文字列の見た目が違っても意味が同じスキーマなら同一とみなせる**ようにしている。

## 4. Registry 照会
- サブジェクトに紐づく **既存スキーマ一覧**を Schema Registry から取得。  
- Fingerprint で一致チェック → 一致すれば「既存の Schema ID」を再利用。  
- 一致がなければ新規登録し、Schema Registry 側で新しい ID を採番。

---

# ⚙️ 判断例

| ケース | 結果 |
|--------|------|
| フィールド順が同じ、型も同じ | **同一とみなす**（再登録なし） |
| フィールド順が同じだが default 値が違う | **別スキーマ**（新しいID） |
| 名前空間（namespace）が違う | **別スキーマ** |
| フィールドを追加（互換性ルールによりOK/NGが決まる） | **別スキーマ**だが互換性があれば登録可能 |
| JSON文字列のインデントだけが違う | **同一とみなす**（canonical化されるので差異消滅） |

---

# 🧩 ksqlDB 側の挙動との関係

- **ksqlDB は Schema ID ではなくサブジェクト単位**で最新スキーマを参照する。  
- よって「同一判断」は **Producer → Schema Registry** 間での話であり、  
  ksqlDB 側は「そのサブジェクトの最新版を取る」か「CREATE DDL で明示定義する」かのどちらか。

---

# ✅ まとめ

- **同一判断は “canonical form → fingerprint” の一致判定で行う**。  
- 見た目のJSONが違っても意味が同じなら同一扱い。  
- namespace/フィールド追加/デフォルト値変更などは別スキーマとして扱われ、新しい Schema ID が振られる。  
- ksqlDB は ID 直接指定できないので、サブジェクトを揃えることが重要。  

---

司令、もしよければ「同一判断で微妙なケース（例：default 値の違い、nullable の扱い）」を深堀りして整理しますか？  

— 送信日時（日本時間）: [[REDACTED_PHONE]]:19

### system — 2025-09-01T00:53:57.829593+00:00

_(empty)_
