---
conversation_id: "678f59df-63c8-8007-8343-b749a1687d6c"
title: "C# try finally 解決策"
create_time: 1737447903.642313
update_time: 1737447919.48235
language_guess: "en"
num_messages: 5
part_index: 1
part_count: 1
---

### system — 2025-01-21T08:25:03.642313+00:00

_(empty)_

### user — 2025-01-21T08:25:03.644956+00:00

C#ではtry finallyの構文でtry内で生成したインスタンスをfinallyブロックで参照できない。解決策を

### assistant — 2025-01-21T08:25:18.155927+00:00

_(empty)_

### assistant — 2025-01-21T08:25:18.156015+00:00

C#では、`try`ブロック内で宣言された変数は、そのスコープが`try`ブロック内に限定されるため、`finally`ブロックで参照することができません。この問題を解決するには、`try`ブロックの外側で変数を宣言することで、`finally`ブロックからアクセスできるようにします。

以下に解決策を示します。

### 解決策: 外側で変数を宣言する
`try`ブロックの外側で変数を宣言しておくことで、`finally`ブロックでその変数を参照できます。

```csharp
StreamReader reader = null;
try
{
    reader = new StreamReader("example.txt");
    string line = reader.ReadLine();
    Console.WriteLine(line);
}
finally
{
    if (reader != null)
    {
        reader.Dispose(); // リソースを解放する
    }
}
```

### 解決策: `using`構文を使用する
リソースの解放を目的とする場合は、`using`構文を使用することでコードを簡潔に書けます。`using`構文では、`Dispose`が自動的に呼び出されます。

```csharp
using (var reader = new StreamReader("example.txt"))
{
    string line = reader.ReadLine();
    Console.WriteLine(line);
}
```

### 解決策: `Nullable`型を使用する（参照型以外の場合）
値型のインスタンスを`try`ブロックで生成して、`finally`ブロックで参照したい場合は、`Nullable`型を使うことができます。

```csharp
int? result = null;
try
{
    result = int.Parse("123");
}
finally
{
    if (result.HasValue)
    {
        Console.WriteLine($"Parsed value: {result.Value}");
    }
}
```

この方法で、`try`ブロックの外に変数を宣言しつつ、適切に`finally`ブロックで参照できます。
