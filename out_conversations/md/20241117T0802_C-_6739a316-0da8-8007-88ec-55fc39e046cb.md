---
conversation_id: "6739a316-0da8-8007-88ec-55fc39e046cb"
title: "C# マイクロ秒計測方法"
create_time: 1731830550.273438
update_time: 1731831351.653479
language_guess: "en"
num_messages: 10
part_index: 1
part_count: 1
---

### system — 2024-11-17T08:02:30.273438+00:00

_(empty)_

### user — 2024-11-17T08:02:30.279370+00:00

C#でパフォーマンス計測対象の処理能力がマイクロ秒である場合、どのように計測すればいいのか

### assistant — 2024-11-17T08:02:49.172841+00:00

_(empty)_

### assistant — 2024-11-17T08:02:49.173050+00:00

C#でマイクロ秒レベルのパフォーマンスを計測するには、高精度な計測が可能な `Stopwatch` クラスを使用するのが一般的です。以下に手順を示します。

---

### 1. **`Stopwatch` クラスを使用**
`Stopwatch` は高分解能タイマーを提供し、計測時間をナノ秒レベルで記録しますが、時間の単位を簡単にマイクロ秒に変換できます。

```csharp
using System;
using System.Diagnostics;

class Program
{
    static void Main()
    {
        // 計測対象の処理
        Action actionToMeasure = () =>
        {
            // 処理の例：何か計測対象のロジック
            for (int i = 0; i < 1000; i++) { }
        };

        // Stopwatchを使用して計測
        Stopwatch stopwatch = Stopwatch.StartNew();
        actionToMeasure();
        stopwatch.Stop();

        // 計測結果をマイクロ秒に変換
        long elapsedMicroseconds = stopwatch.ElapsedTicks * 1_000_000 / Stopwatch.Frequency;

        Console.WriteLine($"処理時間: {elapsedMicroseconds} マイクロ秒");
    }
}
```

- `Stopwatch.Frequency` は、タイマーが1秒間に刻むカウント数（ティック数）を表します。
- `ElapsedTicks` は計測中に記録されたティック数です。
- 上記を基に、マイクロ秒（`1_000_000分の1秒`）に変換しています。

---

### 2. **精度確認**
`Stopwatch.IsHighResolution` プロパティで、使用しているタイマーが高分解能タイマーか確認できます。以下のようにチェックします：

```csharp
Console.WriteLine($"IsHighResolution: {Stopwatch.IsHighResolution}");
Console.WriteLine($"Frequency: {Stopwatch.Frequency} ticks/second");
```

- 高分解能タイマーの場合、`Stopwatch.Frequency` が1秒あたり数百万ティック以上になります（例: 3 GHz CPU なら 3,000,000,000）。

---

### 3. **平均化**
処理能力がマイクロ秒レベルの場合、計測誤差を減らすために複数回計測し、その平均を取ることが推奨されます。

```csharp
long totalTicks = 0;
int iterations = 100;

for (int i = 0; i < iterations; i++)
{
    Stopwatch sw = Stopwatch.StartNew();
    actionToMeasure();
    sw.Stop();
    totalTicks += sw.ElapsedTicks;
}

long averageMicroseconds = (totalTicks / iterations) * 1_000_000 / Stopwatch.Frequency;
Console.WriteLine($"平均処理時間: {averageMicroseconds} マイクロ秒");
```

---

### 4. **条件付きで代替案**
場合によっては、外部ライブラリやOS特有のAPI（例: Windows の `QueryPerformanceCounter`）を使うことで、さらに精密な計測を行うこともできます。ただし、`Stopwatch` はその内部実装でこれらを活用しているため、通常は `Stopwatch` を使用するだけで十分です。

---

### 注意事項
- 計測対象のコードが極めて短い場合、計測自体のオーバーヘッドを考慮する必要があります。この場合、処理を繰り返し実行して累積時間を測定し、1回あたりの時間を割り出すのが有効です。
- ガベージコレクション（GC）の影響を受けないよう、計測前にGCを強制実行することも考慮してください。
```csharp
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();
```

このように、`Stopwatch` と工夫を組み合わせることで、マイクロ秒レベルの計測が可能です。

### user — 2024-11-17T08:14:32.683862+00:00

必要に応じてログに出力する。ログが多くなるとパフォーマンスに影響するのでそこを考慮に入れてほしい

### assistant — 2024-11-17T08:14:53.100001+00:00

_(empty)_

### assistant — 2024-11-17T08:14:53.100170+00:00

ログ出力を必要に応じて行い、ログがパフォーマンスに与える影響を最小限にする方法を検討するためには、以下のようなアプローチを取ることが考えられます。

---

## 1. **ログ出力の基本設計**

### **条件付きログ**
ログ出力の条件を柔軟に制御できるように、ログレベルを設定します。例えば、デバッグやトレースログを開発環境でのみ出力するようにし、本番環境では重要なログ（エラーや警告）のみを出力する設定を行います。

```csharp
using Microsoft.Extensions.Logging;

ILogger logger = ...; // 依存性注入で取得する例
if (logger.IsEnabled(LogLevel.Debug))
{
    logger.LogDebug("処理時間: {ElapsedMilliseconds} ミリ秒", elapsedMilliseconds);
}
```

---

## 2. **ログによるパフォーマンス低下の軽減**

### **非同期ログ**
ログ出力を非同期で行うことで、処理のボトルネックを軽減します。多くのロギングライブラリ（例: `Serilog`, `NLog`, `Microsoft.Extensions.Logging`）は非同期ログ機能を提供しています。

#### **Serilog の例**
Serilog では、非同期ログを以下のように設定できます。

```csharp
Log.Logger = new LoggerConfiguration()
    .WriteTo.Async(a => a.File("logs/log.txt"))
    .CreateLogger();
```

この設定により、ログ書き込みがバックグラウンドスレッドで実行されます。

---

### **バッファリング**
ログを一定のバッチサイズまたはタイムアウト間隔でまとめて書き込むように設定します。これにより、ログ出力回数を減らしてパフォーマンスを向上させます。

#### **NLog の例**
NLog では、`BufferingWrapper` を使用してログのバッファリングが可能です。

```xml
<targets>
  <target xsi:type="File" name="fileTarget" fileName="logs/log.txt">
    <wrapper xsi:type="BufferingWrapper" bufferSize="50" flushTimeout="5000">
      <target-ref name="fileTarget" />
    </wrapper>
  </target>
</targets>
```

- `bufferSize`: ログをまとめて出力する件数
- `flushTimeout`: バッファをフラッシュするタイミング（ミリ秒）

---

## 3. **処理対象がマイクロ秒単位の場合の工夫**

ログの出力頻度が多くなるとパフォーマンス低下の原因になります。そのため、ログ出力を最小限に抑える工夫をします。

### **一定の閾値を超えた場合のみログを出力**
処理時間が閾値を超えた場合のみログを出力します。

```csharp
long thresholdMicroseconds = 100; // 閾値（例: 100マイクロ秒）
if (elapsedMicroseconds > thresholdMicroseconds)
{
    logger.LogWarning("処理時間が閾値を超えました: {ElapsedMicroseconds} μs", elapsedMicroseconds);
}
```

---

### **サンプリング**
すべてのログを記録せず、一部のみをログに残します。これにより、ログ量を抑えつつ問題の分析に必要な情報を取得できます。

```csharp
Random random = new Random();
double samplingRate = 0.1; // 10% の確率でログを記録
if (random.NextDouble() < samplingRate)
{
    logger.LogInformation("処理時間: {ElapsedMicroseconds} μs", elapsedMicroseconds);
}
```

---

## 4. **ログの書き込み先を考慮**

### **メモリ内ログ**
一時的なログをメモリ内に保存し、必要に応じてファイルや外部サービスに出力します。これにより、不要なログ書き込みを削減できます。

#### **Microsoft.Extensions.Logging におけるメモリ内ログ**
`MemoryLoggerProvider` を使用してログをキャッシュし、後で必要なログのみを処理します。

---

### **ロギングインフラを活用**
大量のログデータを処理する場合、適切なロギングインフラを導入することを検討します（例: `ELK Stack`, `Datadog`, `Azure Monitor`）。

---

## 5. **具体例**

以下は、パフォーマンスを考慮したC#コードの例です。

```csharp
using System.Diagnostics;
using Microsoft.Extensions.Logging;

class Program
{
    private static readonly ILogger<Program> logger = LoggerFactory.Create(builder =>
    {
        builder.AddConsole();
    }).CreateLogger<Program>();

    static void Main()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        // 計測対象の処理
        ProcessTask();

        stopwatch.Stop();
        long elapsedMicroseconds = stopwatch.ElapsedTicks * 1_000_000 / Stopwatch.Frequency;

        // ログ出力（閾値とサンプリングを考慮）
        long thresholdMicroseconds = 100;
        double samplingRate = 0.1;
        if (elapsedMicroseconds > thresholdMicroseconds || new Random().NextDouble() < samplingRate)
        {
            logger.LogInformation("処理時間: {ElapsedMicroseconds} μs", elapsedMicroseconds);
        }
    }

    static void ProcessTask()
    {
        // 計測対象の処理
        for (int i = 0; i < 1000; i++) { }
    }
}
```

---

このように、ログ出力によるパフォーマンス低下を軽減しつつ、必要な情報を記録するバランスを保てます。

### user — 2024-11-17T08:15:28.868496+00:00

Contextを利用するのはどうか

### assistant — 2024-11-17T08:15:51.190261+00:00

`Context` を利用するアプローチは、ログ出力の制御や情報の関連付けに非常に有効です。特に、処理のトラッキングや必要最小限のログ出力を実現する場合に役立ちます。以下に具体的な方法を示します。

---

## 1. **`AsyncLocal` を利用した Context の導入**

`AsyncLocal` を使うことで、スレッドや非同期タスクごとに異なるコンテキスト情報を保持できます。これを活用して、処理ごとに必要なログ情報を動的に追加することが可能です。

### **実装例**

以下の例では、処理のトラッキングIDを `Context` に格納し、ログ出力に含めています。

```csharp
using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

class Program
{
    private static readonly AsyncLocal<string> _context = new AsyncLocal<string>();
    private static readonly ILogger<Program> logger = LoggerFactory.Create(builder =>
    {
        builder.AddConsole();
    }).CreateLogger<Program>();

    static async Task Main()
    {
        // コンテキスト設定（例: トラッキングID）
        _context.Value = Guid.NewGuid().ToString();

        await ProcessTaskAsync();
    }

    static async Task ProcessTaskAsync()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        // 計測対象の処理
        await Task.Delay(100); // 例: 実際の処理

        stopwatch.Stop();
        long elapsedMicroseconds = stopwatch.ElapsedTicks * 1_000_000 / Stopwatch.Frequency;

        // コンテキストを使ったログ出力
        logger.LogInformation("処理時間: {ElapsedMicroseconds} μs, トラッキングID: {TrackingId}", 
            elapsedMicroseconds, _context.Value);
    }
}
```

- **ポイント**:
  - `_context` を利用してトラッキングIDをスレッド/タスクごとに管理。
  - ログ出力に `_context.Value` を含めて処理の関連性を記録。

---

## 2. **`LogContext` を使った実装（Serilogの場合）**

`Serilog` では `LogContext` を使用して、一時的なコンテキスト情報を簡単にログに含めることができます。

### **実装例**

以下の例では、`using` スコープ内でコンテキスト情報を設定し、そのスコープで発生したログに自動的に含めています。

```csharp
using Serilog;
using Serilog.Context;
using System;
using System.Diagnostics;

class Program
{
    static void Main()
    {
        Log.Logger = new LoggerConfiguration()
            .Enrich.FromLogContext()
            .WriteTo.Console()
            .CreateLogger();

        // コンテキストを設定
        using (LogContext.PushProperty("TrackingId", Guid.NewGuid()))
        {
            ProcessTask();
        }
    }

    static void ProcessTask()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        // 計測対象の処理
        for (int i = 0; i < 1000; i++) { }

        stopwatch.Stop();
        long elapsedMicroseconds = stopwatch.ElapsedTicks * 1_000_000 / Stopwatch.Frequency;

        // 自動的に TrackingId が含まれる
        Log.Information("処理時間: {ElapsedMicroseconds} μs", elapsedMicroseconds);
    }
}
```

- **ポイント**:
  - `LogContext.PushProperty` でコンテキスト情報を設定。
  - `Enrich.FromLogContext` を有効にすることで、コンテキスト情報が自動的にログに追加される。

---

## 3. **独自の Context 管理クラスを作成**

独自の `Context` クラスを作成し、必要な情報を格納する方法もあります。このアプローチでは、柔軟性が向上し、複数のプロパティを管理できます。

### **実装例**

```csharp
public class LogContext
{
    private static readonly AsyncLocal<LogContext> _current = new AsyncLocal<LogContext>();

    public static LogContext Current
    {
        get => _current.Value ??= new LogContext();
        set => _current.Value = value;
    }

    public string TrackingId { get; set; }
    public string UserId { get; set; }
}
```

このクラスを使用して、コンテキストを設定し、ログに活用します。

```csharp
LogContext.Current.TrackingId = Guid.NewGuid().ToString();
LogContext.Current.UserId = "User123";

logger.LogInformation("処理時間: {ElapsedMicroseconds} μs, トラッキングID: {TrackingId}, ユーザーID: {UserId}",
    elapsedMicroseconds, LogContext.Current.TrackingId, LogContext.Current.UserId);
```

---

## 4. **Context を利用したログ削減の工夫**

コンテキスト情報を利用して、条件付きでログ出力を制御できます。

### **例: トラッキングIDごとにログを抑制**

```csharp
HashSet<string> loggedTrackingIds = new HashSet<string>();

if (!loggedTrackingIds.Contains(LogContext.Current.TrackingId))
{
    logger.LogInformation("重要なログ: {Message}", "ここに重要な情報");
    loggedTrackingIds.Add(LogContext.Current.TrackingId);
}
```

---

## 5. **Context + 非同期処理の注意点**

非同期処理で `Context` を使用する場合、`AsyncLocal` がスレッドやタスク間で正しく引き継がれることを確認します。引き継ぎが必要ない場合、意図的にクリアすることも可能です。

```csharp
LogContext.Current = null; // 必要に応じてクリア
```

---

このように `Context` を活用すれば、ログの関連性を強化しつつ、必要最小限の出力でパフォーマンスを維持できます。
