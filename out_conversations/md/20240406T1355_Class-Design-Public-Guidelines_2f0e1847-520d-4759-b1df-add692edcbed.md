---
conversation_id: "2f0e1847-520d-4759-b1df-add692edcbed"
title: "Class Design: Public Guidelines"
create_time: 1712411723.740057
update_time: 1712411917.259474
language_guess: "en"
num_messages: 14
part_index: 1
part_count: 1
---

### system — 2024-04-06T13:55:23.740057+00:00

_(empty)_

### user — 2024-04-06T13:55:23.741131+00:00

C#のクラス設計について、publicとすべき判断基準は

### assistant — 2024-04-06T13:55:31.743099+00:00

C#のクラス設計において、`public`にするべきかどうかを判断する際に考慮すべきいくつかの基準があります。以下に挙げるいくつかの基準は、クラスの目的や設計によって異なる場合がありますが、一般的な考慮事項です。

1. **カプセル化の原則を考慮する**: カプセル化は、情報隠蔽の原則を指し、クラス内のデータやメソッドを隠蔽して直接アクセスできないようにすることです。クラスのデータやメソッドが他のクラスから直接アクセスされる必要がない場合は、`public`にしないでください。その代わりに、必要に応じてプロパティやメソッドを`private`や`protected`にし、適切な公開インターフェースを提供します。

2. **外部からのアクセスが必要な場合**: クラスの機能やデータが他のクラスやモジュールから利用される必要がある場合は、それらを`public`にします。これにより、他の部分から簡単にアクセスできるようになります。

3. **再利用と拡張性を考慮する**: クラスを設計する際に、将来的な変更や拡張に備えて、公開されるべき機能やデータを考慮する必要があります。将来的な拡張を容易にするために、クラスの一部を`public`にして他のクラスがこれを拡張できるようにすることがあります。

4. **セキュリティを考慮する**: `public`にした場合、他のコードからアクセスできる可能性が高まります。セキュリティ上の懸念があるデータや機能は、適切なアクセス制御を施すか、`private`にしてアクセスを制限する必要があります。

5. **ドキュメントとコードの理解性**: クラスやそのメンバーが`public`である場合、それらはライブラリの一部として利用される可能性があります。そのため、適切なドキュメントやコメントを付けて、他の開発者がコードを理解しやすくする必要があります。

これらの基準を考慮して、各クラスやそのメンバーがどのように利用され、他のコードとどのように統合されるかを考え、適切なアクセス修飾子を選択してください。

### user — 2024-04-06T13:56:11.707941+00:00

public以外のクラス、メソッドに対してUnitTestをコード化する方法

### assistant — 2024-04-06T13:56:19.513615+00:00

`public`以外のクラスやメソッドに対してユニットテストを実装する方法は、通常のテストケースを書くのと同じですが、テストプロジェクト内でアクセス可能な方法を使ってそれらをテストします。主に2つの方法があります。

1. **アクセス修飾子を変更する**: テストプロジェクト内で、テスト対象のクラスやメソッドにアクセスするために必要なメソッドやプロパティを`internal`に変更します。これにより、テストコードからテスト対象の非`public`メンバーにアクセスできるようになります。ただし、これはテストコードが本来のライブラリの内部構造に依存することになり、将来の変更に対して脆弱になる可能性があるため、注意が必要です。

```csharp
// テスト対象のクラス
internal class MyClass
{
    internal int MyMethod()
    {
        return 42;
    }
}

// テストプロジェクト内のテストコード
[TestClass]
public class MyClassTests
{
    [TestMethod]
    public void MyMethod_ReturnsExpectedValue()
    {
        // Arrange
        var myClass = new MyClass();

        // Act
        var result = myClass.MyMethod();

        // Assert
        Assert.AreEqual(42, result);
    }
}
```

2. **リフレクションを使用する**: リフレクションを使って、非`public`メンバーにアクセスすることもできます。これにより、テストコードはアクセス修飾子を変更することなく、テスト対象の非`public`メンバーにアクセスできますが、リフレクションを使ったコードは通常のコードよりも複雑になる可能性があります。

```csharp
// テスト対象のクラス
internal class MyClass
{
    private int MyPrivateMethod()
    {
        return 42;
    }
}

// テストプロジェクト内のテストコード
[TestClass]
public class MyClassTests
{
    [TestMethod]
    public void MyPrivateMethod_ReturnsExpectedValue()
    {
        // Arrange
        var myClass = new MyClass();
        var methodInfo = typeof(MyClass).GetMethod("MyPrivateMethod", BindingFlags.NonPublic | BindingFlags.Instance);

        // Act
        var result = (int)methodInfo.Invoke(myClass, null);

        // Assert
        Assert.AreEqual(42, result);
    }
}
```

どちらの方法を使用するかは、プロジェクトの要件や設計によって異なります。ただし、`internal`を使用する方法が一般的にはより簡潔で保守的であると考えられます。

### user — 2024-04-06T13:56:43.960737+00:00

テストコードが紛れ込むことになるが

### assistant — 2024-04-06T13:56:51.578909+00:00

テストコードが本来のコードと混ざることは、問題のある実装方法です。しかし、非`public`なメンバーをテストする必要がある場合、どうしてもテストコードが本来のコードに紛れ込むことがあります。

このような場合、以下のいくつかのアプローチが役立つかもしれません。

1. **部分クラスを使用する**: テスト対象のクラスの機能を2つの部分に分割し、1つは本来の実装を含み、もう1つはテスト用の実装を含む部分クラスを作成します。テスト用の部分クラスは、`public`なメンバーを持ち、テストコードからアクセス可能です。これにより、テストコードが本来のコードと分離され、整理された構造が保たれます。

2. **テスト用のアセンブリを作成する**: テスト用のアセンブリを作成し、テスト対象のコードの`internal`メンバーにアクセスできるようにします。これにより、テスト用のコードが本来のコードから分離されますが、アセンブリの構造が複雑になる可能性があります。

3. **テスト用のフレームワークを使用する**: 特定のフレームワークやライブラリを使用して、`internal`なメンバーをテストするための仕組みを提供することができます。例えば、`InternalsVisibleToAttribute`を使用して、指定したアセンブリから内部メンバーにアクセスできるようにすることができます。

4. **リフレクションを使用する**: 先ほど述べたように、リフレクションを使用してテストすることも可能ですが、コードが複雑になる可能性があります。

これらのアプローチは、それぞれのプロジェクトや要件に合わせて選択することができます。ただし、いずれの場合でも、テストコードと本来のコードを分離し、テストコードの整理を心がけることが重要です。

### user — 2024-04-06T13:57:26.682104+00:00

InternalsVisibleToAttributeとは

### assistant — 2024-04-06T13:57:32.505633+00:00

`InternalsVisibleToAttribute`は、.NETのアセンブリ内で非公開メンバーに対してテストを行うために使用される属性です。この属性を使用すると、指定した別のアセンブリから、`internal`なクラスやメンバーにアクセスすることができます。

通常、C#でテストを行う場合、テスト対象のコードは通常のプロジェクトに含まれますが、テストコードは別のプロジェクトに含まれます。しかし、`internal`なメンバーは同じアセンブリ内からのみアクセス可能であり、テストプロジェクトからはアクセスできません。そのため、`InternalsVisibleToAttribute`を使用して、テストプロジェクトからテスト対象のコードの`internal`なメンバーにアクセスできるようにすることができます。

具体的には、`InternalsVisibleToAttribute`を使用して、テストプロジェクトのアセンブリ名を指定します。これにより、指定したアセンブリからテスト対象のアセンブリ内の`internal`なメンバーにアクセスできるようになります。

例えば、以下のように使用します。

```csharp
// テスト対象のアセンブリのAssemblyInfo.csに追加
[assembly: InternalsVisibleTo("MyTestProject")]

// テスト対象のクラス
internal class MyClass
{
    internal int MyMethod()
    {
        return 42;
    }
}
```

上記の例では、`MyTestProject`という名前のテストプロジェクトから、`MyClass`の`internal`なメソッドにアクセスできるようになります。

この属性を使用することで、テストコードと本来のコードを分離し、テストをより簡潔に行うことができます。

### user — 2024-04-06T13:58:02.772039+00:00

XUnitから参照できるのか

### assistant — 2024-04-06T13:58:07.070921+00:00

はい、XUnitからも`InternalsVisibleToAttribute`を使用して、他のアセンブリから`internal`なメンバーにアクセスできるようにすることができます。XUnitを使用する場合でも、同じ方法で`InternalsVisibleToAttribute`を設定してテストプロジェクトから`internal`なメンバーにアクセスできるようにすることができます。

以下は、XUnitを使用した場合の例です。

```csharp
// テスト対象のアセンブリのAssemblyInfo.csに追加
[assembly: InternalsVisibleTo("MyTestProject.Test")]

// テスト対象のクラス
internal class MyClass
{
    internal int MyMethod()
    {
        return 42;
    }
}
```

ここで、`MyTestProject.Test`はXUnitで使用されるテストプロジェクトのアセンブリ名を表します。これにより、XUnitを使用している場合でも、同じく`internal`なメンバーにアクセスできるようになります。

ただし、注意点として、`InternalsVisibleToAttribute`を使用すると、他のアセンブリから`internal`なメンバーにアクセスできるため、セキュリティ上のリスクが発生する可能性があります。したがって、アクセスが制限される必要がある場合や、セキュリティ上の懸念がある場合は、適切な検討を行ってください。

### user — 2024-04-06T13:58:32.345884+00:00

private メソッドにアクセスできるのか

### assistant — 2024-04-06T13:58:37.108621+00:00

`InternalsVisibleToAttribute`を使用して他のアセンブリから`internal`なメンバーにアクセスできるようにすることは可能ですが、`private`なメソッドについてはこの属性を使って他のアセンブリから直接アクセスすることはできません。

`private`なメソッドはそのクラス内からのみアクセス可能であり、他のクラスやアセンブリからは直接アクセスできません。`internal`なメンバーはそのアセンブリ内からはアクセスできますが、`private`なメソッドは更にそのクラス内からしかアクセスできないため、`InternalsVisibleToAttribute`を使っても他のアセンブリから直接アクセスすることはできません。

`private`なメソッドをテストする場合、通常はリフレクションを使用して、そのメソッドに間接的にアクセスする方法があります。ただし、この方法はコードが複雑になる可能性があるため、適切な検討が必要です。また、`private`なメソッドが多用される場合、その設計について再考することも一考する価値があります。
