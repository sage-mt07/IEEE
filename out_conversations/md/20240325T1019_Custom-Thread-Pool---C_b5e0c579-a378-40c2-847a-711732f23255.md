---
conversation_id: "b5e0c579-a378-40c2-847a-711732f23255"
title: "Custom Thread Pool - C#"
create_time: 1711361991.839033
update_time: 1711362163.022349
language_guess: "en"
num_messages: 6
part_index: 1
part_count: 1
---

### system — 2024-03-25T10:19:51.839033+00:00

_(empty)_

### user — 2024-03-25T10:19:51.839642+00:00

C#で独自のスレッドプールを使用する

### assistant — 2024-03-25T10:20:53.925051+00:00

C#で独自のスレッドプールを使用する方法を解説します。独自のスレッドプールを実装することで、特定のタスクに合わせてスレッドの管理やキューイングの挙動をカスタマイズできます。以下は簡単な独自スレッドプールの実装例です。

### 基本的なスレッドプールの実装

1. **スレッドの管理を行うクラスの作成**  
   スレッドを管理するクラスを作成し、内部にスレッドのリストとタスクのキューを持たせます。

2. **タスクの追加**  
   外部からタスク（アクションや関数）を追加できるようにメソッドを提供します。タスクはキューに保存されます。

3. **スレッドの実行と監視**  
   スレッドプールに追加されたタスクを実行するスレッドを生成し、タスクの実行が完了したら次のタスクをキューから取り出して実行します。

### サンプルコード

以下のコードは、上記の概念を簡単に実装したものです。タスクの追加と、それを実行するための基本的なスレッドプールの構造を示しています。

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading;

public class SimpleThreadPool
{
    private readonly ConcurrentQueue<Action> _taskQueue = new ConcurrentQueue<Action>();
    private readonly int _numberOfThreads;
    private bool _isStopped = false;

    public SimpleThreadPool(int numberOfThreads)
    {
        _numberOfThreads = numberOfThreads;
        StartThreads();
    }

    private void StartThreads()
    {
        for (int i = 0; i < _numberOfThreads; i++)
        {
            Thread thread = new Thread(Worker)
            {
                IsBackground = true
            };
            thread.Start();
        }
    }

    private void Worker()
    {
        while (!_isStopped)
        {
            if (_taskQueue.TryDequeue(out Action task))
            {
                task.Invoke();
            }
            else
            {
                Thread.Sleep(100); // 待機時間を設定してリソースの無駄遣いを防ぐ
            }
        }
    }

    public void EnqueueTask(Action task)
    {
        if (!_isStopped)
        {
            _taskQueue.Enqueue(task);
        }
    }

    public void Stop()
    {
        _isStopped = true;
    }
}
```

このコードでは、`SimpleThreadPool` クラス内でスレッドを管理し、外部からタスクをキューに追加できます。スレッドはキューを監視し、タスクが存在する場合はそれを実行します。この基本例を拡張して、エラーハンドリングやスレッドの再利用、タスクの優先順位付けなど、より複雑な機能を実装できます。

独自のスレッドプールを実装する際は、タスクの追加や取り出しをスレッドセーフに行うため、`ConcurrentQueue` や他のスレッドセーフなコレクションを使用することが重要です。また、リソースの無駄を防ぐため、タスクがない時はスレッドを適切に待機させる必要があります。

### user — 2024-03-25T10:21:46.053088+00:00

Task.invoke内部から非同期のリクエストがある場合は?

### assistant — 2024-03-25T10:22:43.013810+00:00

`Task.Invoke`内部で非同期のリクエストを扱う場合、タスクの実行を非同期にする必要があります。ただし、`SimpleThreadPool`の実装例では、タスクを同期的に処理しています。非同期リクエストを扱うには、いくつかの方法がありますが、一つのアプローチは`Task`を使用して非同期操作をサポートすることです。

非同期タスクをスレッドプールに追加する場合、アクションではなく`Func<Task>`をキューに入れることになります。これにより、非同期操作を実行し、完了するまで待機することができます。ただし、この方法ではスレッドがブロッキングされることなく、非同期操作の完了を待つことが可能になります。

以下のコードは、非同期操作をサポートするための`SimpleThreadPool`の改良版です。

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;

public class AsyncSimpleThreadPool
{
    private readonly ConcurrentQueue<Func<Task>> _taskQueue = new ConcurrentQueue<Func<Task>>();
    private readonly int _numberOfThreads;
    private bool _isStopped = false;

    public AsyncSimpleThreadPool(int numberOfThreads)
    {
        _numberOfThreads = numberOfThreads;
        StartThreads();
    }

    private void StartThreads()
    {
        for (int i = 0; i < _numberOfThreads; i++)
        {
            Thread thread = new Thread(async () => await Worker())
            {
                IsBackground = true
            };
            thread.Start();
        }
    }

    private async Task Worker()
    {
        while (!_isStopped)
        {
            if (_taskQueue.TryDequeue(out Func<Task> task))
            {
                await task();
            }
            else
            {
                Thread.Sleep(100); // 非同期操作がない場合はスレッドを待機させます
            }
        }
    }

    public void EnqueueTask(Func<Task> task)
    {
        if (!_isStopped)
        {
            _taskQueue.Enqueue(task);
        }
    }

    public void Stop()
    {
        _isStopped = true;
    }
}
```

このコードでは、`ConcurrentQueue<Func<Task>>`を使用して非同期タスクをキューに入れ、`Worker`メソッド内で非同期タスクを`await`しています。これにより、非同期のHTTPリクエストやデータベース操作など、任意の非同期操作を含むタスクをスレッドプールで処理できるようになります。

非同期操作を含むタスクを追加するには、以下のようにします。

```csharp
var pool = new AsyncSimpleThreadPool(4); // 例えば、スレッドプールを4つのスレッドで初期化

pool.EnqueueTask(async () =>
{
    // ここに非同期操作を記述
    await Task.Delay(1000); // 例: 1秒待機
    Console.WriteLine("非同期タスク完了");
});
```

このアプローチでは、非同期タスクが効率的に処理され、スレッドが非同期操作の完了をブロッキングすることなく、他のタスクに移ることができます。
