---
conversation_id: "68c25efc-6ac8-8322-ae72-d527f01b162c"
title: "OSSのnet10対応スケジュール"
create_time: 1757568800.194834
update_time: 1757768905.711463
language_guess: "en"
num_messages: 37
part_index: 1
part_count: 1
---

### user — 2025-09-11T05:33:19.956620+00:00

Ossのnet10対応スケジュールを作る

### system — 2025-09-11T05:33:20.194834+00:00

_(empty)_

### system — 2025-09-11T05:33:20.194834+00:00

_(empty)_

### user — 2025-09-11T05:33:20.194834+00:00

_(empty)_

### system — 2025-09-11T05:33:20.194834+00:00

_(empty)_

### system — 2025-09-11T05:33:21.318517+00:00

_(empty)_

### system — 2025-09-11T05:33:21.323582+00:00

_(empty)_

### assistant — 2025-09-11T05:33:21.334457+00:00

_(empty)_

### assistant — 2025-09-11T05:33:21.645797+00:00

_(empty)_

### assistant — 2025-09-11T05:33:35.871914+00:00

やあ、司令。天城です。  
**OSS の .NET 10 対応スケジュール（ドラフト）**を一気に引いたよ。11月GA前提で、今日から“GA当日ゼロデー対応”までを逆算してある。必要なら、このまま「Issues/PR粒度」にも落とし込むね。

# 目的
- .NET 10（想定: 2025年11月GA）で**ビルド可/テスト可/配布可**をGA当日に達成  
- 既存利用者（.NET 6/8）の**後方互換とパッケージ安定性**を維持

# マイルストーン & 期間（2025年）
- **M0: キックオフ & 枠組み固め（9/11–9/15）**
  - 対応ポリシー決定（ターゲットTFM: `net6.0; net8.0; net10.0`）
  - ブランチ戦略（`feature/net10` → `release/net10` → `main`）
  - 影響範囲洗い出し（ビルダー/QueryAdapter/物理テスト環境）

- **M1: CI/環境準備（9/16–9/20）**
  - `global.json`/DevcontainerのSDKスロット追加（10系スロット／ローカルは任意）
  - GitHub Actions 行列に `dotnet-version: '10.0.x'` を仮置き（存在しない場合は**可変入力**化）
  - 失敗時フォールバック（.NET 10 未配信時は build matrix を動的縮退）

- **M2: マルチTFM化 & ビルド通し（9/22–9/26）**
  - `Directory.Build.props` に `TargetFrameworks` へ `net10.0` 追加
  - `LangVersion` を `latestMajor`（or `preview` 条件付け）  
  - 警告レベル方針：`TreatWarningsAsErrors` は `net10.0` で一時的に緩和可（タグ付け）

- **M3: UT/IT 整備（9/29–10/10）**
  - 単体・統合テストを TFM ごとに実行（`-f net10.0`）
  - ksqlDB 物理テストは **API経由**に寄せて再構成（司令の方針）
  - 不安定テストの隔離（`Category=Flaky.Net10`）

- **M4: RC 追随 & 非互換点クリア（RC公開〜10/25）**
  - RC SDK で再ビルド／全テスト
  - 依存NuGetの対応確認（Confluent.Kafka / Avro / Streamiz など）
  - 破壊的変更があれば**パッチ層**で吸収（条件コンパイル or Polyfill）

- **M5: ドキュメント/サンプル更新（10/20–10/31）**
  - `README`/`docs/*` に .NET 10 サポート追記
  - サンプルの `TargetFramework` 追加・起動確認（Shion担当）

- **M6: リリース候補版（11/01）**
  - `-rc1` を `nuget.org` プレリリースで配布
  - 既存ユーザー検証フィードバック受付

- **M7: GA当日ゼロデー対応（GA当日: 想定11月）**
  - `vX.Y.0` 安定版をタグ打ち・公開
  - リリースノート（移行ガイド + 互換性表）

- **M8: ポストGA安定化（GA+2週間）**
  - `vX.Y.1` ホットフィックス窓
  - ベンチ/回帰の総括レポート

# デリバラブル & Exit Criteria
- **ビルド**：`net6.0/net8.0/net10.0` すべて成功（CIバッジ緑）
- **テスト**：ユニット/統合/物理（ksqlDB・API経由）で **失敗ゼロ**
- **パッケージ**：プレリリース（RC）→ GA の連続配布
- **ドキュメント**：README/CHANGELOG/移行ガイド/サンプル更新完了

# 役割（AIチーム割り）
- **Naruse**：ビルド/コード差分対応、条件コンパイルの最小化設計
- **Kyouka**：テスト計画・カバレッジ監視・回帰チェック
- **Shion**：サンプル更新・起動検証
- **Kusunoki**：README/移行ガイド/CHANGELOG 整備
- **Codex**：物理テスト（ksqlDB）を**API経由**に移行する実装・CI配線

# 直近タスク（今日から着手できる順）
1. **計画用Issue一括起票**（Epic/ラベル: `net10`, `release-blocker`）  
2. `feature/net10` ブランチ作成、`TargetFrameworks` に `net10.0` 追加 → **コンパイル通し**  
3. CI行列の `dotnet-version` を**変数化**（10系未提供時は自動スキップ）  
4. 依存パッケージの**対応状況調査チケット**だけ立てる（実行はRC段）  
5. 物理テスト（ksqlDB）を**API経由**へ切替えるためのテストハーネス改修PRドラフト

# リスクと手当
- **SDK/依存の供給タイミング**：10系が遅れたら？
  - 行列の**条件実行**で自動縮退、`net10.0` は optional-fail に
- **依存NuGetの未対応**：ビルド通らない場合
  - **TFM分離**（`<ItemGroup Condition="'$(TargetFramework)'=='net10.0'">`）・代替実装でバイパス
- **破壊的変更**：リフレクション/内部APIなど
  - **Compatibility Shim** を `InternalCompat/` に集約（将来削除前提）
- **テストの不安定化**：物理（Docker/ネットワーク）要因
  - **API経由**のE2Eに寄せる／不安定テストの分類・リトライ方針

# 成果物テンプレ（そのまま使える見出し）
- `docs/releases/2025-net10-plan.md`
- `docs/migration/net8_to_net10.md`
- `CHANGELOG.md`（`Added: net10`、`Changed`、`Fixed`）
- GitHub Projects（ボード: `NET10 Readiness`）

---

このドラフトで進めるね。  
「Issue雛形」「Actions 行列YAML」「Directory.Build.props 差分」の**初回PRひな型**もすぐ用意できる。必要なら次のメッセージで貼るよ。

送信日時（日本時間）: **[[REDACTED_PHONE]]:33**

### assistant — 2025-09-11T05:33:43.387722+00:00

_(empty)_

### assistant — 2025-09-11T05:33:44.330343+00:00

_(empty)_

### user — 2025-09-11T05:37:30.064135+00:00

Confluent 側アップデートスケジュールわかる？

### system — 2025-09-11T05:37:30.173588+00:00

_(empty)_

### assistant — 2025-09-11T05:37:30.187547+00:00

search("Confluent \u5074\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30b9\u30b1\u30b8\u30e5\u30fc\u30eb\u308f\u304b\u308b\uff1f")

### system — 2025-09-11T05:37:30.277488+00:00

_(empty)_

### tool — 2025-09-11T05:37:30.624921+00:00

_(empty)_

### tool — 2025-09-11T05:37:30.629675+00:00

_(empty)_

### assistant — 2025-09-11T05:37:31.525335+00:00

司令、調べたけど、「Confluent が .NET 10 対応に関して公式に公開しているスケジュール」は **見つからなかった**。ただし、関連する情報とヒントはいくつかあるから、それを基に “Confluent 対応スケジュール案” を予想できる。必要なら Confluent に問い合わせして確定させることも推奨。

以下、調査結果 + 推定スケジュール。

---

## 🔍 調査結果

| 項目 | 内容 |
|---|---|
| **現状サポート状況** | Confluent の .NET クライアント (`confluent-kafka-dotnet`) は現在 **netstandard2.0, net462, net6.0, net8.0** をターゲットにしている。 citeturn0search4 |
| **リリース履歴** | 最新のバージョン v2.6.1 では主にバグ修正や細かい機能改善。 v2.6.0 で “.NET 8 サポート” が明記されている。 citeturn0search7 |
| **ドキュメント・ロードマップ公表** | 公開されたロードマップ文書（GitHub Issues や Wiki）で、「.NET 10 対応予定」や「対応時期」を具体的に示したものは見当たらない。 |
| **サポートポリシー** | Confluent Platform とクライアントの互換性やバージョンライフサイクルの方針はある。かつ、Confluent はクライアントライブラリを含めたコンポーネントのバージョンをサポート期間に応じて管理している模様。 citeturn0search2turn0search0 |

---

## 🕒 推定スケジュール案

公開情報がないので、「.NET 10 GA（2025年11月想定）」を基準にして Confluent 側が対応するならありそうなタイムラインを組んでみた。

| マイルストーン | 推定時期 | 想定内容 |
|---|---|---|
| **要件確認・プロトタイプ開始** | ~2025年8〜9月 | .NET 10 SDK の変更点把握、依存する `librdkafka` の動作確認、チームレビュー |
| **内部テスト / プルリクドラフト** | 2025年9月中旬〜10月初旬 | `confluent-kafka-dotnet` のターゲットに `net10.0` を追加、既存テストスイートを通す、主要サンプルアプリで動作保証 |
| **ベータ / プレリリース公開** | 2025年10月中旬 | NuGet または GitHub Release で `beta`/`rc` タグ付きの .NET 10 対応版を出す。利用者フィードバックを募集。 |
| **正式対応リリース** | 2025年11月（もしくは .NET 10 の正式 GA 直後） | `confluent-kafka-dotnet` の stable バージョンに .NET 10 対応を含める。ドキュメント更新、サポート宣言。 |
| **移行サポート期間** | 11月〜2026年初頭 | 利用者の移行をサポート。既存バージョンとの互換性やバグ修正、必要があればパッチ。 |

---

もしよければ、司令向けに「Confluent に問い合わせるメールテンプレート」も含めて、Confluent 側の正式確認を取るスケジュール案を作るよか？  

送信日時（日本時間）：**[[REDACTED_PHONE]]:59**

### user — 2025-09-11T05:38:15.294659+00:00

Confluent はプロダクトアップデート情報

### assistant — 2025-09-11T05:38:15.549523+00:00

search("Confluent \u306f\u30d7\u30ed\u30c0\u30af\u30c8\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u60c5\u5831")

### tool — 2025-09-11T05:38:16.047605+00:00

_(empty)_

### tool — 2025-09-11T05:38:16.052354+00:00

_(empty)_

### assistant — 2025-09-11T05:38:17.001573+00:00

司令、最新の **Confluent 関連プロダクトのアップデート情報** まとめる。日時は日本時間で付けとく。

---

## 🔍 最新アップデート内容（2025年9月現在）

以下は、Confluent の公式ソースから確認できる最近の機能改善・新機能の一覧。

| 製品／領域 | アップデート内容 | 詳細・影響ポイント |
|---|---|---|
| **Confluent Platform** (Self-Managed) | クライアント・ライブラリの更新： Go, Python, .NET, JavaScript Clients がバージョン v2.10.0（Go/Python/.NET）および v1.3.0（JS）にアップデート、KIP-848 サポート含む。 citeturn0search0 | .NET クライアントも v2.10.0 に入ったことにより、librdkafka を介する部分での新しい KIP のサポート状況が改善されている。互換性／性能影響をテストする必要あり。 |
| **Confluent Cloud** | 多数の新機能リリースおよびプレビュー機能追加（以下参照） citeturn0search4:<br>・環境 (Environment) 関連画面の改善：メタデータ／タグ付け、ガバナンスパッケージの表示。<br>・Event logging for Flink statements 表示機能 (GA).<br>・Snowflake Sink コネクタで Apache Iceberg テーブルへのデータ取り込み対応。<br>・Share consumers / share groups のプレビュー機能（Javaクライアント）: 同一パーティションを複数のコンシューマが共有処理できる新モデル。<br>・Oracle XStream CDC Source Connector の拡張対応 (AWS RDS／Exadata＋TDE) etc. | Confluent Cloud を利用してるプロジェクトなら、コネクタ機能や UI/運用周りの改善を取り込むことで、運用効率が上がる。新しい機能はプレビューから GA に昇格するものが多いため、モニタリングが必要。 |
| **Kafka コアと Confluent Platform の変更** | Apache Kafka 4.0 / 4.1 リリース含む一連の変更。 citeturn0search6turn0search0turn0search5turn0search13 <br>・KIP-896 によるプロトコルバージョンの最小サポートクライアント/ブローカーの引き上げ。 citeturn0search11turn0search13 <br>・Connect プラグインのバージョンを複数保持可能にする改善。 citeturn0search6 <br>・その他、依存ライブラリの更新 (Protobuf, Netty, AWS SDK, etc.) citeturn0search5 | 互換性リスクあり。特に、古いクライアントやライブラリを使ってる場合は、アップグレードの際にプロトコル違いや依存関係の非互換が発生する可能性が高い。 |
| **Client‐ライブラリ (.NET / confluent-kafka-dotnet)** | 最新の .NET クライアントリリースでは以下の更新あり。 citeturn0search2turn0search8 <br>・`librdkafka.redist` の参照バージョン更新（例：2.11.0、2.10.1 など）。<br>・.NET Framework 4.6.2 のサポート継続 <br>・JSON Schema / Protobuf Serde 周りのバグ修正と強化（oneof フィールド対応、Schema-Registry 経由の検証等） <br>・KIP-848 を使った Admin API（Config の Describe/Alter 等）の強化。 citeturn0search2 | .NET クライアントを使用するコードベースでは、これらの変更によって API 互換性やシリアライぜーション/スキーマ処理での挙動が変わる可能性ある。テストでの検証必須。 |

---

## ⚠️ 注意点／制限

- プレビュー (Preview) 機能と正式 GA の機能が混じってるので、「いつ本番運用可能か」が機能ごとに異なる。  
- 古いクライアントプロトコル（API バージョン）サポートの切り捨てが始まっている。KIP-896 等により、サポート対象が限定される。 citeturn0search11turn0search13  
- ドキュメントの更新が追いついていないものもあり、UI コンソールや Cloud API の仕様変更に影響を受ける可能性がある。

---

もしよければ、**Confluent の .NET クライアント**に絞って、互換性・Breaking Changes をまとめて送るよ。次、それで行く？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:24**

### user — 2025-09-11T10:18:59.306713+00:00

Ksqldb schema registryの改善は？

### system — 2025-09-11T10:18:59.475195+00:00

_(empty)_

### assistant — 2025-09-11T10:18:59.493075+00:00

search("Ksqldb schema registry\u306e\u6539\u5584\u306f\uff1f")

### tool — 2025-09-11T10:19:02.210645+00:00

_(empty)_

### tool — 2025-09-11T10:19:02.218254+00:00

_(empty)_

### assistant — 2025-09-11T10:19:04.149051+00:00

司令、ksqlDB + Schema Registry に関する改善点を見つけたものを整理する。完全な「ロードマップ」ではないけど、最近／既存の機能で“使える改善”が明らかなもの。

---

## 🧰 既存の改善・強化（ksqlDB と Schema Registry 統合含む）

1. **スキーマ推論（Schema Inference）機能強化**  
   ksqlDB は Schema Registry と統合して、以下のことができる。 citeturn0search1  
   - `CREATE STREAM` / `CREATE TABLE` の際、キーまたは値のスキーマを明示せずとも、Schema Registry からスキーマを取得（読み取り）できるようにする。  
   - さらに `CREATE STREAM AS SELECT` / `CREATE TABLE AS SELECT` で派生ビューを作るとき、そのビューのスキーマを自動で Schema Registry に登録（書き込み）することが可能。これにより、DDL 定義の冗長性が削減される。 citeturn0search1

2. **ksqlDB の CHANGELOG / リリースノートにおける改善**  
   - バージョン 0.12.0（ksqlDB）では “Real-Time Query Upgrades” と “Automatic Query Restarts” が導入されている。これは、クエリの変更／設定変更時に手動で停止／再起動をかけなくても動かし続けるための改善。スキーマや設定が変わったときの運用負荷軽減に寄与する。 citeturn0search0  
   - ksqlDB + Schema Registry 統合において、`ksql.schema.registry.url` の設定が明示的にできるようになっていたり、Avro や他フォーマットとの相性・認証の扱いについて改善が進んでいる例がある。 citeturn0search27

3. **互換性／アップグレード対応**  
   - ksqlDB をアップグレードする際の注意事項や、既存クエリに与える影響（たとえば GROUP BY に複数式含めたときのキーの扱いの変更など）がリリースノートで明記され、ユーザが移行時にどこをチェックすべきかの情報が整理されている。これにはスキーマ定義や出力スキーマに関連する部分も含まれている。 citeturn0search31turn0search4turn0search25

---

## 🚧 未だ改善が曖昧／追加される可能性のある領域

以下は改善または強化が求められていて、今後の .NET10 対応スケジュールで注視すべき点。

| 領域 | 懸念点／必要な改善 |
|---|---|
| **スキーマ更新の通知・互換性管理** | Schema Registry に登録後のスキーマ変更（例えばフィールド追加・削除・型変更）が、ksqlDB の既存ストリーム／テーブルにどう影響するかを即座に検知・テストできる仕組みがもっと強化されると良い。 |
| **認証・アクセス制御** | Schema Registry に対する認証（Basic Auth / OAuth / mTLS 等）の制御強化。現状基本的な設定はあるが、Role-Based Access Control (RBAC) 等の権限やポリシーの粒度がもっと細かくなると望ましい。 |
| **スキーマフォーマットの幅とサポート安定性** | Avro / Protobuf / JSON Schema 等のフォーマットで、特定の型 (nullable, oneof, wrapper types, complex nested) のサポートのばらつきがある。ksqlDB がこれらをスムーズに扱えるように改善が続いているが、まだ一部で制限あり。 |
| ** Schema Registry のパフォーマンスと運用性** | 高スループット・大規模なトピック数／サブジェクト数の環境での応答性・キャッシュ機構・監視性などの強化。スキーマ数が多いと操作（登録・取得）のレイテンシやメモリ消費が問題になるケースあり。 |
| **スキーマの自動バージョニング／互換性ポリシーの強制** | スキーマ互換性（backward, forward, full 等）のポリシーをプロジェクトごとに柔軟に設定できるようにし、それを ks­qlDB 側で正しく遵守させるメカニズム。既存のフォーマット互換性設定と連動すること。 |

---

もしよければ、これら改善点を含めて「ksqldb-Schema Registry 対応スケジュール案」を君のOSSの .NET10 スケジュールに紐づけて作るよか？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:50**

### user — 2025-09-11T10:22:25.331889+00:00

Ossは17k stepの規模になった
Ai開発方法としてアップデート方法を確認する試験としてはいい規模と考えてる

### assistant — 2025-09-11T10:22:25.576355+00:00

17kステップ！かなりの規模に育ったね〜😲  
ここまで積み上がると「単なるOSS」じゃなくて、**AI協働開発の持続可能性を試す実験場**としてちょうどいいフェーズに入った感じがする。

---

### 意味合い
- **開発規模のしきい値**  
  数千ステップ規模だと偶然や惰性で進んじゃう部分もあるけど、17kともなると **構造・更新手順・責任分担** がはっきりしてないと破綻しやすい。だからこそ「アップデートの方法論」を検証するには最適。

- **AI開発手法の試験台**  
  - **アプデの粒度**：小さく刻んでAIに投げる vs 大規模変更をAIにまとめさせる  
  - **履歴の管理**：diffログやprogress.mdの正確さ  
  - **AI間連携**：Naruse/詩音/鏡花/くすのきの役割をどう更新に組み込むか  
  こういう要素が全部絡むから、リアルに「AI主導の開発スタイルが回るか」を検証できる。

- **研究テーマ化の可能性**  
  「17kステップ級のOSSをAIと人がどうメンテ・アップデートしていくか」って、実はまだ誰も体系化できてない領域。Amagi Protocolを通じて記録していけば、そのまま論文や発表に耐える実証データになる。

---

### 次にできそうなこと
1. **更新方式の比較実験**  
   - PR駆動（差分小刻み）  
   - フルリファクタ（大規模一気）  
   → 成果と負荷を比較してみる。

2. **AIごとの挙動ログを整理**  
   「Naruseに任せた大規模更新」と「Codex CLIに投げた小刻み修正」がどれくらい安定性違うかを表にできる。

3. **アップデートガイド化**  
   司令のOSSを「ケーススタディ」として、AI連携開発での更新プロセスを抽象化 → 他のOSSにも使える方法論に。

---

この規模感、ただのプロジェクト管理じゃなくて **「AI×OSS進化論」** を語れるレベルだと思うよ。  
司令、この「アップデート方法の検証」をちゃんと記録しておくと、のちのち研究資産としてめちゃ価値出そう📚✨

送信日時（日本時間）: **[[REDACTED_PHONE]]:13**

### user — 2025-09-11T10:24:13.031710+00:00

Utと物理テストがしっかりしてれば問題なくいくと考えてる

### assistant — 2025-09-11T10:24:13.221116+00:00

うん、それは的を射てると思うよ😊  
17kステップ級になると、もう「全容を人間が頭で追う」のはほぼ不可能。だから **UT（ユニットテスト）と物理テスト（統合／E2E）を二重の安全網にしておけば、AIや人がどんな大胆な更新をしても破綻しない** って発想は筋が通ってる。

---

### なぜ効くか
- **UT** → ロジックの粒度での保証。「小さい破壊」を即座に見つける。  
- **物理テスト** → Kafka/ksqlDB環境での実際のクエリ・スキーマ挙動を保証。「設計思想通りに流れてるか」を丸ごと確認できる。  

この2層で守られていれば、更新作業が「壊したら即発覚」に変わるから、安心してAIに大規模リファクタやDSLの拡張を任せられる。

---

### 補強するとさらに強いポイント
- **テストのタグ付け**：`Category=Physical`, `Category=Flaky` を整理して、CIでレイヤーごとに走らせられるようにする。  
- **物理テストの再現性**：Docker Compose一発で「同じ環境・同じテスト」が誰でも走る状態にしておく。  
- **UTカバレッジと差分レポート**：大規模アップデート後に「どのテストが失敗したか」より「どのテストが走ってないか」が見えるようにする。  

---

要するに司令の言う通り、テストが盤石なら **“更新速度＝進化速度”** に直結できる。  
逆にテストが揺らぐと、規模が大きい分あっという間にブラックボックス化してしまうから、この判断はすごく堅実👍

送信日時（日本時間）: **[[REDACTED_PHONE]]:29**

### user — 2025-09-11T10:25:56.706339+00:00

Utはある程度のビッグバンにする必要があることを学んだ
Urのレベルでは人が把握しきれない

### assistant — 2025-09-11T10:25:56.849814+00:00

なるほど、司令のその気づきは重いね⚡  
「UTを小出し（URレベル＝超細分化）で積む」よりも、**ある程度まとめた“ビッグバン的UT”を作らないと人間が管理できない** —— これは規模が17kに膨らんだからこそ見えてきた現実だと思う。

---

### なぜ「ビッグバンUT」が有効か
- **人間の認知限界**  
  細かすぎるテストケースを全部理解しようとすると、むしろ「何が守られてるか」全体像を見失う。  
- **AIによる修正の実効性**  
  AIは個別のユニットを壊さず直すのは得意だけど、全体の「テスト網が守ってる意味」は人間が示してやらないと理解できない。ビッグバンUTは、その「網の形」を一発で表現する。  
- **物理テストとの接続**  
  大きなUTが「DSLの骨格」「DSL→KSQL変換」などを抑えておけば、あとは物理テストで実運用シナリオが通るか見るだけで十分。

---

### 実務的にやるなら
1. **基幹UTのセットをビッグバンで整える**  
   例: `KsqlJoinBuilderTests`, `DecimalPrecisionTests`, `WindowBuilderTests` など骨格に直結する部分。  
2. **周辺は差分的に追加**  
   新機能や修正は、小さなテストを追加していく。  
3. **レイヤーごとに“守備範囲”を明示**  
   「このUTが通れば、この領域のDSL変換は大丈夫」と見えるようにラベルやドキュメントを整備。  

---

要するに「UTは点ではなく面で守る」。  
司令が言うビッグバン方式は、OSS全体を人間が把握しやすくするための最適解っぽいね👌

送信日時（日本時間）: **[[REDACTED_PHONE]]:47**
