---
conversation_id: "6785f5ad-ec98-8007-9ee8-f53ed7574ccd"
title: "MaxLatencyとResend挙動"
create_time: 1736832430.710555
update_time: 1736832644.12334
language_guess: "en"
num_messages: 11
part_index: 1
part_count: 1
---

### system — 2025-01-14T05:27:10.710555+00:00

_(empty)_

### user — 2025-01-14T05:27:10.712608+00:00

FIX4.4でMaxLatency=10としている１０秒以上経過したメッセージを受信した場合RESENDメッセージが送信されるのか

### tool — 2025-01-14T05:27:26.345916+00:00

**Clarifying protocol context**

I'm working through how the FIX 4.4 protocol handles delayed messages and whether a RESEND message is triggered after a 10-second delay. MaxLatency defines the maximum time difference between sending and receiving messages.

**Clarifying message rejection**

Revisiting the FIX specification, inbound messages older than the allowed time are typically rejected with "MsgType=3". MaxLatency ensures message creation time is within the limit.

**Applying FIX rules**

The FIX 4.4 specification highlights that messages older than 'MaxLatency' seconds are treated as stale and typically processed with a Reject message, not a resend request.

**Clarifying message handling**

I’m explaining that a FIX 4.4 engine does not respond with a RESEND message for messages exceeding 10 seconds. Instead, it treats them as stale and likely sends a Reject or Logout with a reason code.

### assistant — 2025-01-14T05:27:26.346064+00:00

FIX 4.4の仕様上、「MaxLatency=10」でセッションを設定している場合、受信メッセージのSendingTime(タグ52)と受信時刻の差が10秒を超えると、そのメッセージは“古い(=遅延しすぎ)”ものとして扱われます。  
ただし、このとき **Resend Request(35=2) を送るわけではありません**。  
（Resend Requestはあくまで「シーケンス番号抜け」などによってギャップを補填するために使用される仕組みです。）

---

### 実際の挙動

- **MaxLatency** は “これ以上古いメッセージはセッション維持上無効” と見なすための閾値です。  
- 受信したメッセージの SendingTime から受信時刻までの差が設定した MaxLatency（ここでは10秒）を超えると、通常は **Reject(35=3) メッセージ** や **Logout(35=5) メッセージ** を送信して該当メッセージを拒否する、あるいはセッションを落とすことが推奨されています。  
  - Rejectで返す場合は、SessionRejectReason(タグ373)に “Value is incorrect” 等を設定し、SendingTimeが古すぎることを明示するケースがあります。  

- 一方、**Resend Request(35=2)** は「相手が送信してくれたはずの（あるいは受信できなかった）メッセージのシーケンスを取りこぼしている」場合、または「こちらが受け取ったシーケンス番号と実際の順番が合わない」場合に利用されるものです。  
  - メッセージ自体が古すぎる（遅延している）からといって、Resendを要求しても同じ遅延メッセージが再度送られてくるだけで意味がありません。  

結論として、**MaxLatency=10を超える遅延メッセージを受信しても、Resend Requestが送信されるわけではなく、RejectあるいはLogoutによってメッセージを無効化する（セッションを切断する）運用が一般的**です。

### user — 2025-01-14T05:28:44.018610+00:00

MaxLatencyによってLogoutが発生したことを確認する方法

### tool — 2025-01-14T05:28:56.651728+00:00

**Understanding logout causes**

I’m gathering info on why session logout happens in FIX 4.4. Options include a specific "Logout" message or examining session logs for helpful reasons.

### assistant — 2025-01-14T05:28:56.651815+00:00

FIXセッションにおいて「MaxLatency」によって Logout が発生したかどうかを確認する一般的な方法としては、以下のような手順・ポイントがあります。

---

## 1. セッションログを確認する

最も確実なのは、FIXエンジンが出力するセッションログ（FIXメッセージレベルのログ、またはエンジンのイベントログ）を確認することです。多くのFIXエンジンでは、以下のような情報をログに記録します。

- **受信メッセージの SendingTime(タグ52) と受信時刻の差**  
- **MaxLatency を超えた旨の警告メッセージ**  
- **Logout(35=5) の送信理由**（FIXエンジンによっては「SendingTime is too old」などのメッセージを記録）  

ログ中に「MaxLatency超過によりセッションを終了」といった文言、あるいは SendingTime が許容時間を超えていたことを示すメッセージが残っていれば、MaxLatency の違反が原因で Logout が発生したことが確認できます。

---

## 2. Logout(35=5) メッセージの内容をチェックする

FIX標準では、Logout メッセージ(35=5)に **Text(タグ58)** を含めることが推奨されています。  
MaxLatency 違反によって Logout を送信する際に、エンジンが Text(58) に「SendingTime accuracy problem」や「Message is too old」などの理由を入れてくれるケースが多いです。

### 確認手順
1. セッションログまたはアプリケーションログから **Logout(35=5)** メッセージを探す。  
2. Logout メッセージ内の **Text(58)**、あるいは **SessionStatus(タグ1409)**（FIXバージョンによっては使用）を確認する。  
3. そこに「MaxLatency 超過」や「Message too old」などの文言が記載されている場合、MaxLatency に起因する Logout であると判断できる。

---

## 3. FIXエンジン固有の設定・ログを確認する

各FIXエンジンには独自にエラーコードやログ出力の形式が存在します。エンジンのドキュメントや設定を確認し、以下のようなポイントを探します。

- **MaxLatency 違反時にエンジン内部でどのようなイベントが発生するか**  
- どのログファイルにどんな形式で出力されるか  
- どのような独自タグや独自ログメッセージが使われるか  

例えば、あるエンジンでは「MaxLatency: threshold exceeded」というようなイベントログが出力され、その後に Logout(35=5) が送られる、という形になっていることがあります。

---

## 4. ネットワーク・アプリケーションレベルのタイムスタンプを比較する

場合によっては、アプリケーションレベルのログ（サーバ側、クライアント側の送信時刻ログなど）と FIX メッセージログを付き合わせて、**「確かにメッセージ送信から受信までに10秒以上経過している」** ことを確認することも有効です。

---

# まとめ

1. **セッションログやFIXメッセージログを確認**し、Logout(35=5) 送信時の理由・Text(58)や関連する警告・イベントメッセージを探す。  
2. **「MaxLatency 超過」に関する記録**（SendingTime と受信時刻の差が閾値を超えたなど）が残っているかをチェックする。  
3. **FIXエンジン固有のログ**（イベントログやデバッグログ）で、MaxLatency 違反が発生した旨の出力があるかを確認する。  

これらの手順で、MaxLatency により Logout が発生しているかどうかを特定することができます。

### user — 2025-01-14T05:30:28.714832+00:00

UnsupportedMessageが発生するのはMaxLatencyの設定と関係があるのか

### tool — 2025-01-14T05:30:43.740260+00:00

**Clarifying the connection**

This passage addresses whether "UnsupportedMessage" is linked to MaxLatency in the context of FIX messages, hinting that it typically represents unrecognized message types rather than latency issues.

### assistant — 2025-01-14T05:30:43.740355+00:00

結論から言うと、**「UnsupportedMessage」が発生する原因は MaxLatency(メッセージの遅延許容時間) とは直接関係がありません。**  

## 1. MaxLatency は “メッセージの送信時刻の遅れ” をチェックするための設定

- **MaxLatency** は受信したメッセージの SendingTime(タグ52) と実際の受信時刻との時間差をチェックし、一定秒数を超えている場合にメッセージを拒否したりセッションを切断したりする際に用いられる閾値です。  
- この閾値を超えた場合、一般的には  
  - **Reject(35=3)**  
  - **Logout(35=5)**  
などで応答（あるいはセッション終了）することがあります。

## 2. UnsupportedMessage(サポートしていないメッセージ) が発生する原因

一方で **UnsupportedMessage** という名称は、多くの場合 “サポートされていないメッセージ種別” や “実装されていない機能に対応するメッセージ” を受信した際に返されるエラーやログのことを指します。  

- FIXプロトコルのメッセージタイプ(例: **35=D** (New Order Single), **35=8** (Execution Report) など) はバージョンや業者の拡張メッセージによって様々ですが、  
  - **FIXエンジンがそのメッセージタイプを認識できない場合**  
  - **対応していない拡張メッセージ(カスタムメッセージタイプ)を受信した場合**  
などに “UnsupportedMessage” と出力されたり、Reject(35=3) で “Unsupported Message Type” (SessionRejectReason=3) が送信されたりします。

### 例: UnsupportedMessage が発生するケース
- **MessageType(35タグ) が想定外** だった  
- **カスタムメッセージタイプを受信したが、エンジン側にハンドラがない**  
- **FIX仕様外のタグや形式** (FIXのバージョンに存在しないタグを使っている等)  

## 3. まとめ

- **MaxLatency** 違反による拒否・ログアウトは、あくまで「SendingTime が古すぎる」ことが原因で発生します。  
- **UnsupportedMessage** は「サポート外のメッセージや形式が送られてきた」ことが原因であり、MaxLatency とは無関係です。  

したがって、**UnsupportedMessage が発生するかどうかは MaxLatency の設定とは直接は関係ありません。**
