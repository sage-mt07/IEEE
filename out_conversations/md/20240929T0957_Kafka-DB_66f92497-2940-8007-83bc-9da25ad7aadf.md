---
conversation_id: "66f92497-2940-8007-83bc-9da25ad7aadf"
title: "Kafka DB登録サービス"
create_time: 1727603863.313549
update_time: 1727603934.081749
language_guess: "en"
num_messages: 9
part_index: 1
part_count: 1
---

### system — 2024-09-29T09:57:43.313549+00:00

_(empty)_

### user — 2024-09-29T09:57:43.318426+00:00

net8でkafkaからのメッセージ内容をDBに登録するサービスを作成する
DB登録はkafkaからの読み取りとは別に非同期におこないたい、
すべてを登録せずに一体間隔の時間を待ってDBへ登録したい
待ち間隔で生じたメッセージは破棄する
この場合のサンプルを示せ

### assistant — 2024-09-29T09:58:00.054261+00:00

_(empty)_

### assistant — 2024-09-29T09:58:00.054357+00:00

The user is creating a service in .NET 8 that reads messages from Kafka and registers them to a database asynchronously. They want to register messages to the database at a fixed interval, and any messages received during the waiting interval should be discarded.

### tool — 2024-09-29T09:58:00.054419+00:00

Model set context updated.

### assistant — 2024-09-29T09:58:00.054475+00:00

Here is a sample implementation in .NET 8 using Kafka and asynchronous database registration. This service reads messages from Kafka, stores them in memory temporarily, and periodically registers them to the database. Messages received during the wait period are discarded.

```csharp
using Confluent.Kafka;
using Dapper;
using System.Data;
using System.Threading.Channels;
using Microsoft.Extensions.DependencyInjection;

public class KafkaConsumerService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly Channel<string> _messageChannel;
    private readonly CancellationTokenSource _cancellationTokenSource;
    private readonly TimeSpan _dbWriteInterval;

    public KafkaConsumerService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
        _messageChannel = Channel.CreateUnbounded<string>();
        _cancellationTokenSource = new CancellationTokenSource();
        _dbWriteInterval = TimeSpan.FromSeconds(10); // Adjust the interval as needed
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        Task.Run(() => ConsumeKafkaMessages(_cancellationTokenSource.Token));
        Task.Run(() => RegisterToDatabasePeriodically(_cancellationTokenSource.Token));
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        _cancellationTokenSource.Cancel();
        return Task.CompletedTask;
    }

    private async Task ConsumeKafkaMessages(CancellationToken cancellationToken)
    {
        var config = new ConsumerConfig
        {
            GroupId = "test-group",
            BootstrapServers = "localhost:9092",
            AutoOffsetReset = AutoOffsetReset.Earliest
        };

        using var consumer = new ConsumerBuilder<Ignore, string>(config).Build();
        consumer.Subscribe("test-topic");

        try
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var consumeResult = consumer.Consume(cancellationToken);
                if (!_messageChannel.Writer.TryWrite(consumeResult.Message.Value))
                {
                    // Message discarded if not written to the channel
                    Console.WriteLine("Message discarded: " + consumeResult.Message.Value);
                }
            }
        }
        catch (OperationCanceledException)
        {
            consumer.Close();
        }
    }

    private async Task RegisterToDatabasePeriodically(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(_dbWriteInterval, cancellationToken);

                if (_messageChannel.Reader.Count > 0)
                {
                    var messagesToRegister = new List<string>();

                    while (_messageChannel.Reader.TryRead(out var message))
                    {
                        messagesToRegister.Add(message);
                    }

                    await RegisterMessagesToDatabase(messagesToRegister);
                }
            }
            catch (TaskCanceledException)
            {
                // Handle graceful shutdown
            }
        }
    }

    private async Task RegisterMessagesToDatabase(IEnumerable<string> messages)
    {
        using var scope = _serviceProvider.CreateScope();
        var dbConnection = scope.ServiceProvider.GetRequiredService<IDbConnection>();

        foreach (var message in messages)
        {
            await dbConnection.ExecuteAsync("INSERT INTO Messages (Content) VALUES (@Content)", new { Content = message });
        }
    }
}
```

### Explanation:

1. **Kafka Message Consumption:**
   - The service consumes messages from Kafka in the `ConsumeKafkaMessages` method.
   - Messages are pushed into a `Channel<string>`, which acts as a buffer.
   - If the buffer can't accept the message, it is discarded.

2. **Periodic Database Registration:**
   - Every `TimeSpan` interval (`_dbWriteInterval`), the service collects messages from the channel and registers them to the database in the `RegisterToDatabasePeriodically` method.
   - Only the messages that have been accumulated within the interval are processed, and any others that arrive during the waiting period are discarded.

3. **Database Registration:**
   - `RegisterMessagesToDatabase` method uses Dapper to register messages into the database.

This is a basic structure, and you can adjust it further depending on specific use cases, error handling, or performance optimizations.

### user — 2024-09-29T09:58:35.336028+00:00

Task.Runの部分はIHostedServiceにしたい

### assistant — 2024-09-29T09:58:53.539723+00:00

If you want to adjust the `Task.Run` portions and implement this directly within the `IHostedService`, it is better to integrate the background tasks (Kafka consumption and database registration) properly within the lifecycle of the `IHostedService`. Below is a revised version where both tasks are managed as part of the service’s start and stop lifecycle.

```csharp
using Confluent.Kafka;
using Dapper;
using System.Data;
using System.Threading.Channels;
using Microsoft.Extensions.DependencyInjection;

public class KafkaConsumerService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly Channel<string> _messageChannel;
    private readonly TimeSpan _dbWriteInterval;
    private Task? _consumeTask;
    private Task? _registerTask;
    private CancellationTokenSource? _cancellationTokenSource;

    public KafkaConsumerService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
        _messageChannel = Channel.CreateUnbounded<string>();
        _dbWriteInterval = TimeSpan.FromSeconds(10); // Adjust the interval as needed
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _cancellationTokenSource = new CancellationTokenSource();
        var linkedToken = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, _cancellationTokenSource.Token).Token;

        _consumeTask = ConsumeKafkaMessages(linkedToken);
        _registerTask = RegisterToDatabasePeriodically(linkedToken);

        return Task.CompletedTask;
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        if (_cancellationTokenSource != null)
        {
            _cancellationTokenSource.Cancel();
        }

        // Ensure both tasks have completed before stopping the service
        if (_consumeTask != null)
        {
            await Task.WhenAny(_consumeTask, Task.Delay(Timeout.Infinite, cancellationToken));
        }

        if (_registerTask != null)
        {
            await Task.WhenAny(_registerTask, Task.Delay(Timeout.Infinite, cancellationToken));
        }
    }

    private async Task ConsumeKafkaMessages(CancellationToken cancellationToken)
    {
        var config = new ConsumerConfig
        {
            GroupId = "test-group",
            BootstrapServers = "localhost:9092",
            AutoOffsetReset = AutoOffsetReset.Earliest
        };

        using var consumer = new ConsumerBuilder<Ignore, string>(config).Build();
        consumer.Subscribe("test-topic");

        try
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var consumeResult = consumer.Consume(cancellationToken);
                if (!_messageChannel.Writer.TryWrite(consumeResult.Message.Value))
                {
                    // Message discarded if not written to the channel
                    Console.WriteLine("Message discarded: " + consumeResult.Message.Value);
                }
            }
        }
        catch (OperationCanceledException)
        {
            consumer.Close();
        }
    }

    private async Task RegisterToDatabasePeriodically(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(_dbWriteInterval, cancellationToken);

                if (_messageChannel.Reader.Count > 0)
                {
                    var messagesToRegister = new List<string>();

                    while (_messageChannel.Reader.TryRead(out var message))
                    {
                        messagesToRegister.Add(message);
                    }

                    await RegisterMessagesToDatabase(messagesToRegister);
                }
            }
            catch (TaskCanceledException)
            {
                // Handle graceful shutdown
            }
        }
    }

    private async Task RegisterMessagesToDatabase(IEnumerable<string> messages)
    {
        using var scope = _serviceProvider.CreateScope();
        var dbConnection = scope.ServiceProvider.GetRequiredService<IDbConnection>();

        foreach (var message in messages)
        {
            await dbConnection.ExecuteAsync("INSERT INTO Messages (Content) VALUES (@Content)", new { Content = message });
        }
    }
}
```

### Key Adjustments:
1. **Lifecycle Management:**
   - In `StartAsync`, both the Kafka consumption and database registration tasks are started within the service’s lifecycle without `Task.Run`.
   - These tasks are tracked using `_consumeTask` and `_registerTask`.

2. **Graceful Shutdown:**
   - In `StopAsync`, the `CancellationTokenSource` is used to cancel the tasks, and the service waits for their completion.
   - This ensures a clean shutdown and allows the background tasks to stop gracefully.

This pattern integrates the background processing into the `IHostedService` lifecycle, removing the need for `Task.Run` and providing a more structured way to manage background tasks.
