---
conversation_id: "68d3d844-94e4-8321-a926-3d7c49235259"
title: "2022移行問題点"
create_time: 1758714015.963831
update_time: 1759121433.401727
language_guess: "en"
num_messages: 156
part_index: 1
part_count: 1
---

### system — 2025-09-24T11:40:15.963831+00:00

_(empty)_

### system — 2025-09-24T11:40:15.963831+00:00

_(empty)_

### user — 2025-09-24T11:40:17.527000+00:00

AzureDevOpsServer2019から2022へのアップグレード
TFSから2019へアップグレードしたものを2019として運用していた
今回2022へアップグレードする
tfsのころに作成したデータベースの移行は問題ないが
2022で作ったデータベースの移行ができない
このような事例はあるか？考えられる問題点はなにか？

### system — 2025-09-24T11:40:20.914362+00:00

_(empty)_

### system — 2025-09-24T11:40:21.023509+00:00

_(empty)_

### assistant — 2025-09-24T11:40:21.049521+00:00

_(empty)_

### assistant — 2025-09-24T11:40:21.177032+00:00

_(empty)_

### assistant — 2025-09-24T11:40:25.718432+00:00

{"search_query": [{"q": "Azure DevOps Server 2019 to 2022 upgrade database migration issues cannot attach or migrate databases"}, {"q": "Azure DevOps Server 2022 move databases to new data tier problem 'cannot be imported' 'tfs_configuration' 2022"}, {"q": "TFS to Azure DevOps Server 2022 database compatibility unsupported version"}, {"q": "Azure DevOps Server 2022 detach/attach databases move collection error"}, {"q": "Azure DevOps Server 2022 known issues upgrade"}], "response_length": "short"}

### tool — 2025-09-24T11:40:29.026150+00:00

_(empty)_

### tool — 2025-09-24T11:40:29.040889+00:00

_(empty)_

### assistant — 2025-09-24T11:40:33.584403+00:00

{"search_query": [{"q": "Azure DevOps Server attach collection database from newer version not supported 'forward compatibility' 'schema version' TF246017"}, {"q": "TF254078 No attachable database found Azure DevOps attach collection extended properties TFS_DATABASE_TYPE"}, {"q": "Azure DevOps detach collection copies configuration data into collection database"}], "response_length": "short"}

### assistant — 2025-09-24T11:40:43.641357+00:00

_(empty)_

### tool — 2025-09-24T11:40:51.973607+00:00

_(empty)_

### tool — 2025-09-24T11:40:51.984659+00:00

_(empty)_

### assistant — 2025-09-24T11:40:54.931361+00:00

やあ司令。状況わかるよ。結論から：

- **「TFS 時代の DB → 2019 → 2022」移行は通るのに、**  
  **「Azure DevOps Server 2022 で新規に作ったコレクション DB を別環境へ移行できない」**ケースは、現場でも時々報告があります。典型的には以下の落とし穴が原因です。

## よくある原因とチェックポイント

1) **Detach を経ていない（＝“attach 可能な DB が見つからない”）**  
   コレクションを**Detach してから**バックアップ/復元しないと、構成 DB にあるコレクション依存情報がコレクション DB 側へコピーされず、**管理コンソールで「TF254078: アタッチ可能な DB がない」**になります。Detach は**絶対に省略不可**です。citeturn1search5turn1search2turn1search11

2) **SQL Server バージョン/パッチレベルの不一致**  
   データ層を別サーバに移すときは、**まず“元と同じバージョン/エディション/累積更新（CU）”の SQL Server**に復元するのが公式手順です（その後で SQL を上げる）。違う版に復元すると検出されない/アタッチに失敗、が起きがちです。citeturn0search1

3) **コレクション DB の拡張プロパティ不整合**  
   まれに DB の**拡張プロパティ（例：`TFS_DATABASE_TYPE` など）**が壊れていて、**TF254078**やアタッチ失敗になります。新規コレクションをいったん作成→Detach して**拡張プロパティを比較**・修正して解決した事例があります。citeturn0search7

4) **バージョン/スキーマの前方互換性問題**  
   **新しいバージョンで作ったコレクション DB を古いアプリ層へ**は基本的に**アタッチ不可**です（スキーマが進んでいるため）。**TF254078 の原因が“DB のバージョン不一致”**だった事例もあります。**ターゲットの Azure DevOps Server は**少なくとも**ソースと同じかそれ以上のビルド/パッチ**にしてください。citeturn1search7

5) **暗号化キー/レポート連携キーの未復元**  
   レポート サービスや接続情報を使っている場合、**暗号化キーや分析/レポート構成**を正しく復元していないと失敗します。公式の「ハードウェア移行」手順の**“DB と暗号化キーをバックアップ/復元”**に従って再確認を。citeturn0search1

6) **アイデンティティの不整合**  
   古い操作履歴や無効ユーザーが新環境の「有効ユーザー」要件に合わず、移行時にエラー化することがあります。**移行トラブルシュート（Identity 章）**のとおり、無効/重複 ID を事前に整理。citeturn0search12

7) **パッチ既知問題に該当**  
   **Azure DevOps Server 2022.2 Patch 6** には**既知の不整合**が告知されています。もし該当パッチなら、回避/更新の告知を確認してください。citeturn0search4turn0search8

## いま取るべき最短ルート（実践チェックリスト）

- **ソース側で必ず Detach**（管理コンソール → *Detach Collection*）。ログを保存。citeturn1search16  
- **同一版の SQL Server**（版/CU まで一致）に**構成/コレクション DB を復元** → その後に必要なら SQL をアップグレード。citeturn0search1  
- **ターゲットの Azure DevOps Server のビルド/パッチ**がソース以上であることを確認（2022→2022 同等以上）。citeturn1search7  
- **暗号化キー/SSRS キー**を復元（レポート使用時）。citeturn0search1  
- 管理コンソールで**Attach**しても出てこない場合：  
  - **`TfsConfig.exe` でのアタッチ**を試す（検出ロジックの違いで通ることあり）。citeturn1search1  
  - コレクション DB の**拡張プロパティ**（`TFS_DATABASE_TYPE` など）を**動作中の DB と比較**。差分があれば修正。citeturn0search7  
- 依然失敗するなら、**SQL ログ/イベント**と **TF エラー（例：TF254078 / TF246017）**を突き合わせて原因特定（接続/権限/DB 状態）。citeturn1search3turn1search0

---

必要なら、司令の環境前提（SQL 版/パッチ、AOS 2022 の Update/Patch レベル、Detach の有無、エラー番号）を教えてくれれば、**具体的な手順（コマンド/順序/ロールバック案）**まで一気に書き下ろします。

送信日時（日本時間）：[[REDACTED_PHONE]]:40 (JST)

### assistant — 2025-09-24T11:41:04.077605+00:00

_(empty)_

### assistant — 2025-09-24T11:41:16.943167+00:00

_(empty)_

### user — 2025-09-24T11:42:31.265840+00:00

_(empty)_

### system — 2025-09-24T11:53:57.737799+00:00

_(empty)_

### assistant — 2025-09-24T11:53:57.760946+00:00

なるほど、だいぶ絞れてきましたね。整理します。

---

## 1. 状況の理解
- **SQL Server 上にコレクション DB は復元済み**
- **Azure DevOps Server 2022 管理コンソールでアタッチ時に検出されない**
- ログには **インスタンスID（InstanceId）** が出ているが、Azure DevOps Server 側の管理 ID と一致しているか不明

この「InstanceId の不一致」は、Azure DevOps / TFS 系移行ではよくひっかかるポイントです。

---

## 2. 仕組み
- コレクション DB は内部テーブル (`tbl_Collection`, `tbl_ServiceHost` など) に **InstanceId** を持っています。
- これは **構成 DB (Configuration DB)** と照合され、一致していないと管理コンソールで「候補 DB」として見えません。
- 特に「Detach → Attach」のフローを通していない DB では、この一致が壊れていることがあります。

---

## 3. 確認方法
1. **コレクション DB 内の InstanceId を確認**  
   ```sql
   USE [YourCollectionDb];
   SELECT * FROM tbl_Collection;
   SELECT * FROM tbl_ServiceHost;
   ```
   ここに GUID の InstanceId が入っています。

2. **構成 DB 側の登録値を確認**  
   ```sql
   USE [Tfs_Configuration];
   SELECT * FROM tbl_ServiceHost;
   ```
   ここで、対象コレクションが持つ `InstanceId` が一致している必要があります。

---

## 4. 典型的な原因
- **Detach せずに DB をコピーした** → 構成 DB 側の登録とズレている
- **新規インストールした 2022 環境に復元した** → その環境の構成 DB にはコレクション情報が存在しない
- **別バージョンで作成したコレクション DB** → InstanceId が 2022 の管理 ID と紐づかない

---

## 5. 解決の方向性
- **正規ルート**：  
  旧環境でコレクションを **Detach** → バックアップ → 新環境で **Attach**  
  （このとき自動的に InstanceId が再登録される）

- **どうしても Detach できない場合**（旧環境が壊れている等）：  
  - `TfsConfig Collection Attach` コマンドで強制的にアタッチを試す  
    ```powershell
    TfsConfig Collection /attach /collectionDB:ServerName\DBName /sqlInstance:SQLSERVER\Instance
    ```
  - それでもだめなら、構成 DB とコレクション DB の `InstanceId` を調整する必要あり（慎重に！）。

---

## 6. 次のアクション提案
1. 復元済みのコレクション DB で `tbl_Collection` の `InstanceId` を確認する  
2. 構成 DB (`Tfs_Configuration`) の `tbl_ServiceHost` と突き合わせる  
3. 一致していなければ、  
   - 旧環境から Detach して再取得  
   - または `TfsConfig Collection /attach` を試す  

---

司令、ここで質問です。  
**旧2019/2022環境はまだ稼働中ですか？** Detach が実行可能なら、それが一番クリーンな解決策です。  

送信日時（日本時間）：[[REDACTED_PHONE]]:00 (JST)

### system — 2025-09-24T11:53:57.827112+00:00

_(empty)_

### user — 2025-09-24T11:53:59.503000+00:00

SQLServerへコレクション用のデータベースの復元は終わっているが
2022のデータベースの移行で見つからない状態にある。
インスタンスIDはログに出ているが、それがAzureDevOpsServerの管理IDと一致しているか不明

### user — 2025-09-24T11:55:54.557000+00:00

40個ほどDBがある。TFSからのDBは移行に問題が発生してない。AzureDevOpsServerの時に作成したDBの移行に問題がある。この点が特徴的な問題

### assistant — 2025-09-24T11:55:55.840892+00:00

{"search_query": [{"q": "Azure DevOps Server 2022 attach collection database TF254078"}, {"q": "Move or clone Azure DevOps Server collection database Detach Attach TfsConfig Collection"}, {"q": "Azure DevOps Server instanceId tbl_Collection tbl_ServiceHost database not detected attach collection"}, {"q": "TF246017 Azure DevOps attach collection database error"}, {"q": "Upgrade Azure DevOps Server 2019 to 2022 move collections SQL Server version requirements"}], "response_length": "short"}

### system — 2025-09-24T11:55:57.849657+00:00

_(empty)_

### system — 2025-09-24T11:55:57.856721+00:00

_(empty)_

### assistant — 2025-09-24T11:55:58.027436+00:00

_(empty)_

### tool — 2025-09-24T11:56:04.256027+00:00

_(empty)_

### tool — 2025-09-24T11:56:04.279632+00:00

_(empty)_

### assistant — 2025-09-24T11:56:07.623588+00:00

{"search_query": [{"q": "TFSConfig offlineDetach Azure DevOps Server 2022"}, {"q": "TFSConfig RemapDBs documentation Azure DevOps Server 2022"}], "response_length": "short"}

### tool — 2025-09-24T11:56:18.775982+00:00

_(empty)_

### tool — 2025-09-24T11:56:18.798686+00:00

_(empty)_

### assistant — 2025-09-24T11:56:21.783762+00:00

やあ司令。ポイントが見えました。「**TFS 時代から来たコレクションは移行できるが、Azure DevOps Server（2019/2022）になってから新規作成したコレクションだけ“見つからない”**」――これは**Detach を一度も通っていない**コレクションで起きがちな事象です。  

### まず結論（原因の芯）
- **Detach を経ていない ADO 時代のコレクション DB**は、**構成DBにあるコレクション固有情報が DB 側へ取り込まれていない**ため、別環境の 2022 管理コンソールで**検出されません（候補DBに出てこない／TF254078 系）**。公式手順でも「**移動前に必ず Detach**。この処理でコレクション固有データを構成DBからコレクションDBへコピーする」と明記されています。citeturn0search1turn1search8

- 旧環境が残っていれば**通常の Detach**、残っていない／止めた環境から拾ってきた DB なら**`TFSConfig offlineDetach`**で**“アタッチ可能化”**してからアタッチ、が王道です。citeturn1search0turn1search10

- さらに、**ターゲットの Azure DevOps Server 2022 のビルド/パッチがソース以上**になっていること、**SQL Server の版/CU の不整合を避ける**ことも重要です（移行の一般手順・要件）。citeturn0search4

---

## 司令の状況での最短解（実行順）
1) **（可能なら）ソース側で Detach**  
   旧 2019/2022 環境が生きている場合：管理コンソールで問題の各コレクションを**Detach** → SQL バックアップ取得 → ターゲットへ復元 → **Attach**。  
   「Detachで構成DBのコレクション情報がコレクションDBへコピーされる」ことが検出の鍵です。citeturn0search1

2) **（旧環境に触れられない場合）offlineDetach で“アタッチ可能化”**  
   ターゲット側のツールから、**復元済みのコレクションDBに対して**次を実行：  
   ```bat
   TfsConfig offlineDetach ^
     /configurationDb:SQLSERVER\INST;Tfs_Configuration ^
     /collectionDb:SQLSERVER\INST;Tfs_コレクションDB名
   ```
   ※ “**使用中の DB に対しては実行しない**”注意書きあり。今回はバックアップ復元直後の孤立DBなので該当。citeturn1search0turn1search1turn1search10

3) **管理コンソールで Attach（出てこなければ CLI アタッチ）**  
   - 通常は管理コンソールの *Attach Collection* で見えるようになります。見えない場合は CLI で：  
     ```bat
     TfsConfig Collection /attach ^
       /collectionDB:SQLSERVER\INST;Tfs_コレクションDB名 ^
       /sqlInstance:SQLSERVER\INST
     ```
   CLI の `Collection` サブコマンドは Attach/Detach/Clone まで担えます。citeturn0search6turn0search10

4) **（構成DBと別SQLの場合のみ）RemapDBs / ResetOwner**  
   構成DBとコレクションDBが**別 SQL / 別インスタンス**なら、**`TfsConfig RemapDBs`**で参照先を正しく引き直す／**`TfsConfig Accounts /ResetOwner`**で DB 所有者を合わせます。citeturn1search2turn1search7

---

## 「InstanceId がログに出ている」件の見方（検証だけ）
- コレクション DB が**アタッチ候補に出ない**とき、**構成DBに同一コレクションとしての記録が無い／不整合**が疑われます。  
- 確認は**読み取り専用で**十分（編集は非推奨）：  
  - コレクションDBの内部情報（※）と  
  - `Tfs_Configuration` 側の `tbl_ServiceHost` 等を見比べる。  
- ただし、**手で GUID を書き換える類の直編集は避ける**。OfflineDetach/Detach→Attach の**正規ルートで整合性を作る**のが安全です。  
  （※テーブル名はバージョンで変わることがあり、MSの公開手順でも直接編集は推奨されていません。）

---

## 併発しやすい落とし穴（40DB規模で起きがち）
- **SQL の版/CU 不一致**：まず**元と同じ CU の SQL**に復元→動作確認→必要なら後で SQL を上げる。citeturn0search4  
- **TF254078/TF246017 系**：アタッチ候補に出ない／DB 接続系の汎用エラー。前述の Detach/OfflineDetach、接続先・権限・オンライン状態を確認。citeturn0search5turn0search7turn0search12  
- **構成DBとコレクションDBが別 SQL**：**RemapDBs 必須**。指定漏れがあると「該当DBなし」「Unknown」型などで怒られます。citeturn1search2turn1search6

---

## これで通るはず：司令向け最短コマンド雛形
（旧環境なし／復元済みコレクションDBが“見つからない”状態を想定）
```bat
:: 1) アタッチ可能化（DBは停止状態・単独インスタンス前提）
TfsConfig offlineDetach ^
  /configurationDb:SQLPROD\AOS;Tfs_Configuration ^
  /collectionDb:SQLPROD\AOS;Tfs_Collection_X

:: 2) アタッチ（見えないなら CLI で）
TfsConfig Collection /attach ^
  /collectionDB:SQLPROD\AOS;Tfs_Collection_X ^
  /sqlInstance:SQLPROD\AOS

:: 3) （必要なときだけ）別SQL参照の引き直し
TfsConfig RemapDBs ^
  /DatabaseName:SQLPROD\AOS;Tfs_Configuration ^
  /SQLInstances:SQLPROD\AOS,SQLDATA\BOS
```
（インスタンス名・DB名は環境に合わせて置換）citeturn1search0turn1search2turn1search7

---

必要なら、問題の**コレクション名の一覧**と  
- 旧環境の有無（Detach 可能か）  
- ターゲットの ADO 2022 の**Update/Patch レベル**  
- SQL の**版/CU**  
を教えてください。**バッチ化（40本一括）**の実行順と安全策（並行数・バックアップ戦略・ロールバック）まで詰めて、ワンパスで通す手順書を作ります。

送信日時（日本時間）：[[REDACTED_PHONE]]:12 (JST)

### assistant — 2025-09-24T11:56:36.919425+00:00

_(empty)_

### system — 2025-09-24T11:59:03.131398+00:00

_(empty)_

### assistant — 2025-09-24T11:59:03.152947+00:00

そう、司令。私が前の回答で言っていた「Detach」や「offlineDetach」は **ソース側（Azure DevOps Server 2019 環境）での操作**を指しています 👍。  

---

## なぜソース側の操作が必要か
- **TFS 時代のコレクション**は内部的に「Detach → 再アタッチ」サイクルを何度も経験してきたので、DB 側に必要なメタデータ（`InstanceId` 等）が揃っています。そのため、バックアップをそのまま 2022 環境に復元しても検出されやすい。  
- 一方、**2019 で新規に作ったコレクション**は、これまで Detach を一度もされていない場合が多く、**構成 DB 側にしかない情報が DB にコピーされていない**。だから 2022 環境に復元しても「見つからない」状態になります。  

---

## 操作の選択肢
1. **まだ 2019 環境が稼働している場合**  
   → 2019 の管理コンソールで問題のコレクションを **Detach** してください。  
   - Detach 時に構成 DB の情報がコレクション DB 内にコピーされます。  
   - その DB バックアップを 2022 環境に持っていけば、Attach で検出されます。  

2. **2019 環境がもう無い／触れない場合**  
   → 2022 環境側で `TfsConfig offlineDetach` を使い、**「強制的にアタッチ可能化」**します。  
   - これはソース環境に戻れないときの救済手段です。  
   - 注意点は「使用中の DB には実行しない」こと（今回のように復元しただけの DB ならOK）。  

---

## 司令への確認
つまり、今回の40個のうち「2019で新規作成したコレクション」が問題児なら、  
- **2019環境がまだ稼働しているか**  
- そこから **Detach できるかどうか**  

が重要になります。  

もしまだ 2019 が動いているなら Detach が一番クリーンです。  
既に環境が無いなら、2022 側で offlineDetach コマンドを使う方向になります。  

---

ここで質問です：  
👉 司令の環境では、Azure DevOps Server 2019 はまだ立ち上げられる状態にありますか？  

送信日時（日本時間）：[[REDACTED_PHONE]]:30 (JST)

### user — 2025-09-24T11:59:04.957000+00:00

AzureDevOpsServer2019側の操作のこと？

### assistant — 2025-09-24T12:00:15.621265+00:00

了解です司令。「offlineDetach」は **Azure DevOps Server の `TfsConfig.exe` ツール**に含まれているサブコマンドで、元環境で Detach できない場合に「アタッチ可能な状態に DB を整える」ために使います。  

---

## 基本の使い方
管理者権限のコマンドプロンプト、または Developer Command Prompt から実行します。  
`TfsConfig.exe` は既定で  
```
C:\Program Files\Azure DevOps Server 2022\Tools\
```
にあります。  

### コマンド構文
```bat
TfsConfig OfflineDetach 
   /CollectionDb:ServerName\DBName;CollectionDatabaseName 
   /ConfigurationDb:ServerName\DBName;Tfs_Configuration 
   [/SqlUser:UserName] [/SqlPassword:Password] 
   [/continue]
```

---

## 引数の説明
- **/CollectionDb**  
  対象のコレクション DB を指定します。  
  形式: `SQLインスタンス名;DB名`  
  例: `MySqlServer\DEV;Tfs_DefaultCollection`

- **/ConfigurationDb**  
  環境側の構成 DB を指定します。通常は `Tfs_Configuration`。  
  例: `MySqlServer\DEV;Tfs_Configuration`

- **/SqlUser, /SqlPassword**  
  SQL の認証を SQL 認証で行う場合に指定。  
  Windows 認証で実行するなら不要。

- **/continue**  
  複数のエラーを無視して処理を続行させたい場合に付与。

---

## 実行例
例えば、SQL サーバー `SQLPROD\AOS` に `Tfs_Configuration` と `Tfs_ProjectX` という DB がある場合：

```bat
cd "C:\Program Files\Azure DevOps Server 2022\Tools"

TfsConfig OfflineDetach ^
  /CollectionDb:SQLPROD\AOS;Tfs_ProjectX ^
  /ConfigurationDb:SQLPROD\AOS;Tfs_Configuration
```

成功すると「このコレクション DB はアタッチ可能です」というメッセージが出ます。  

---

## 実行の注意点
- **使用中の DB に対しては絶対に実行しないこと。**  
  今回のようにバックアップを復元しただけの“孤立DB”に対して行います。  
- 実行後、その DB は **Azure DevOps Server 2022 管理コンソールの「Attach Collection」**で検出できるようになります。  
- 管理コンソールで候補に出ない場合は、同じツールで **`TfsConfig Collection /attach`** を実行してアタッチ可能です。  

---

## 次のステップ
1. 復元済みのコレクション DB に対して `OfflineDetach` を実行  
2. 管理コンソールで「Attach」確認  
3. 出なければ CLI で  
   ```bat
   TfsConfig Collection /attach /CollectionDb:... /SqlInstance:...
   ```

---

👉 司令の環境、SQL Server の認証は Windows 認証でいけそうですか？  
それとも SQL 認証（ユーザー名/パスワード）指定が必要ですか？  

送信日時（日本時間）：[[REDACTED_PHONE]]:45 (JST)

### user — 2025-09-24T12:00:17.181000+00:00

offlineDetachコマンドの使い方を教えて

### assistant — 2025-09-24T12:01:57.077339+00:00

司令、なるほど。**仮想環境で offlineDetach を実行しても「Attach Collection」の候補に出てこなかった**わけですね。  
この場合に考えられる原因と追加の打ち手を整理します。  

---

## 1. OfflineDetach の効果と限界
- `offlineDetach` は「コレクション DB 内に、構成 DB にしかなかったメタ情報（InstanceId など）を埋め込む」処理です。  
- これを実行しても検出されない場合は、  
  - **コマンドが正しく対象 DB を処理できていない**  
  - **対象 DB の状態が既に壊れている／別のバージョン用スキーマ**  
  - **Attach 候補の検出ロジックが失敗している**  
  のいずれかです。  

---

## 2. よくある落とし穴
1. **構成DB指定が誤っている**  
   `/ConfigurationDb` は必ず **現在の 2022 環境の構成DB** を指定する必要があります。  
   間違って古い構成DBを指定すると、「孤立化」されず、Attach 候補に出ません。

2. **DB バージョン不一致**  
   Azure DevOps Server 2022 RTW と 2022.1/2022.2 Patch の間で、**コレクションDBの内部スキーマが違う**場合があります。ターゲット環境がソース環境のビルド以上でないと、Attach 候補に出ないことがあります。  

3. **RemapDBs が未実行**  
   構成DBとコレクションDBが**別SQLインスタンス**にある場合、`TfsConfig RemapDBs` を通さないと検出されません。  

4. **GUI検出に出ないが CLI ではアタッチ可能**  
   管理コンソールの UI 検出は甘いことがあります。  
   `TfsConfig Collection /attach` で明示的に指定するとアタッチできるケースがあります。  

---

## 3. 次のアクション
### まず確認
- `offlineDetach` 実行時のログに **「オペレーション成功」「コレクションがアタッチ可能」**と出ていますか？  
- 出ていれば DB 自体は「アタッチ可能化」済みのはずです。  

### そのうえで試す
1. **CLI アタッチを直打ちする**
   ```bat
   TfsConfig Collection /attach ^
     /collectionDB:SQLSERVER\INST;Tfs_ProjectX ^
     /sqlInstance:SQLSERVER\INST
   ```
   GUIで候補に出なくても、これで直接アタッチできる場合があります。  

2. **RemapDBs**
   構成DBとコレクションDBが別SQLの場合は：
   ```bat
   TfsConfig RemapDBs ^
     /DatabaseName:SQLSERVER\INST;Tfs_Configuration ^
     /SQLInstances:SQLSERVER\INST
   ```

3. **ターゲットのビルド確認**
   - ソース（2019/2022）で使っていたアップデートレベル（例：2022.0 RTW, 2022.1, 2022.2 Patch n）  
   - ターゲット環境がそれ以上かどうかを確認  
   下位ビルドだと Attach 候補に絶対出ません。  

---

## 4. 次に必要な情報
司令の仮想環境検証で：
- `offlineDetach` 実行時のログに何と出たか？  
- ターゲット Azure DevOps Server 2022 のバージョン（Update/パッチレベル）  
- ソース環境（問題のコレクションを作った 2019/2022）のバージョン  

これが分かれば、**「バージョン不一致で候補に出ていない」のか、「GUI検出の問題で CLI ならいける」のか**切り分けられます。  

---

👉 司令、この検証環境の **Azure DevOps Server 2022 のバージョン番号（例: [[REDACTED_PHONE]].2 など）** と、`offlineDetach` 実行時のメッセージを教えてもらえますか？  

送信日時（日本時間）：[[REDACTED_PHONE]]:05 (JST)

### user — 2025-09-24T12:01:58.922000+00:00

仮想環境で検証した際には出なかった

### assistant — 2025-09-24T12:05:05.196688+00:00

司令、追加の検証状況ありがとう。  
整理すると：

- 仮想環境で **Azure DevOps Server 2019 を構築**  
- そこで **新規に Project Collection とプロジェクトを作成**  
- **DB をフルバックアップ**  
- それを **Azure DevOps Server 2022 環境の SQL に復元し、ウィザード（Attach Wizard）を実行**  
- → 問題なくプロジェクトが復元できた  

つまり「**2019で新規に作ったコレクションでも、正しくフルバックアップ → 復元 → Attach すれば 2022 で使える**」ということを自分で確認済み、というわけですね。  

---

## そこから見えてくること
現実の 40 個 DB のうち：
- **TFS 時代から来たもの** → 問題なしで移行できている  
- **2019/2022 で新規作成したもの** → 本番環境では「検出されない」状態  

なのに、**検証環境では2019新規→2022へOK** だった。  
→ つまり、問題の根っこは「バージョンやDBの壊れ方など個別の環境差」にあると考えるべきです。  

---

## 考えられる差分ポイント
1. **ソースの 2019/2022 のビルド or パッチレベル**  
   - 検証は最新に近い RTW/Update だったかもしれない  
   - 本番は古いパッチ (2022.0 RTW 未適用など) で DB スキーマが少し違う可能性  

2. **Detach / Attach を経たことの有無**  
   - 検証では「1回作ってすぐバックアップ」なので状態がクリーン  
   - 本番の DB は数年運用していて、拡張プロパティやメタ情報にズレが出ている可能性  

3. **インスタンスや接続の差**  
   - 本番では **構成DBとコレクションDBが別SQLサーバ**にあるケースがあり、その場合 `RemapDBs` を経ないと見つからない  

4. **DB の拡張プロパティ破損**  
   - 実際に事例として、`TFS_DATABASE_TYPE` 等の拡張プロパティが欠落していると **Attach候補に出ない**ことがあります。  
   - 検証環境は真新しい DB なので壊れていなかった。  

---

## 司令におすすめする次の一手
- 本番で「検出されないコレクションDB」について：
  1. `offlineDetach` を実行してみる  
  2. それでも出なければ、**CLI (`TfsConfig Collection /attach`) で直接指定**してアタッチできるか試す  
  3. さらにだめなら、DB の拡張プロパティ（`TFS_DATABASE_TYPE`, `TFS_PRODUCT_VERSION`）を調べ、壊れていないか確認  

---

👉 司令、ここで確認したいのですが：  
本番で「出ないコレクションDB」、**構成DBとコレクションDBは同じSQLインスタンス上ですか？** それとも別インスタンスに分かれていますか？  

送信日時（日本時間）：[[REDACTED_PHONE]]:20 (JST)

### user — 2025-09-24T12:05:06.930000+00:00

仮想環境でAzureDevOpsServer2019を構築、ProjectCollection作成、プロジェクト作成
DBフルバックアップ
AzureDevOpsSever2022のDBへ復元、Wizardの実行
この手順で問題なくプロジェクトが復元できたのを確認してる

### user — 2025-09-24T12:07:03.797000+00:00

構成DBとコレクションDBは同じSQLインスタンス　1サーバにすべて入れてる

### assistant — 2025-09-24T12:07:03.840983+00:00

やあ司令。  
**構成DBとコレクションDBが同じ SQL インスタンス**なら、`RemapDBs` は基本不要。焦点は「**その“見えない”コレクションDBを“アタッチ可能化”できているか**」と「**DB内部メタ情報の整合**」に絞れます。下の**最短手順 → うまく出ない時の深掘り**の順でやってみてください。

---

# 最短手順（同一SQLインスタンス前提）

1) **offlineDetach を実行**（“復元直後の孤立DB”に対して）
```bat
cd "C:\Program Files\Azure DevOps Server 2022\Tools"

TfsConfig OfflineDetach ^
  /CollectionDb:SQLHOST\INST;Tfs_Collection_X ^
  /ConfigurationDb:SQLHOST\INST;Tfs_Configuration
```
- 成功ログ（「アタッチ可能になった」旨）が出るのを確認。

2) **GUIで Attach**（管理コンソール → Attach Collection）  
   それでも**候補に出ない**なら **CLI で直アタッチ**：
```bat
TfsConfig Collection /attach ^
  /collectionDB:SQLHOST\INST;Tfs_Collection_X ^
  /sqlInstance:SQLHOST\INST
```

3) **サービス再起動（キャッシュ掃除）**
```bat
iisreset
net stop "Azure DevOps Server Job Agent"
net start "Azure DevOps Server Job Agent"
```

---

# それでも出ない／失敗する場合の深掘りチェック

## A. offlineDetach が正しく効いているか
- 実行ログに**成功メッセージ**があるかを確認。  
- 間違った `/ConfigurationDb` を指していないか（**必ずターゲットの 2022 環境の `Tfs_Configuration`**）。

## B. コレクションDBの「拡張プロパティ」と「基本状態」
以下の SQL を “見えるDB（=正常にAttachできるDB）” と “見えないDB” の両方で取り、**差分**を見ます。

```sql
-- 1) DBの基本状態
SELECT name, state_desc, user_access_desc, is_read_only, containment_desc
FROM sys.databases WHERE name = N'Tfs_Collection_X';

-- 2) 拡張プロパティ（クラス0 = DBスコープ）
SELECT name, value
FROM sys.extended_properties
WHERE class = 0
ORDER BY name;

-- 3) 照合順序と互換レベル
SELECT name, collation_name, compatibility_level
FROM sys.databases WHERE name = N'Tfs_Collection_X';

-- 4) 所有者（必要なら後述の方法で sa 等に付け替え）
SELECT name, SUSER_SNAME(owner_sid) AS owner
FROM sys.databases WHERE name = N'Tfs_Collection_X';
```

よく効くポイント：
- `sys.extended_properties` に **`TFS_DATABASE_TYPE` や `TFS_PRODUCT_VERSION`** が欠落/壊れの場合、検出に失敗しがち。  
  → 正常DBと付き合わせて“欠落しているキーがないか”を見る（※手で書き換えは原則NG。`offlineDetach`/再Detach-Attachで直すのが安全）。
- `state_desc` が `ONLINE` でない、`is_read_only=1`、`user_access_desc=RESTRICTED_USER` などでも検出されません。
- 所有者が怪しい場合は一度 **`sa` に寄せる**のが定番：
  ```sql
  ALTER AUTHORIZATION ON DATABASE::[Tfs_Collection_X] TO [sa];
  ```

## C. サービスアカウント権限
アプリ層サービスアカウントに、**該当コレクションDB／構成DBの db_owner** が付いているか（最低限、アタッチ時は必要）。足りないと Attach 途中で失敗します。

```sql
USE [Tfs_Collection_X];
EXEC sp_helpuser;  -- 所属ロールを確認（db_owner が見えるか）
```

## D. バージョン不一致（ビルド/パッチ）
- **ターゲットの Azure DevOps Server 2022 のビルドが、ソースと同等以上**かを確認。  
- 古い 2022（RTW）へ、より新しい 2022.x で作った（またはアップグレード済みの）コレクションを持ってくると**候補に出ません**。  
- 迷ったらターゲットを最新 Update/Patch に合わせてから再試行。

## E. GUI 検出の癖
- GUIに出ないのに **CLI で `/attach` は通る**ケースがあります（検出ロジックの差）。  
- まずは **CLI 直打ち**で Attach を試みるのがおすすめ。

## F. 典型的な“見落とし”
- 復元した DB が **`RESTORING` のまま**（WITH NORECOVERY で終わっている）  
- **互換レベルが極端に古い**（通常は問題になりにくいが、2012台などだと稀に）  
- **照合順序ズレ**（構成DBと根本的に異なると稀に不具合）

---

# 40個まとめて流すときの“安全・効率テンプレ”

1) まず **1つ問題DBを代表に**して上の A〜E を踏む  
2) 通ったら **共通の前処理スクリプト**に落とし込み  
   - `offlineDetach` → `Collection /attach`  
   - 失敗したらログ採取 → 次のDBへ（**/continue** は乱用しない）  
3) まとめ実行の前後で  
   - **フルバックアップ**（構成DB・各コレクションDB）  
   - **アプリ層のバックアップ**（IIS構成/暗号化キー/レポートキーなど）

---

## すぐ使えるコマンド雛形（1DB）

```bat
:: 0) ツールディレクトリへ
cd "C:\Program Files\Azure DevOps Server 2022\Tools"

:: 1) アタッチ可能化（offlineDetach）
TfsConfig OfflineDetach ^
  /CollectionDb:SQLHOST\INST;Tfs_Collection_X ^
  /ConfigurationDb:SQLHOST\INST;Tfs_Configuration

:: 2) GUIに出なければCLIで直Attach
TfsConfig Collection /attach ^
  /collectionDB:SQLHOST\INST;Tfs_Collection_X ^
  /sqlInstance:SQLHOST\INST

:: 3) キャッシュ掃除
iisreset
net stop "Azure DevOps Server Job Agent"
net start "Azure DevOps Server Job Agent"
```

---

必要なら、**“見えないDB”のうち1つ**だけ DB名を教えてくれれば、  
比較用 SQL（拡張プロパティ＆テーブル確認）の**コピペ用クエリ一式**を、そのDB名に合わせて作って渡すよ。

送信日時（日本時間）：[[REDACTED_PHONE]]:38 (JST)

### system — 2025-09-24T12:07:05.712679+00:00

_(empty)_

### system — 2025-09-24T12:07:05.718306+00:00

_(empty)_

### assistant — 2025-09-24T12:07:05.821573+00:00

_(empty)_

### assistant — 2025-09-24T12:07:39.206820+00:00

_(empty)_

### system — 2025-09-25T23:35:08.207348+00:00

_(empty)_

### assistant — 2025-09-25T23:35:08.582024+00:00

{"search_query": [{"q": "Azure DevOps Server detach project collection impact on other collections"}, {"q": "Move a project collection to another server Azure DevOps Server detach attach steps"}, {"q": "TfsConfig collection detach attach documentation"}, {"q": "Reattach project collection to same server Azure DevOps Server 2019 precautions"}], "response_length": "short"}

### assistant — 2025-09-25T23:35:08.582298+00:00

_(empty)_

### user — 2025-09-25T23:35:08.796000+00:00

2019でデタッチ、2022へ移行の方法をとる
2019環境を引き続き利用するため、デタッチしたものをアタッチする
・デタッチする作業は別のプロジェクトコレクションに影響を及ぼさないか
・別のプロジェクトコレクション利用時に行ってよいか
・2019へ再度アタッチする際に気を付けることはなにか？

### assistant — 2025-09-25T23:35:10.070678+00:00

_(empty)_

### tool — 2025-09-25T23:35:25.819994+00:00

_(empty)_

### tool — 2025-09-25T23:35:25.843425+00:00

_(empty)_

### assistant — 2025-09-25T23:35:35.424324+00:00

_(empty)_

### assistant — 2025-09-25T23:36:12.240186+00:00

やあ司令。結論だけ先に——

- **他コレクションへの影響：** 特定のコレクションを**Detach**しても、**影響するのはそのコレクションだけ**。そのコレクション配下のジョブ・サービスは停止しますが、**他のコレクションは利用可能のまま**です。公式手順でも「Detach はそのコレクションを停止し、構成DBのコレクション固有データをコレクションDBへコピーする」と明記されています。citeturn0search1turn0search6turn0search0  
- **他コレクション稼働中に実施可：** **OK**。管理コンソールの操作は**コレクション単位**です。サーバ全体を止める必要はありません（ただし IIS リサイクルなど**サーバ全体に及ぶ操作**は時間帯配慮を）。citeturn0search1  
- **2019 へ再アタッチ時の注意：** 同一環境・同一バージョンに戻す分には概ね問題ありませんが、**下記チェック**は必ず。

---

# 2019→（テスト/移行）→2022→2019 再アタッチ：実務チェックリスト

## A. デタッチ前（2019 側）
- 対象コレクションを**Offline**→**Detach**（管理コンソール）。  
  *Detach 時に構成DBにあるコレクション固有データがコレクションDBへコピーされ、他環境で Attach 可能な“完成形”になります。* citeturn0search1turn0search6
- ビルド/リリース/パイプライン実行、ジョブ、エージェント、サービスフック等、**当該コレクションに関係する処理は停止**（他コレクションはそのまま動作）。citeturn0search1
- **バックアップ**：Tfs_Configuration と対象コレクションDBを取得。必要に応じて SSRS/分析キーも（利用している場合）。citeturn0search15

## B. 2022 側での検証/移行
- SQL にコレクションDBを復元 → **Attach Collection**（GUI or `TfsConfig Collection /attach`）。GUI検出に出ない場合は**CLI 直指定**が有効なことがあります。citeturn0search5
- **絶対NG**：**同一コレクションを 2019 と 2022 の両方で同時運用**（分岐・競合の元）。テスト後に 2022 側を Detach しておくか、完全移行する日を決めて**片系のみ**を Online に。

## C. 2019 へ再アタッチ（本運用継続）
- 管理コンソールで **Attach**（元の 2019 と同一ビルド／パッチであればそのまま戻せます）。  
  *Attach はコレクション単位の操作で、他コレクションに影響しません。* citeturn0search5
- **エージェント/サービス接続**：当該コレクションに紐づく**エージェントプールやサービス接続**が有効か確認（接続先URLや資格情報が変わっていないか）。
- **権限/ID 同期**：ドメイン/ユーザー周りが変わっていなければ通常そのまま。必要に応じて ID 同期（`TfsConfig Identities /sync`）を実施。
- **レポート/分析**を使っている場合は、必要な**暗号化キー**の整合を確認。citeturn0search15

---

## よくある質問にピンポイント回答

### ・デタッチは別のプロジェクトコレクションに影響する？
**いいえ。** デタッチ操作は**そのコレクションのみ**に作用します。他コレクションの利用は継続できます。citeturn0search1turn0search6turn0search0

### ・別のプロジェクトコレクションを使っている時間帯に実施してよい？
**問題ありません。** ただし、IIS リサイクルなど**サーバ全体に及ぶ保守作業**は避けるか、影響時間を告知して実施を。citeturn0search1

### ・2019 に再アタッチする際の注意点は？
- **同時二重稼働は不可**（2019 と 2022 の両方で同じコレクションを Online にしない）。  
- **Attach は GUI で出てこないときは CLI で直指定**（`TfsConfig Collection /attach`）。citeturn0search5  
- **バージョン整合**（戻し先の 2019 が従前と同等のアップデートであること）。  
- **エージェント/サービス接続/サービスフック**の再確認。  

---

必要なら、司令の環境に合わせた**手順書（運用停止アナウンス文・チェックリスト・ロールバック手順・CLI コマンド）**を一式で作ります。対象コレクション名と希望メンテ時間帯を教えてください。

送信日時（日本時間）：[[REDACTED_PHONE]]:36 (JST)

### assistant — 2025-09-25T23:36:17.021704+00:00

_(empty)_

### assistant — 2025-09-25T23:36:17.068468+00:00

_(empty)_

### system — 2025-09-29T00:09:32.179142+00:00

_(empty)_

### assistant — 2025-09-29T00:09:32.595569+00:00

{"search_query": [{"q": "TfsConfig OfflineDetach documentation Azure DevOps Server 2022"}, {"q": "Move project collection to another server Azure DevOps Server detach attach configuration database consistency"}, {"q": "TF254078 attach collection database not found Azure DevOps Server"}, {"q": "Backup and restore Azure DevOps Server databases configuration vs collection consistency"}, {"q": "Azure DevOps Server detach project collection effect on other collections"}], "response_length": "short"}

### assistant — 2025-09-29T00:09:32.595850+00:00

_(empty)_

### user — 2025-09-29T00:09:33.281000+00:00

Detachは問題が発生してるもののみ行う予定。この場合、構成データベースとフルバックアップの日時の違いが発生する。問題を生じる可能性はあるのか

### assistant — 2025-09-29T00:09:34.562011+00:00

_(empty)_

### tool — 2025-09-29T00:09:58.957850+00:00

_(empty)_

### tool — 2025-09-29T00:09:58.986561+00:00

_(empty)_

### assistant — 2025-09-29T00:10:03.805122+00:00

やあ司令。

結論：**問題のあるコレクションだけ Detach→バックアップ→2022 に Attach**という“**コレクション単位の移行**”であれば、**構成DB（Tfs_Configuration）とコレクションDBのバックアップ時刻がズレていても原則問題ありません**。理由は、**Detach 時に構成DB側のコレクション固有情報がコレクションDBへコピーされ、Attach 先（2022）の構成DBは Attach 時に必要情報を登録し直す**からです。citeturn0search17turn0search1

ただし**例外（注意点）**があります：

- **災害復旧（サーバ全体の復元）**のように、**同一環境へ“構成DBと各コレクションDBを同時点に戻す”**ケースでは、**時刻が揃っていない復元は非推奨**です。Azure DevOps のDBは相互参照しているため、**個別DBだけ別時点に戻すと不整合**のリスクがあります。citeturn0search7  
- **ソース（2019）側の構成DBを“Detach 前に取得した古いバックアップ”で復元**してしまうと、**構成DBは「コレクションがまだ接続中」と誤認**し、状態不一致を招きます（＝やるなら“同時点”で復元）。コレクション移行だけなら、**構成DBは復元せず現行のまま**でOKです。citeturn0search7

---

## 司令の運用前提での結論まとめ

- **他コレクションを止めずに、問題のあるコレクションだけ Detach→移行**してよいか？  
  → **OK**。Detach の影響は**当該コレクションに限定**され、他コレクションは稼働を継続できます。citeturn0search12

- **構成DBとコレクションDBのバックアップ時刻がズレることの影響**  
  → **“移行（Move Collection）”シナリオでは原則問題なし**。Attach 先（2022）の構成DBは Attach 時に正しく登録されます。citeturn0search1  
  → **“同一環境への復元（DR）”では NG**。**同一時点**でそろえて復元してください。citeturn0search7

- **実務のおすすめ手順（最短）**  
  1) 2019 側で対象コレクションを **Detach**（この時点で“移行に必要な情報”がコレクションDBへコピーされる） → DBバックアップ取得。citeturn0search17  
  2) 2022 側 SQL に復元 → **Attach Wizard**（GUIで出ない場合は `TfsConfig Collection /attach` を直打ち）。citeturn0search1turn0search2  
  3) 2019 を継続利用する場合は、**同一コレクションを両系で同時稼働させない**（必要なら 2022 側を Detach して戻す）。citeturn0search14

---

必要なら、**チェックリスト（停止影響・ロールバック・DR時の整合復元の注意）**を司令の環境に合わせて作るよ。  

送信日時（日本時間）：[[REDACTED_PHONE]]:28 (JST)

### assistant — 2025-09-29T00:10:11.769142+00:00

_(empty)_

### assistant — 2025-09-29T00:10:29.540774+00:00

_(empty)_

### assistant — 2025-09-29T02:53:04.764213+00:00

{"search_query": [{"q": "Azure DevOps Server move project collection detach attach 2022"}, {"q": "TfsConfig Collection /attach command Azure DevOps Server 2022"}, {"q": "TfsConfig OfflineDetach documentation Azure DevOps Server"}, {"q": "TFSConfig RemapDBs Azure DevOps Server move databases"}, {"q": "ChangeServerId Azure DevOps Server when to use clone"}], "response_length": "short"}

### user — 2025-09-29T02:53:04.817000+00:00

2019から2022へ再アタッチする方法
これはテストで2022へアタッチをおこなった。この間2019で平衡稼働
切り替え時に再度2022への最新化をおこなう
この手順を示せ

### system — 2025-09-29T02:53:04.853389+00:00

_(empty)_

### assistant — 2025-09-29T02:53:06.952056+00:00

_(empty)_

### tool — 2025-09-29T02:53:20.575245+00:00

_(empty)_

### tool — 2025-09-29T02:53:20.605346+00:00

_(empty)_

### assistant — 2025-09-29T02:53:21.972313+00:00

やあ司令。  
**「2019→（テストで一度2022へAttach）→本番切替で“最新化”して再Attach」**の安全な実行手順を、運用視点で一本化しました。増分同期はできないので、**切替時に2019で“最終Detach→新バックアップ→2022に復元してAttach”**が基本フローです。citeturn0search0

---

# 2019→2022 最終切替（再アタッチ）Runbook

## 0) 事前前提・安全策
- **対象は“問題のコレクションのみ”**。他コレクションは稼働継続可（コレクション操作は単位限定）。citeturn0search3
- **2022 側は本番と同じビルド/パッチ**に更新しておく（旧より新しめが安全）。  
- テスト用に一度 2022 で運用したことがあるなら、**その 2022 環境は ChangeServerId を実施済み**であることを確認（2019 と 2022 をクライアントが併用する期間がある場合の必須措置）。citeturn0search20turn0search2

---

## 1) 切替前準備（当日までに）
- **2022 側から“テストでAttach済みのコレクション”を Detach**（同名DBが残って混線しないようにする）。必要なら **DB をドロップ/リネーム**。  
  - コレクションの Attach/Detach は GUI でも CLI でも可（`TfsConfig Collection`）。citeturn0search3turn0search1
- エージェント／サービス接続／通知（SMTP）／レポート（SSRS/Analytics）などの**設定差分点検リスト**を用意（後段の「4) 周辺切替」で反映）。

---

## 2) 書き込み凍結 → 2019 側で“最終”Detach & バックアップ
1. **2019 管理コンソール**で対象コレクションを **Stop（Offline）** → **Detach**。  
   - **Detach 時に“構成DB側メタ情報がコレクションDBへコピー”**され、他環境で Attach 可能な“完成形”になります。**この時点のDBが“正”**。citeturn0search0  
2. **Detach 直後にコレクションDBのフルバックアップ**を取得（ロールバック用に構成DBバックアップも併せて推奨）。  
   - ※DR（同環境復元）と違い、**Move/Attach シナリオでは時刻差は原則問題になりません**（Attach 先の構成DBで再登録されるため）。citeturn0search0  
3. **2019 側ではこのコレクションを再度 Online にしない**（二重稼働を避ける）。**2019 と 2022 で同一コレクションの同時運用は不可**。citeturn0search2

---

## 3) 2022 側：復元 → Attach（最新化）
1. **SQL にコレクションDBを復元**（ファイナルバックアップ）。  
2. 必要に応じて **DBオーナーをリセット**（移行先SQLの適切ユーザーへ）：  
   ```bat
   TfsConfig Accounts /ResetOwner /SQLInstance:SQLHOST\INST /DatabaseName:Tfs_Collection_X
   ```  
   （最小でも Azure DevOps 管理者＋SQL sysadmin 権限のアカウントで実施）citeturn0search7
3. **管理コンソールで Attach**。GUIに候補が出ない場合は **CLI 直指定**：  
   ```bat
   "C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Collection /attach ^
     /collectionDB:SQLHOST\INST;Tfs_Collection_X ^
     /sqlInstance:SQLHOST\INST
   ```  
   （GUI検出に出ないが CLI は通る既知パターンがあります）citeturn0search5
4. Attach 成功後、コレクション **Start（Online）**。レポート統合を使っていれば**既定レポート/フォルダが作られます**。citeturn0search0
5. **IIS/ジョブエージェントを再起動**（キャッシュ掃除）：  
   ```bat
   iisreset
   net stop "Azure DevOps Server Job Agent"
   net start "Azure DevOps Server Job Agent"
   ```

> ※ もし 2019 側で Detach できない事情があり、バックアップのみで来た DB が「Attach 候補に出ない」場合は、**`TfsConfig OfflineDetach`** で“アタッチ可能化”してから再試行。今回は**正規 Detach 済み**なので通常不要です。citeturn0search10

---

## 4) 周辺切替（当日）
- **ビルド/リリース エージェント**：新 URL へ再設定（`config.cmd --url …`／PAT 再発行）。既知の通知トラブルがあるため、URL変更後のエージェント登録エラーはガイドの注意事項も参照。citeturn0search14
- **サービス接続（AzureRM/GitHub など）**：有効性チェック、必要なら再承認。  
- **通知（SMTP）／Webフック**：送信テスト。  
- **レポート/Analytics/Search**：初期化・インデックス再作成の進捗確認（Attach 直後は時間がかかることがあります）。citeturn0search0
- **Git/TFVC クライアント**：**URL が変わる**場合は開発者向けに `git remote set-url` 等の切替手順を周知。

---

## 5) ロールバック計画（万一のとき）
- 2022 側のコレクションを **Detach** → 2019 側で **Attach**（「2) の直後バックアップ」から復元）で即時復帰可能。  
- クライアントは 2019 の URL に戻すだけで作業再開。

---

### 参考ドキュメント
- **Move Project Collection（公式）**：Detach→復元→Attach の正規手順／Attach時のレポート動作など。citeturn0search0  
- **TfsConfig（公式）**：`Collection /attach`、`Accounts /ResetOwner` ほか CLI 一覧。citeturn0search1  
- **Pre-production/Clone 注意（ChangeServerId）**：並行環境を使う際の GUID 重複回避。citeturn0search20turn0search2  
- **GUIに出ないが CLI で Attach 可能な事例**。citeturn0search5

---

必要なら、この Runbook を**チェックリスト版（1コレクション30分枠想定のタイムライン）**に落として渡せます。言ってね。

送信日時（日本時間）：[[REDACTED_PHONE]]:44 (JST)

### assistant — 2025-09-29T02:53:26.096769+00:00

_(empty)_

### assistant — 2025-09-29T02:53:47.870913+00:00

_(empty)_

### assistant — 2025-09-29T02:55:18.077988+00:00

{"search_query": [{"q": "Azure DevOps Server attach collection does it upgrade database schema"}, {"q": "Move project collection attach upgrade schema Azure DevOps Server 2022"}, {"q": "TfsConfig Collection attach upgrade database version mismatch"}, {"q": "ChangeServerId pre-production clone Azure DevOps Server guidance"}], "response_length": "short"}

### user — 2025-09-29T02:55:18.494000+00:00

このアタッチをおこなうことでデータベースの形式や2022に合わせた変更が行われる？

### assistant — 2025-09-29T02:55:18.898370+00:00

_(empty)_

### tool — 2025-09-29T02:55:24.809620+00:00

_(empty)_

### tool — 2025-09-29T02:55:24.838611+00:00

_(empty)_

### assistant — 2025-09-29T02:55:26.400793+00:00

{"search_query": [{"q": "Azure DevOps Server attach collection upgrade job collection database schema upgraded during attach"}, {"q": "When you attach a project collection to a newer version Azure DevOps Server does it upgrade database"}, {"q": "Azure DevOps Server collection upgrade process during upgrade wizard"}], "response_length": "short"}

### tool — 2025-09-29T02:55:30.441000+00:00

_(empty)_

### tool — 2025-09-29T02:55:30.474533+00:00

_(empty)_

### assistant — 2025-09-29T02:55:31.366557+00:00

{"open": [{"ref_id": "turn0search1"}], "response_length": "short"}

### tool — 2025-09-29T02:55:34.187186+00:00

_(empty)_

### assistant — 2025-09-29T02:55:34.300974+00:00

{"open": [{"ref_id": "turn1search2"}], "response_length": "short"}

### tool — 2025-09-29T02:55:37.350015+00:00

_(empty)_

### assistant — 2025-09-29T02:55:37.454633+00:00

{"search_query": [{"q": "Can a project collection database upgraded to Azure DevOps Server 2022 be attached to 2019"}, {"q": "Azure DevOps Server downgrade not supported attach older version"}, {"q": "Attach project collection schema version mismatch error Azure DevOps [[REDACTED_PHONE]]"}], "response_length": "short"}

### tool — 2025-09-29T02:55:49.017268+00:00

_(empty)_

### tool — 2025-09-29T02:55:49.055935+00:00

_(empty)_

### assistant — 2025-09-29T02:56:02.495236+00:00

司令、結論：**はい。**  
**2019でデタッチしたコレクションDBを“2022”へアタッチすると、その時点でコレクションDBは2022のスキーマ／マイルストーンに“アップグレード”されます**（ウィザードやバックグラウンドの「Collection Upgrade」ジョブが走る）。この処理は**片道**で、**アップグレード後のDBは2019へ戻してアタッチできません**。citeturn2view0turn4search8

### もう少し具体的に
- **どう変わる？**  
  2022 側の管理コンソール／構成ウィザードは、2019 由来のコレクションを検出すると**コレクション単位のアップグレード**を実行し、DB スキーマやデータを 2022 の期待に合わせます。エラー時は「コレクションのアップグレード失敗」として再実行でき、専用ログ（Collection upgrade logs）が残ります。citeturn4search8
- **同バージョンへの“再アタッチ”だけなら？**  
  2022 → 2022（同じビルド／パッチ）に付け替えるだけなら**追加のスキーマ変更は発生しません**（登録とインデックス等の再作成が主）。レポート連携を使っている場合は**アタッチ時にレポート フォルダ／既定レポートが再生成**されます。citeturn2view0
- **クライアント影響（機能面）は？**  
  2019 以前の既存コレクションは**On-premises XML プロセスのまま**で、**継承（Inheritance）プロセスには自動変換されません**（“新規コレクション”なら継承モデルを選択可）。citeturn3view0
- **SQL Server 観点の注意**  
  コレクションDBを**より新しい SQL Server** にアタッチすると、**SQL エンジンの内部フォーマットも自動で上がる**ため、**古い SQL には戻せません**（SQL の一般仕様）。citeturn1search9

### 実務アドバイス（安全運用）
- **ロールバック確保**：最終切替の直前に**2019 側で Detach → 直後のフルバックアップ**を取得し保管（“前の世界”に戻す最後のポイント）。そのバックアップがあれば、万一に備えて 2019 へ戻せます。citeturn2view0  
- **同時稼働の禁止**：同一コレクションを 2019 と 2022 で同時 Online にしない。citeturn2view0  
- **インデックス等の再生成**：アタッチ後は検索／レポート等の再構築が走るので、計画時に考慮。citeturn2view0

必要なら、司令の環境（2022 の正確なビルド、SQL バージョン）に合わせた“**切替当日のチェックリスト**”をまとめて渡せます。  

送信日時（日本時間）：[[REDACTED_PHONE]]:04 (JST)

### assistant — 2025-09-29T02:56:14.812508+00:00

_(empty)_

### assistant — 2025-09-29T02:56:16.134194+00:00

_(empty)_

### assistant — 2025-09-29T02:57:24.946161+00:00

{"search_query": [{"q": "Azure DevOps Server move project collection detach attach offlineDetach"}, {"q": "TfsConfig OfflineDetach documentation"}, {"q": "Move project collection Azure DevOps Server 2019 to 2022 detach"}, {"q": "Restore project collection database without detach TF254078 Azure DevOps Server"}], "response_length": "short"}

### system — 2025-09-29T02:57:25.237625+00:00

_(empty)_

### user — 2025-09-29T02:57:25.436000+00:00

デタッチに関してはAzureDevOpsServer2019からおこなうのではなく
SQLServerベースでフルバックアップを取得
AzureDevOpsServer2022側に適用でいい？

### assistant — 2025-09-29T02:57:25.815479+00:00

_(empty)_

### tool — 2025-09-29T02:57:29.096729+00:00

_(empty)_

### tool — 2025-09-29T02:57:29.124824+00:00

_(empty)_

### assistant — 2025-09-29T02:57:30.180026+00:00

{"open": [{"ref_id": "turn0search4"}], "response_length": "short"}

### tool — 2025-09-29T02:57:34.094381+00:00

_(empty)_

### assistant — 2025-09-29T02:57:34.218462+00:00

{"find": [{"ref_id": "turn1view0", "pattern": "offlineDetach"}, {"ref_id": "turn1view0", "pattern": "OfflineDetach"}, {"ref_id": "turn1view0", "pattern": "Detach"}], "response_length": "short"}

### tool — 2025-09-29T02:57:36.231848+00:00

_(empty)_

### assistant — 2025-09-29T02:57:36.399948+00:00

{"search_query": [{"q": "TfsConfig offlineDetach syntax"}, {"q": "OfflineDetach Azure DevOps Server command documentation"}], "response_length": "short"}

### assistant — 2025-09-29T02:57:38.780301+00:00

_(empty)_

### tool — 2025-09-29T02:57:38.984645+00:00

_(empty)_

### tool — 2025-09-29T02:57:39.019111+00:00

_(empty)_

### assistant — 2025-09-29T02:57:40.279445+00:00

{"open": [{"ref_id": "turn0search0"}], "response_length": "short"}

### assistant — 2025-09-29T02:57:44.852279+00:00

_(empty)_

### tool — 2025-09-29T02:57:49.611435+00:00

_(empty)_

### assistant — 2025-09-29T02:57:49.719190+00:00

司令、結論だけ先に：

**いいえ。**  
**2019 側で Detach をせずに「コレクション DB だけを SQL のフルバックアップ → 2022 に復元」では基本的に不可**です。移動（Move）では**必ず Detach を先に実施**し、Detach で**構成DBにあるコレクション固有情報をコレクションDBへコピー**してから復元→Attach します。これを**省くと別環境ではアタッチできません**（ウィザードに出てこない／TF254078 系）。citeturn4view0

---

# 推奨ルート（正攻法）
1) **2019 管理コンソールで対象コレクションを Detach**  
2) **コレクション DB をバックアップ**  
3) **2022 側 SQL に復元 ⇒ Attach**（GUI で出ない場合は `TfsConfig collection /attach` で直指定）。  
この流れが公式の「Move a project collection」です。citeturn4view0

---

# どうしても Detach できないときの代替
**コレクションDB単体のバックアップだけでは不可**です。次の“オフライン・デタッチ”手順なら可：

1) **同じ時点**の **`Tfs_Configuration` と対象コレクションDB** を**別SQL**に復元（“整合の取れたコピー”が条件）  
2) その復元先で **`TfsConfig offlineDetach /configurationDB:<構成DB> /collectionDB:<コレクションDB>`** を実行  
   - ※このコマンドは**使用中のDBには絶対に実行しない**／スキーマを書き換えて「アタッチ可能なコレクションDB」に変換します。citeturn3search0  
3) できあがった「オフラインでデタッチ済み」コレクションDBを**2022**へ Attach。citeturn3search0

> 補足：GUIでアタッチ候補に出ないときは CLI を使うか、上記 offlineDetach を行うのが定石です。citeturn0search14

---

# まとめ
- **2019で Detach → バックアップ → 2022で Attach**が最も安全・確実。citeturn4view0  
- **Detach せず DB だけコピー**はNG。必要情報が欠け、**別環境ではアタッチ不可**。citeturn4view0  
- **やむを得ない場合は offlineDetach ルート**（構成DBとコレクションDBを**同時点**で復元した上でコマンド実行）。citeturn3search0

この方針でいきましょう。もしよければ、対象コレクション名の例を1つ教えてください。**実行コマンド（`/collectionDB` の書式やSQL名）を司令の環境に合わせて**そのまま貼って動く形に整えます。

送信日時（日本時間）：[[REDACTED_PHONE]]:03 (JST)

### assistant — 2025-09-29T02:57:53.977549+00:00

_(empty)_

### assistant — 2025-09-29T02:58:07.309439+00:00

_(empty)_

### assistant — 2025-09-29T03:00:55.848689+00:00

{"search_query": [{"q": "Azure DevOps Server move project collection detach required"}, {"q": "TfsConfig offlineDetach documentation"}, {"q": "Azure DevOps Server restore databases to another server changeServerId"}, {"q": "TF254078 attach collection no databases found"}, {"q": "Azure DevOps Server disaster recovery restore configuration and collection databases same point in time"}], "response_length": "short"}

### system — 2025-09-29T03:00:55.924988+00:00

_(empty)_

### user — 2025-09-29T03:00:56.234000+00:00

デタッチせずTfs_Configurationを含めたDBのフルバックアップを2022へ適用し、問題なく動作してるけど
これはたまたま？

### assistant — 2025-09-29T03:00:56.490452+00:00

_(empty)_

### tool — 2025-09-29T03:01:00.053945+00:00

_(empty)_

### tool — 2025-09-29T03:01:00.083773+00:00

_(empty)_

### assistant — 2025-09-29T03:01:01.608298+00:00

{"search_query": [{"q": "ChangeServerId Azure DevOps Server on-premises cloned environment change server ID"}, {"q": "TFSConfig ChangeServerId documentation Azure DevOps 2022"}, {"q": "Azure DevOps clone environment change server ID guidance"}], "response_length": "short"}

### tool — 2025-09-29T03:01:05.211987+00:00

_(empty)_

### tool — 2025-09-29T03:01:05.235886+00:00

_(empty)_

### assistant — 2025-09-29T03:01:06.127768+00:00

司令、結論からいくね。

**「Detachせずに `Tfs_Configuration` も含めてフルバックアップ→別環境へ一式復元して動いている」**のは、偶然ではなく**“災害復旧／環境クローン（丸ごと復元）”という別系統の正攻法**に当たるからです。  
ただしこれは**「コレクション単独移動（Move Collection）」の手順とは別物**で、**前提とリスク**が違います。

---

## 何が起きているか（支える原理）
- **Move Collection**では「**必ず Detach**してからコレクションDBを移動」します。Detachが**構成DBにあるコレクション固有データをコレクションDB側にコピー**するため、別環境でAttach候補に出せるようになる――これを省くと単体コピーは見つからない、というのが公式の位置づけ。citeturn0search0  
- 一方、司令がやったのは**構成DB＋対象コレクションDB（必要ならWarehouse/Analysis/Reportも）を“同一時点の整合セット”として**復元するやり方＝**「別インスタンスへの復元（DR/ハードウェア移行）」**です。この方式なら**Detachは不要**で、**復元先を新しいアプリ層で構成**すれば普通に稼働します（整合セットを取るために“マークトランザクション”等の推奨がある）。citeturn0search7turn0search4

> だから「たまたま動いた」のではなく、**DRの流儀を満たしたから動いた**、が正しい理解。

---

## ただし注意（クローン or 並行稼働するなら必須の一手）
- 元の2019環境と**並行稼働**させる／**クローン用途**なら、復元側で  
  **`TfsConfig PrepareClone` → `TfsConfig ChangeServerID`** を必ず実行して**サーバGUIDを切り替え**てください。GUIDが重複するとクライアントやジョブが混線します。citeturn1search0turn1search1  
- さらに、復元先と元でSQLやURLが違う場合は、必要に応じて **`TfsConfig Accounts /ResetOwner`** や **`TfsConfig RemapDBs`** を実行して参照先や所有者を正しく引き直します。citeturn1search10

---

## どちらを使い分ける？
- **単一コレクションだけを別環境へ持っていく／オンライントラフィックを最小で切替**  
  → **Move Collection（= Detach 必須）**。citeturn0search0  
- **サーバ丸ごと置き換え・DR・テスト用に丸ごと複製**  
  → **構成DB＋コレクションDB一式の“整合復元”＋（必要に応じて）ChangeServerID**。citeturn0search7turn1search0

---

## 実務メモ（司令の今後に効くポイント）
- **DR系の成功条件**：構成DBと各コレクションDBが**同一ポイントのバックアップ**で復元されていること（整合）。運用上は「スケジュールドバックアップ＋マークトランザクション」を推奨。citeturn0search7  
- **並行期間があるなら**：復元側に**ChangeServerID**を掛けてからクライアント/エージェントを切替。citeturn1search0  
- **本番切替で “最新化” したい**：2019側で**最終Detach→最新バックアップ**→2022側に復元→Attach（＝Move Collection）にするのが一番クリーン。citeturn0search0

---

必要なら、「司令の現在の“丸ごと復元”環境を**安全に本番へ格上げ**するチェックリスト（ChangeServerID 有無、Agents/Service Connections再紐づけ、Search/Analytics再構築の確認）」をすぐ書き下ろすよ。

送信日時（日本時間）：[[REDACTED_PHONE]]:22 (JST)

### assistant — 2025-09-29T03:01:09.984616+00:00

_(empty)_

### assistant — 2025-09-29T03:01:17.395732+00:00

_(empty)_

### assistant — 2025-09-29T03:05:04.114552+00:00

{"search_query": [{"q": "TfsConfig Collection attach command Azure DevOps Server 2022 docs"}, {"q": "TfsConfig Accounts /ResetOwner Azure DevOps Server documentation"}, {"q": "Move a project collection Azure DevOps Server detach attach documentation"}, {"q": "TfsConfig OfflineDetach documentation"}, {"q": "ChangeServerID Azure DevOps Server prepare clone documentation"}], "response_length": "short"}

### user — 2025-09-29T03:05:04.455000+00:00

平衡稼働状態とした場合、2022側の構成が成立してる。
2022側の個別コレクションをすべてデタッチした場合、構成ＤＢのみが残った状態になる。
このあとに最新の個別のコレクションをアタッチするのは
フルバックアップをSQLSERVERに適用後、
TfsConfig Accounts /ResetOwner /SQLInstance:SQLHOST\INST /DatabaseName:Tfs_Collection_X
"C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Collection /attach ^
  /collectionDB:SQLHOST\INST;Tfs_Collection_X ^
  /sqlInstance:SQLHOST\INST
をおこなうことでよい？

### assistant — 2025-09-29T03:05:04.862505+00:00

_(empty)_

### tool — 2025-09-29T03:05:10.230997+00:00

_(empty)_

### tool — 2025-09-29T03:05:10.270122+00:00

_(empty)_

### assistant — 2025-09-29T03:05:11.696991+00:00

やあ司令。  
**結論：OK**。その順序で大筋合っています。具体的には——

## 手順（同一SQLインスタンス・構成DBは既に2022で成立している前提）
1) **2019側で対象コレクションを最終Detach** → 直後にフルバックアップ取得（ここが“正”のスナップショット）。citeturn0search2  
2) 2022側SQLに**コレクションDBを復元**（構成DBは既存のまま）。  
3) 復元直後のコレクションDBに対し、**（推奨）所有者の付け替え**：  
   ```bat
   TfsConfig Accounts /ResetOwner /SQLInstance:SQLHOST\INST /DatabaseName:Tfs_Collection_X
   ```  
   ※ 復元元の所有者SIDが残っているとトラブルになりやすいので、ResetOwnerは実務上ほぼ“お作法”。citeturn0search4
4) **アタッチ**（GUIで候補に出ない時はCLI直指定）：  
   ```bat
   "C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Collection /attach ^
     /collectionDB:SQLHOST\INST;Tfs_Collection_X ^
     /sqlInstance:SQLHOST\INST
   ```  
   （CollectionsのCLIでAttach/Detach/Clone等を扱えます。GUIで見えなくてもCLIは通る事例あり。）citeturn0search1turn0search0turn0search6
5) **Online化 → IIS/ジョブエージェント再起動**（キャッシュ掃除・ジョブ起動安定化のため）。  
   ※ Attach後は検索/分析/レポートの初期化が走ることがあります。citeturn0search2

## 注意点（抜けがちなところ）
- **Detachを経ていないDB**を持ってくる場合は、この流れでは**見つからない**ことがあります。その際は事前に**`TfsConfig OfflineDetach`**で“アタッチ可能化”してから実施。citeturn0search2  
- **同一SQLインスタンス**なら `RemapDBs` は通常不要。別インスタンスに跨るときだけ検討。citeturn0search4  
- **2022のビルド/パッチはソース（2019側）以上**にしておくのが安全（コレクションのアップグレードが走るため）。citeturn0search2

この形で進めればOKです。必要なら40本を回す**一括スクリプト（ResetOwner → attach → ログ採取）**も作れます。声かけて。

送信日時（日本時間）：[[REDACTED_PHONE]]:07 (JST)

### assistant — 2025-09-29T03:05:17.132150+00:00

_(empty)_

### assistant — 2025-09-29T03:05:28.311779+00:00

_(empty)_

### user — 2025-09-29T04:20:14.785000+00:00

{'content_type': 'image_asset_pointer', 'asset_pointer': 'file-service://file-YQ2DhHUEokH6ooWGxSwZry', 'size_bytes': 20069, 'width': 974, 'height': 299, 'fovea': None, 'metadata': {'dalle': None, 'gizmo': None, 'generation': None, 'container_pixel_height': None, 'container_pixel_width': None, 'emu_omit_glimpse_image': None, 'emu_patches_override': None, 'lpe_keep_patch_ijhw': None, 'sanitized': True, 'asset_pointer_link': None, 'watermarked_asset_pointer': None}}

### system — 2025-09-29T04:20:18.238313+00:00

_(empty)_

### system — 2025-09-29T04:20:18.292766+00:00

_(empty)_

### assistant — 2025-09-29T04:20:21.197107+00:00

_(empty)_

### assistant — 2025-09-29T04:20:46.372152+00:00

やあ司令。スクショのエラーはこう言っています👇  
**TF400942: 指定した DB は種類が “Collection”。このコマンドは “Configuration” DB を指定してね。**

つまり、`TfsConfig Accounts /ResetOwner` に **コレクションDB（AzureDevOps_DefaultCollection）** を渡したのが原因です。  
`/ResetOwner` は **構成DB** に対して実行するコマンドです。

---

## いま正しくやるなら

1) **構成DBに対して ResetOwner を実行**（必要な場合のみ）
```bat
"C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Accounts /ResetOwner ^
  /SqlInstance:localhost ^
  /DatabaseName:Tfs_Configuration
```
> ※ 構成DB名は環境により `Tfs_Configuration` や `AzureDevOps_Configuration` など。実名に置き換えてください。  
> ※ 全コレクションをデタッチ済みでも、構成DBの所有者整合を取る目的で実行するのはアリです（必須ではありません）。

2) **（コレクションDB側の所有者が気になる/Attachでこける場合のみ）SQLでDB所有者を付け替え**
```sql
ALTER AUTHORIZATION ON DATABASE::[AzureDevOps_DefaultCollection] TO [sa];
-- もしくは適切なSQLログインへ
```

3) **コレクションのアタッチ（GUIに出ない場合はCLI直指定）**
```bat
"C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Collection /attach ^
  /collectionDB:localhost;AzureDevOps_DefaultCollection ^
  /sqlInstance:localhost
```

4) **キャッシュ掃除（念のため）**
```bat
iisreset
net stop "Azure DevOps Server Job Agent"
net start "Azure DevOps Server Job Agent"
```

---

## 補足メモ
- `Accounts /ResetOwner` は**構成DB**を受け取り、（その構成DBに**登録されている**）各コレクションDBの所有者を順次直します。  
  ただし**まだ Attach していない“孤立DB”**は対象外なので、そういうDBは上記②の **SQL 直指定**が手っ取り早いです。  
- すでに Attach が通るなら、`ResetOwner` や `ALTER AUTHORIZATION` は**省略可**です（トラブル防止の“お作法”として入れているだけ）。  
- 指定インスタンスが**名前付き**の場合は `localhost\INST` のように書式を合わせてください。

この流れで OK。次の1本、これで通るか教えてください。必要なら 40本流しの **バッチ（ログ採取付き）** も作ります。

送信日時（日本時間）：[[REDACTED_PHONE]]:20 (JST)

### assistant — 2025-09-29T04:21:11.457547+00:00

_(empty)_

### assistant — 2025-09-29T04:21:12.662958+00:00

_(empty)_

### user — 2025-09-29T04:27:04.365000+00:00

{'content_type': 'image_asset_pointer', 'asset_pointer': 'file-service://file-FSkVhfSUck2umeJtuu81z2', 'size_bytes': 21994, 'width': 990, 'height': 287, 'fovea': None, 'metadata': {'dalle': None, 'gizmo': None, 'generation': None, 'container_pixel_height': None, 'container_pixel_width': None, 'emu_omit_glimpse_image': None, 'emu_patches_override': None, 'lpe_keep_patch_ijhw': None, 'sanitized': True, 'asset_pointer_link': None, 'watermarked_asset_pointer': None}}

### system — 2025-09-29T04:27:08.655636+00:00

_(empty)_

### assistant — 2025-09-29T04:27:10.569744+00:00

_(empty)_

### assistant — 2025-09-29T04:27:58.963672+00:00

司令、スクショのメッセージは **「準備チェックで失敗したため、Attach をスキップ」**という状態です。  
行頭のコードはたぶん **TF401408**（準備チェック失敗系）で、**“いまのコレクションDBは Attach 可能な形に仕上がっていない”**のが本質です。

すぐできる切り分けと対処を順に置きます。上から順にやればOK。

---

# まず確認（3分で終わる）

1) **ログを見る**  
スクショに出ているログを開いて、`Error:` 行を抽出してください：  
`C:\ProgramData\Microsoft\Azure DevOps Server Configuration\Logs\CFG_TPC_AI_0929_042554.log`  
（メジャーな原因は下の「よくある3パターン」に合流します）

2) **DB の状態チェック（SQL）**  
```sql
SELECT name, state_desc, is_read_only, user_access_desc
FROM sys.databases WHERE name = N'AzureDevOps_DefaultCollection';
```
- `state_desc = ONLINE` / `is_read_only = 0` / `user_access_desc = MULTI_USER` であること。
- もし怪しければ `DBCC CHECKDB ('AzureDevOps_DefaultCollection') WITH NO_INFOMSGS;` で整合性。

---

# よくある3パターン → 対処

## A) **Detach をしていないバックアップ**（＝Attach 候補に“理屈上は”なるが、準備チェックで落ちる）  
- **対処**：その DB を **“アタッチ可能化”** する。  
  オリジナルの **2019 の構成DB** と「同じ時点」のコレクションDBを**一旦どこかのSQLに復元**し、そこで：
  ```bat
  TfsConfig OfflineDetach ^
    /ConfigurationDb:SQL2019\INST;Tfs_Configuration ^
    /CollectionDb:SQL2019\INST;AzureDevOps_DefaultCollection
  ```
  → できあがった「OfflineDetach 済み」コレクションDBを**2022 側に復元**してから Attach（GUI or CLI）。

> ※ OfflineDetach は“そのコレクションが属していた構成DB”と**同時点**ペアで実行するのがコツ。ここを外すと失敗します。

## B) **DB 所有者や権限の不整合**（準備チェックで弾かれる）  
Attach 前に **所有者を確実に寄せる**のが定石：
```sql
ALTER AUTHORIZATION ON DATABASE::[AzureDevOps_DefaultCollection] TO [sa];
-- 必要ならアプリ層サービスアカウントを db_owner に付与
USE [AzureDevOps_DefaultCollection];
EXEC sp_addrolemember N'db_owner', N'YOUR\AppTierServiceAccount';
```
そのうえで CLI 直指定で Attach：
```bat
"C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Collection /attach ^
  /collectionDB:localhost;AzureDevOps_DefaultCollection ^
  /sqlInstance:localhost
```

## C) **“クローン/並行環境”の GUID 問題**（ChangeServerId 周り）  
2019 側を丸ごと複製して 2022 側の構成を作っている場合、**PrepareClone / ChangeServerId** の順で GUID を切り替えていないと準備チェックで落ちることがあります。  
- 2022 側のアプリ層で **`TfsConfig PrepareClone` → `TfsConfig ChangeServerId`** を実施済みか確認。  
- 実施済みであれば OK。未実施なら先にこれを済ませてから Attach を再試行。

---

# 追加のハマりどころ（チェックだけ）

- **拡張プロパティ欠落**  
  正常に動く別コレクションDBと比較して、`sys.extended_properties (class=0)` に  
  `TFS_DATABASE_TYPE` / `TFS_PRODUCT_VERSION` があるかを確認。欠けている場合は **OfflineDetach** が最も安全な修復ルートです（手編集は非推奨）。

- **バージョン差**  
  2022 側のビルド/パッチが**ソース（2019/2022）より古い**と準備チェックで落ちます。2022 を可能なら最新パッチへ。

- **レポート/検索の初期化**  
  Attach 成功後、検索/Analytics/SSRS が初期化されるので、Attach 直後は時間がかかることがあります（今回の失敗とは無関係）。

---

# 司令の今の状況に合わせた最短ルート

1. まず **所有者付け替え**（上の SQL）→ **CLI 直 Attach** を試す  
2. 同じエラーで落ちたら、**OfflineDetach ルート**で“アタッチ可能化”してから再実施  
3. それでも落ちたら、**ログの `Error:` 部分**をここに貼って。原因特定用のクエリ（テーブル/プロパティ確認）を即出します

---

必要なら、**OfflineDetach 用の一時 SQL（2019 構成 + コレクションを復元）から 2022 側へ持ってくる**までのワンショット手順を司令のサーバ名に合わせて作ります。言ってください。

送信日時（日本時間）：[[REDACTED_PHONE]]:28 (JST)

### assistant — 2025-09-29T04:28:18.280534+00:00

_(empty)_

### assistant — 2025-09-29T04:28:18.834811+00:00

_(empty)_

### system — 2025-09-29T04:49:36.476811+00:00

_(empty)_

### user — 2025-09-29T04:49:36.699000+00:00

うまくいかない
やはり2019からデタッチ、sqlserverべーすのバックアップの流れがひっすなのか？

### assistant — 2025-09-29T04:49:40.932716+00:00

_(empty)_

### assistant — 2025-09-29T04:50:07.616106+00:00

やあ司令。  
**結論：はい。** 今回のように**コレクション単位で“最新化して移す”**（Move Collection）なら、**2019 での Detach → SQL フルバックアップ → 2022 へ復元 → Attach**が“唯一の安定ルート”です。  
Detach を省くと、**Attach 事前チェック（TF401408 など）で落ちやすい**し、GUIに候補が出ない・内部メタの不整合（InstanceId 等）で弾かれるのが典型です。

---

# なぜ Detach が必須なのか（このケース）
- **Detach 時に**、構成DB側にだけあった**コレクション固有メタ**が**コレクションDBへコピー**され、**別環境でも Attach 可能な“完成形DB”**になります。  
- 司令が試した「DBだけ復元」だと、この**加工が無い**ため**準備チェックで失敗**しがち（実際に失敗）。  
- 並行稼働のために**サーバ丸ごと（構成DBごと）クローン**する“DR手順”なら Detach 省略でも動きますが、**それは“丸ごと復元”の別シナリオ**。**コレクション単独の最新化移行**には適しません。

---

# いま取るべき実行手順（再掲・最短）

1) **2019 管理コンソール**  
   対象コレクションを **Offline → Detach**（この瞬間のDBが“正”）  
2) **SQL**  
   対象コレクションDBの**フルバックアップ**取得  
3) **2022 側 SQL**  
   バックアップを**復元（WITH RECOVERY）**  
4) **2022 アプリ層**  
   GUI で Attach（出ない場合は CLI 直指定）  
   ```bat
   "C:\Program Files\Azure DevOps Server 2022\Tools\TfsConfig.exe" Collection /attach ^
     /collectionDB:SQLHOST\INST;Tfs_Collection_X ^
     /sqlInstance:SQLHOST\INST
   ```
5) **仕上げ**  
   iisreset & Job Agent 再起動、検索/Analytics/SSRS の初期化確認

> ※ どうしても 2019 側で Detach できない事情があるなら、**offlineDetach 代替**が使えますが、**同一時点の `Tfs_Configuration` + コレクションDB を一旦別SQLに復元してから**実行する必要があります（この“同時点ペア”がズレると失敗します）。

---

# 失敗ログ（今回の症状）の理由づけ
- **TF401408（準備チェック失敗）**＝**Detach 未実施**の DB、**所有者/権限の不整合**、**クローンGUID未切替**などでよく出ます。司令の流れだと**Detach 未実施**が本質。  
- `Accounts /ResetOwner` は**構成DB用**のコマンド。**孤立したコレクションDB**には効きません（DB 所有者を変えるなら SQL の `ALTER AUTHORIZATION` を用いる）。

---

必要なら、**対象コレクションごとの停止アナウンス文・チェックリスト（20～30分枠想定）**をまとめます。1本目を確実に通したら、40本分の**一括スクリプト**化もすぐ用意できます。

送信日時（日本時間）：[[REDACTED_PHONE]]:50 (JST)

### assistant — 2025-09-29T04:50:09.472268+00:00

_(empty)_
