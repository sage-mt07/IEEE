---
conversation_id: "6764eecd-6044-8007-b492-e0bda7dcd1e5"
title: "クラス配列 ジャグ配列変換"
create_time: 1734667981.613009
update_time: 1734668063.462726
language_guess: "en"
num_messages: 7
part_index: 1
part_count: 1
---

### system — 2024-12-20T04:13:01.613009+00:00

_(empty)_

### user — 2024-12-20T04:13:01.618936+00:00

Net8前提　クラス配列をジャグ配列変換　最速のコード

### assistant — 2024-12-20T04:13:15.528487+00:00

_(empty)_

### assistant — 2024-12-20T04:13:15.528582+00:00

.NET 8 を前提として、クラスの配列をジャグ配列に変換する場合、最速のコードを目指すためには、効率的なループや LINQ を活用できます。以下はその一例です。

### サンプルコード

```csharp
using System;

public class MyClass
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Program
{
    static void Main()
    {
        // 入力: クラスの配列
        MyClass[] classArray = new MyClass[]
        {
            new MyClass { Id = 1, Name = "Alice" },
            new MyClass { Id = 2, Name = "Bob" },
            new MyClass { Id = 3, Name = "Charlie" }
        };

        // ジャグ配列に変換
        object[][] jaggedArray = new object[classArray.Length][];
        for (int i = 0; i < classArray.Length; i++)
        {
            jaggedArray[i] = new object[] { classArray[i].Id, classArray[i].Name };
        }

        // 結果を確認
        foreach (var row in jaggedArray)
        {
            Console.WriteLine(string.Join(", ", row));
        }
    }
}
```

### 出力

```plaintext
1, Alice
2, Bob
3, Charlie
```

---

### 解説

1. **入力データ**  
   `MyClass` の配列 (`classArray`) を用意しています。

2. **ジャグ配列変換**  
   `object[][]` のジャグ配列に変換しています。各要素は `object[]` 型で、`Id` と `Name` の値を格納しています。

3. **最適化ポイント**
   - **ループの使用**: 素直な `for` ループを使用することでパフォーマンスを確保。
   - **型の汎用性**: ジャグ配列の要素型を `object` にすることで、任意の型に対応可能。

4. **LINQ を使った別解 (可読性重視)**

```csharp
var jaggedArray = classArray
    .Select(c => new object[] { c.Id, c.Name })
    .ToArray();
```

LINQ 版は可読性が高いですが、パフォーマンスが若干劣る場合があります。

---

### ベンチマークが必要な場合

もし実際にどちらが高速かを測りたい場合、`System.Diagnostics.Stopwatch` を使ってパフォーマンスを比較できます。

### user — 2024-12-20T04:14:06.421787+00:00

Span memoryを利用し高速化

### assistant — 2024-12-20T04:14:22.865941+00:00

`Span<T>` を利用してクラス配列をジャグ配列に変換することで、高速化を図るコード例を以下に示します。

`Span<T>` を使うと、不要なアロケーションを減らし、メモリ効率を向上させることが可能です。ただし、ジャグ配列（`object[][]`）自体は配列構造上の制約からヒープを使用します。そのため、変換処理で可能な限りメモリ効率を高めるアプローチを取ります。

---

### コード例

```csharp
using System;

public class MyClass
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Program
{
    static void Main()
    {
        // 入力: クラス配列
        MyClass[] classArray = new MyClass[]
        {
            new MyClass { Id = 1, Name = "Alice" },
            new MyClass { Id = 2, Name = "Bob" },
            new MyClass { Id = 3, Name = "Charlie" }
        };

        // Span を利用してジャグ配列に変換
        var jaggedArray = ConvertToJaggedArray(classArray);

        // 結果の確認
        foreach (var row in jaggedArray)
        {
            Console.WriteLine(string.Join(", ", row));
        }
    }

    static object[][] ConvertToJaggedArray(ReadOnlySpan<MyClass> classSpan)
    {
        // ジャグ配列の初期化
        var result = new object[classSpan.Length][];
        
        for (int i = 0; i < classSpan.Length; i++)
        {
            // 各行をメモリ効率よく生成
            ref readonly MyClass current = ref classSpan[i];
            result[i] = new object[] { current.Id, current.Name };
        }

        return result;
    }
}
```

---

### 解説

1. **入力データを `ReadOnlySpan<T>` に変換**  
   `classSpan` として `ReadOnlySpan<MyClass>` を利用することで、ヒープのアロケーションを減らし、パフォーマンスを向上させています。

2. **ループ内の最適化**  
   `ref readonly` を使用して、直接参照を取得。これにより余分なコピーを防ぎます。

3. **出力形式**  
   結果は `object[][]` のジャグ配列として返します。これは、C# の型システム上、ジャグ配列がヒープに配置されるための制約です。

---

### Span を活用した高速化のポイント

- **配列コピーの削減**  
  `ReadOnlySpan<T>` により、元データのコピーを避けて処理します。
  
- **参照型の最小化**  
  `ref readonly` を使うことで、`MyClass` オブジェクトへの参照を再利用しています。

- **不要なアロケーションを削減**  
  必要最小限の `object[]` アロケーションに抑えています。

---

### 注意点

- **`Span<T>` の制限**  
  `Span<T>` はスタック領域に限定されるため、スタックサイズを超える非常に大きな配列には向いていません。

- **高速化の限界**  
  ジャグ配列（`object[][]`）そのものは構造的にヒープを利用するため、完全なアロケーション削減はできません。

---

このコードは、メモリ効率を意識しつつ、`Span<T>` の利点を活かしてパフォーマンスを向上させた実装です。
