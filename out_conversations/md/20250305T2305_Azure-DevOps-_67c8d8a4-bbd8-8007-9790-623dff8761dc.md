---
conversation_id: "67c8d8a4-bbd8-8007-9790-623dff8761dc"
title: "Azure DevOps テスト管理"
create_time: 1741215908.980119
update_time: 1741216394.181254
language_guess: "en"
num_messages: 12
part_index: 1
part_count: 1
---

### system — 2025-03-05T23:05:08.980119+00:00

_(empty)_

### system — 2025-03-05T23:05:08.980119+00:00

_(empty)_

### user — 2025-03-05T23:05:09.029000+00:00

AzureDevOpsを使用してソースの管理、ドキュメントの管理を行っている。
テストフェーズで必要なツールをリンクで示したい。
リンク先にはテストツールをzip化したファイルがある。
どのような構成なのか？
ツールのバージョン管理もあわせておこないたい。

### assistant — 2025-03-05T23:05:09.042503+00:00

Azure DevOps 上で「テストツール（zipファイル）」をチームメンバーへ共有しつつ、ドキュメントなどからリンクできるようにしたい、さらにツール自体もバージョン管理を行いたい、というケースでは、以下のような構成・運用が考えられます。  

---

## 1. 大まかな全体像

1. **ソースコード管理 (Repos)**
   - メインのソースコードとは別に、テスト用ツールのソースコードまたはビルド済みの成果物を格納・管理するリポジトリを作成する。
   - ソースからビルドしているツールなら、そのビルドの手順をパイプライン化しておくと、常に最新バージョンを自動で用意できる。

2. **ドキュメント管理 (Wiki やドキュメントリポジトリ)**
   - 「テスト実行手順書」「使用ツール一覧」などのドキュメント内で、該当するツールのダウンロードリンクを提示する。
   - Azure DevOps Wiki からリンクする、またはドキュメント(READMEなど)内にリンクを貼る。

3. **バージョン管理の実施**
   - もしツールが比較的大きい（数MB以上）のであれば、Git LFS や Azure Artifacts のような外部パッケージ管理機構を利用し、サイズ面や履歴の管理を最適化する。
   - あるいはビルド済みアーティファクトを「Releases (リリース)」機能で管理し、タグ・バージョンを付与してリリースノートと共にツールをアップロードしておく。
   - いずれの方法でも、各バージョンに対して「どんな機能追加やバグ修正をしたか」というドキュメントを残しておくと、チーム全体での活用がスムーズになる。

---

## 2. 構成パターン例

### パターンA: 別リポジトリでバイナリ (zip) を管理して、Wiki や README からリンク

1. **`TestTools` リポジトリを用意**  
   - テストツール単体のためのリポジトリを作る。バージョンごとにタグをつける。
   - 必要であれば Git LFS を使って大きいファイルを管理する。
   - 例: `TestTools` リポジトリ直下に `tools/ToolName_X_X_X.zip` のようにバージョン別に配置。

2. **リリース単位で zip を追加/更新**
   - 新しいバージョンを登録する際は `release/v1.0.1` などのタグ（ブランチ）を切り、そこにビルド済みのzipを格納。
   - リポジトリの “Releases” 機能を使って zip ファイルを添付してもよい（GitHub と同様、Azure Repos でもリリース機能を活用可能）。
   - こうすることで、過去バージョンを遡ってダウンロードできるようになる。

3. **Wiki、またはメインリポジトリのREADMEからリンク**  
   - ダウンロード先URLの書き方:  
     - 例）`https://dev.azure.com/{組織名}/{プロジェクト名}/_git/TestTools?path=/tools/ToolName_1_0_0.zip`  
   - あるいはリリース機能で公開した場合は、各リリースページへのリンクを案内する。

#### ポイント
- バイナリファイルを直接バージョン管理したい場合は Git LFS や Azure Artifacts の利用を検討（通常の Git だと履歴が肥大化しやすいため）。
- リリース運用にした方が「ツールにタグ・バージョンを割り振る」運用がわかりやすい。

---

### パターンB: ビルドパイプライン + Artifacts で管理する

テストツールが “ソースからビルドして生成する” ケースや、サードパーティ製の実行ファイルをまとめて管理したいときにおすすめです。

1. **ソース管理**  
   - テストツールのソースを Repos や別のリポジトリに格納する。
   - Azure Pipelines でビルドする定義ファイル (`azure-pipelines.yml`) も同じリポジトリに置く。

2. **ビルドとアーティファクト化**  
   - パイプラインが走ったら、ビルド成果物（実行ファイルやzipなど）を **Azure Pipelines の “Artifacts”** として出力する。
   - Artifacts に成果物を保存することで、各実行ビルドごとに自動でバージョン管理される(ビルド番号やリリース番号などを付与できる)。

3. **Artifacts へのリンク**  
   - ビルド結果ページにArtifactsが出てくるので、必要なダウンロードURLをコピーし、Wikiやドキュメントに貼り付ける。
   - これにより、テスト実行者は任意のビルド版のツールをダウンロードできる。

4. **リリース（リリースパイプライン）運用**  
   - ビルド後、自動または手動承認ステップを経て「正式リリース」としてリリースパイプラインを実行し、成果物を最終的に “(テストチーム向け) 公開” する流れを作れる。
   - 過去のリリース版にも簡単に遡れるため、古いバージョンにロールバックしたいときも対応しやすい。

#### ポイント
- **Azure Artifacts** に登録する際、`universal package` として管理するとバージョン付けがしやすい。
- パイプラインで自動ビルド & テスト & リリース という形にすれば、ツールの更新から配置までが一貫して自動化できる。

---

## 3. 実際にリンクを示す例

Wiki や README.md 内で示すリンクの書き方は Azure DevOps の “Project name / Repo name / パス / バージョン指定” といった形になります。  
例えばリポジトリ内にファイルを直接置いている場合:

```
[テストツール v1.0.0 ダウンロード](https://dev.azure.com/<組織名>/<プロジェクト名>/_git/TestTools?path=/releases/Tool_v1.0.0.zip)
```

リリース機能や Artifacts を使う場合は、対象の成果物を公開しているページURLがあるので、それを貼り付けます(発行方法によってURLが変わるので、都度確認する必要があります)。

---

## 4. 運用上のヒント

1. **サイズの大きなファイルは Git LFS や Artifacts を使う**  
   - 通常の Git 管理だけでは履歴肥大化が発生しやすいです。  
   - Git LFS はバイナリだけ外部ストレージに置き、Git の履歴を圧迫しないようにできます。  
   - さらに多人数で共有するなら、Azure Artifacts にアップロードして管理すると、バージョン番号ごとに簡単に取り出し・再利用ができます。

2. **ドキュメントとツールのバージョンを明示的に紐づける**  
   - 例）テスト実行手順書（バージョン1.2）には、ツール X (バージョン 2.0) を使用することと明示したり、リリースノートで「ツール X が 2.1 にアップデートされました」と記載する。

3. **Azure DevOps の “Artifacts Feeds (NuGet 以外も可)” を活用する**  
   - `nuget`, `npm`, `maven`, `universal package`など、様々なタイプのパッケージを保持できます。
   - Universal Package として zip や exe なども登録できるので、ツール単体のバージョン管理に向いています。

4. **テスト自動化も考慮するならパイプライン連携が便利**  
   - テストフェーズで使うツールを、Azure DevOps Pipelines 上で毎回ビルド～テストを行う段階でダウンロードして使うワークフローにしておくと、“新バージョンに差し替わったら自動でテストも走る” といったモダンな連携が可能です。

---

## まとめ

- **ツール自体をどう管理するか:**  
  1. 別リポジトリでバイナリファイル(zip)を直接バージョン管理し、Wiki や README からリンクする。  
  2. ビルドパイプラインを組み、成果物を Azure Artifacts や “Releases” で管理する。  

- **ドキュメント (Wiki / Markdown) との紐づけ:**  
  - ツールのダウンロードリンクを文書内に記載。
  - テスト手順書とツールバージョンを明示的に管理。

- **ポイントは履歴の肥大化を防ぎつつ、多人数がスムーズに利用できるようにすること。**  
  そのため、ファイルサイズが大きい／更新頻度が高い場合は Git LFS や Artifacts を活用した方が安定的です。  
  必要に応じてリリースタグを管理したり、リリースノートをつけたりすることでツールの変更内容を明示しながら進められます。

### tool — 2025-03-05T23:05:09.354938+00:00

**管理の方法を検討中**

Azure DevOpsでツールのバージョン管理とドラフトを行う方法を探っている。ツールの遅延をリポジトリやリリースで管理するのが効率的だと考えている。

**リモートリポジトリの活用**

Zipファイルやツールのバージョン管理を、Azure DevOpsリポジトリやパッケージフィード、またはアーティファクトを使って管理する方法を模索中。

### assistant — 2025-03-05T23:06:14.259540+00:00

Azure Artifacts には “Universal Packages” と呼ばれる機能があり、任意のファイルをまとめた zip 等をパッケージとしてアップロード・バージョン管理できます。ツールやバイナリを Azure Artifacts に格納し、プロジェクトメンバーがいつでも必要なバージョンをダウンロードできるようにするのは、非常に有効な方法のひとつです。以下に大まかな使い方やメリット・注意点をまとめます。

---

## 1. 概要: Universal Packages での zipファイル管理

1. **Artifacts (Universal Packages) を作成**
   - Azure DevOps の「Artifacts」タブから、“Universal feed” を作成する。
   - ここで “universal package” をアップロード・管理できるようになる。

2. **ツールを zip 形式で固める**
   - “TestTool_x.y.z.zip” のように、バージョン番号を付与する形でファイル名をつける。
   - Universal Packages では、複数のファイルをフォルダ構造ごとまとめて “1つのパッケージ” として登録することが可能ですが、既に zip 化しておくと管理や利用が分かりやすい場合が多いです。

3. **Azure Pipelines からのアップロード（推奨）**
   - ビルドやテスト後に“Publish Universal Package” タスクを使って自動でArtifactsへアップロードできる。
   - あるいは、ローカルPCのCLIから `az artifacts universal publish` や `azure devops` CLI コマンドで手動アップロードすることもできる。
   - バージョン番号を指定することで、同一パッケージ名でも差し替えがしやすく、過去バージョンも保持できる。

4. **他メンバーがダウンロード（使用）**
   - CLI でダウンロードしたり、パイプラインやリリースパイプラインで“Download Universal Package”を使ったりして取得する。
   - あるいはArtifactsのWeb UIから直接ダウンロードも可能。

5. **Wiki／ドキュメントからリンク**
   - Universal Packages単体の“直接ダウンロードURL”は取得しづらいため、**Artifacts のパッケージページへのリンク**を貼る方法が一般的。
   - クリックだけで自動DLできる直リンクにこだわる場合は、外部公開の設定などを別途する必要があるため、基本的にはArtifactsページのURLを案内するか、CLIの使い方を案内する形が多いです。

---

## 2. メリット

1. **バージョン単位での管理が容易**  
   - Universal Packages はバージョンを明確に付けられ、最新／過去のバージョンへ容易にアクセス可能。
   - アーカイブとして残したいファイルセットを一括管理できる。

2. **履歴の肥大化を抑制**  
   - Git にバイナリをそのまま含めるより、Gitリポジトリのサイズを肥大化させずに済む。
   - 大容量ファイルの管理には Git LFS などもあるが、Azure Artifacts (Universal Packages) はさらに組織的にパッケージ管理しやすいメリットがある。

3. **パイプラインとの親和性**  
   - Azure Pipelines のタスクで簡単にアップロード・ダウンロードができ、ビルド→テスト→リリースの自動化フローに組み込みやすい。
   - ツール更新の都度、最新版を自動でアップロードし、古いバージョンへロールバックするときにもArtifacts上で選択するだけでよい。

4. **アクセス制限やライフサイクル管理**  
   - Azure DevOps のセキュリティ設定で特定グループにのみダウンロード権限を与える等の制御が可能。
   - 不要になったバージョンは“Retain”／“Delete”などで管理できる。

---

## 3. 注意点・運用のポイント

1. **直リンクダウンロードの運用**  
   - Universal Packagesは、GitHub Releases のようにワンクリックで簡単にファイルをダウンロードするURLが提供されるわけではない（2025年現在）。  
   - チームメンバーには「Azure DevOpsのArtifactsページから取得」または「CLIコマンドで取得」という手順を案内するのが一般的。

2. **ディスク容量のモニタリング**  
   - パッケージ数・バージョン数が増えるほど、利用可能なストレージを消費していく。Azure DevOpsの課金プランによっては上限に注意が必要。

3. **外部ユーザーへの配布**  
   - 組織外のユーザーにも渡す必要がある場合、Azure DevOpsへのアクセス権がない人にはこの方法は使いづらい。  
   - 外部公開が必要な場合は別途ダウンロード用サーバーやSaaS（Azure Storage + SASリンクなど）を用意するケースもある。

4. **ツールへのタグや説明付加**  
   - Universal Packages は名前とバージョン以外に、簡易的な説明を設定できるが、詳しい更新履歴などはリリースノートやWikiで補足すると良い。  
   - ドキュメントやWikiに「v1.2.0のリリース内容」などをまとめておくと、どのバージョンを使えば良いか迷いにくい。

---

## 4. 運用フロー例

1. **テストツールの更新**  
   - ローカルで新バージョンを作成 → zipを作成 → バージョンを `1.2.0` とする。

2. **Azure Pipelines でビルド→Artifacts登録**  
   - 手動 or 自動トリガーで、パイプラインを走らせて “Publish Universal Package” タスクでアップロード。  
   - 成功したら Azure Artifacts の “Universal feed” に `TestTool@1.2.0` のような形で格納される。

3. **ドキュメント更新**  
   - Wiki や README に「テストツール v1.2.0 がリリースされました。更新点は～～です。ダウンロードはArtifactsページのこちら → (URLリンク)」と記載する。

4. **テストメンバーが取得して利用**  
   - Azure DevOpsポータルのArtifactsページか、CLI (`az artifacts universal download --organization <...> --feed <...> --name TestTool --version 1.2.0`) から取得。
   - 既にパイプラインに組み込んであれば、テスト実行フェーズ時に自動で最新を取得して展開する設定も可能。

5. **不要バージョンのクリーンアップ**  
   - アーティファクトが増えてきたら、もう使わないバージョンをArtifacts上で削除、あるいはRetentionポリシーを設定して定期削除する。

---

## まとめ

- **Artifacts へ zipファイルを登録する方式**は、Azure DevOpsの機能をフル活用でき、ツールのバージョン管理やドキュメント連携がしやすい手法です。  
- 特に Universal Packages は任意ファイルをバージョン付きで管理できるため、テストツールやツールの依存ファイルセットを丸ごと一括管理したい場合に最適です。  
- 注意点は「直リンクの配布がしにくい」点や「外部ユーザー配布には向かない」点ですが、組織内利用であればアップロード・ダウンロードともに簡単で、履歴管理とパイプライン連携のメリットが大きいでしょう。

### user — 2025-03-05T23:06:14.430000+00:00

Artifactsへzipファイルを登録する方式はどうか

### tool — 2025-03-05T23:06:14.686182+00:00

**アップロードと管理**

Azure Artifactsでzipファイルをアップロードし、wikiやdocsからリンクを貼る方法を説明している。

### user — 2025-03-05T23:12:42.018000+00:00

パッケージ配布先として利用しているが、分けるべきか

### assistant — 2025-03-05T23:12:42.018958+00:00

「Azure Artifacts」を既にパッケージ配布先として利用していて、そこにテスト用ツール（zip等）も同居させるべきか、別途分けるべきか—という点については、**プロジェクト内での利用状況・管理ポリシー・セキュリティ要件**などによって判断が分かれます。以下では、同じFeedにまとめる場合と、分ける場合のメリット・デメリットを整理しますので、参考にしてみてください。

---

## 1. 同じArtifacts Feedにまとめる場合

### メリット
1. **管理対象が少なくシンプル**  
   - フィードが1つだけだと、URLや権限設定が一元化され、アクセスする側もシンプル。
2. **初期導入コストが低い**  
   - 既存のArtifacts Feedをそのまま利用できるため、新規にフィードを作成・設定する手間がない。
3. **チームの認証・権限設定が既に整っている**  
   - 同じチーム内で運用しているなら、追加の権限設定が最小限ですむ。

### デメリット
1. **パッケージが増えてFeedが煩雑になる**  
   - アプリやライブラリなど、他の目的のパッケージと混在してしまうと、検索や一覧性が低下する可能性がある。
2. **アクセス権を細かく分けにくい**  
   - もしテストツールだけ特定のグループに制限したい場合、同じFeed内で権限分割できるが、若干ややこしくなりがち。
3. **ライフサイクルが異なるパッケージと混在**  
   - “本番配布パッケージ” と “テストツール” では更新ペースや保管の長期性が違う場合があり、一括管理だと不要データが溜まりやすい。

---

## 2. 別々のArtifacts Feedを用意する場合

### メリット
1. **目的・用途ごとに整理される**  
   - 「プロダクトの配布パッケージ」「テスト専用ツール」など、役割が異なるものを分けることで混乱しにくい。
2. **権限・ライフサイクル管理を分離できる**  
   - たとえば、テストツールは全員が自由にアップロードできるが、本番パッケージは限られたメンテナしかアップロードできない、等のルールを分けやすい。
3. **不要パッケージのクリーンアップがしやすい**  
   - テストツール用Feedは古いバージョンをこまめに削除するといった運用がしやすい。  
   - 逆に本番配布パッケージは長期保持するなど運用ポリシーが別の場合にも便利。

### デメリット
1. **管理対象が増える**  
   - フィードが複数に分かれるため、管理者はそれぞれのFeedの設定やメンテナンスを行う手間が増える。
2. **ユーザー側の導線が複雑になる可能性**  
   - 同じチーム内で複数のFeedを扱う場合、「どのFeedに何があるか」を把握してもらう必要がある。
3. **初期設定の手間**  
   - 新しいFeedを作る際の命名規則・アクセス権限・ポリシー設定などを検討・実装するコスト。

---

## 3. 判断のポイント

1. **パッケージの利用者や配布先が明確に異なるか？**  
   - たとえば本番用ライブラリや製品リリース向けアーティファクトと、テストチームだけが使うツールが混在すると混乱する場合、分けるメリットが大きいです。
2. **更新頻度やライフサイクルに大きな差があるか？**  
   - テストツールはバージョン更新が頻繁かつ短期間だけ保持すれば良いが、本番パッケージは長期保持が必要で、変更が少ない、など大きく性質が違う場合は分けるほうがスッキリします。
3. **アクセス制御が異なるか？**  
   - たとえば「このテストツールは限られたQAチームが編集して使うだけ、一方で製品のパッケージは社内外の開発者が参照」といったケースでは、Feedを分けて権限設定を独立させたほうが安全です。
4. **すでにFeedが肥大化してきているか？**  
   - 1つのFeed内に数十～数百のパッケージやバージョンが積み上がり、必要なものを探しにくいなら、フェーズごと・用途ごとに分けると管理しやすくなります。

---

## 4. まとめ・おすすめ方針

- **同じFeedで十分対応できるなら、そのまま運用するのが手軽**  
  - ただし、テストツールが少数で更新頻度も低いといった場合に限りメリットが大きい。
- **利用対象・更新頻度・ライフサイクル・アクセス制御が異なるなら、別Feedを作ったほうが混乱が少ない**  
  - 特に「QA専用」「製品リリース用」など、用途が大きく違うなら分けたほうが権限管理や運用ポリシーを独立できるため、結果的にシンプルになることが多い。

最終的には、**運用のしやすさとセキュリティ要件**、そして**現在のArtifacts Feedの規模**が判断材料となります。すでに大きくなっているFeedにテスト用zipまで混在させると、今後さらに肥大化したり探しにくくなるリスクもあります。どちらにせよ、Azure Artifactsではフィードを簡単に増やせますので、**「用途ごとの分離は早めに検討しておく」** ほうが長期的には楽になるケースが多いです。

### tool — 2025-03-05T23:12:42.507657+00:00

**分離の検討**

テストツールを既存のAzure Artifactsに追加する場合、セキュリティやチーム間の明確な区分け、サイズ使用量、ライセンス、コンプライアンスの要件を考慮して、専用のフィードを設ける必要があるか検討中。

**パートの比較を行う**

テストツールを主フィードから分けることで混乱を避け、見つけやすくし、フィードの成長をコントロールすることが可能になる。
