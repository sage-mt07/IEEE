---
conversation_id: "676a3651-510c-8007-9be8-ecb693daa71b"
title: "Web API パラメータ形式"
create_time: 1735013969.641974
update_time: 1735014140.940126
language_guess: "en"
num_messages: 9
part_index: 1
part_count: 1
---

### system — 2024-12-24T04:19:29.641974+00:00

_(empty)_

### user — 2024-12-24T04:19:29.657050+00:00

Net8でwebapiを作成　パラメータをjson形式、通常のkey value 形式とする
いずれかの形式はパスで判断する

### assistant — 2024-12-24T04:20:00.332751+00:00

_(empty)_

### assistant — 2024-12-24T04:20:00.332880+00:00

.NET 8 で Web API を作成し、リクエストのパラメータを JSON 形式または通常の key-value 形式で受け取る場合、リクエストのパスを使って形式を判断する方法を以下の手順で説明します。

### 1. **コントローラを作成**
以下の例では、`/api/json` では JSON 形式、`/api/keyvalue` では key-value 形式のリクエストを受け付けるエンドポイントを用意します。

```csharp
[ApiController]
[Route("api")]
public class MyController : ControllerBase
{
    // JSON形式を受け付けるエンドポイント
    [HttpPost("json")]
    public IActionResult PostJson([FromBody] MyRequestDto request)
    {
        if (request == null)
        {
            return BadRequest("Invalid JSON format.");
        }
        return Ok(new { message = "JSON received", data = request });
    }

    // key-value形式を受け付けるエンドポイント
    [HttpPost("keyvalue")]
    public IActionResult PostKeyValue([FromForm] MyRequestDto request)
    {
        if (request == null)
        {
            return BadRequest("Invalid key-value format.");
        }
        return Ok(new { message = "Key-value data received", data = request });
    }
}

// リクエストデータ用のDTOクラス
public class MyRequestDto
{
    public string Key1 { get; set; }
    public string Key2 { get; set; }
}
```

### 2. **リクエストのハンドリング**
- `PostJson` メソッドは `application/json` 形式のリクエストボディを期待し、`[FromBody]` 属性でモデルをバインドします。
- `PostKeyValue` メソッドは `application/x-www-form-urlencoded` 形式のリクエストを期待し、`[FromForm]` 属性でモデルをバインドします。

### 3. **リクエスト例**
#### JSON形式リクエスト
- URL: `https://example.com/api/json`
- ヘッダー: `Content-Type: application/json`
- ボディ:
  ```json
  {
      "Key1": "Value1",
      "Key2": "Value2"
  }
  ```

#### Key-Value形式リクエスト
- URL: `https://example.com/api/keyvalue`
- ヘッダー: `Content-Type: application/x-www-form-urlencoded`
- ボディ:
  ```
  Key1=Value1&Key2=Value2
  ```

### 4. **実行結果**
適切な形式でリクエストを送信すると、`200 OK` とともにリクエストデータがレスポンスとして返されます。

### 5. **注意点**
- クライアントが適切なリクエスト形式を送信するよう、API の仕様を明確にドキュメント化してください。
- 必要に応じて入力検証（Validation）を追加し、不正なデータやフォーマットを防ぐようにします。

### 6. **拡張案**
- 複雑なルーティングを避けたい場合、単一のエンドポイントでリクエストヘッダーやクエリパラメータを使って形式を判断する方法も検討できます。

### user — 2024-12-24T04:20:19.541404+00:00

コードはなるべく統一する

### assistant — 2024-12-24T04:21:07.392818+00:00

コードを統一し、パスでフォーマットを判別しつつ、できるだけシンプルで再利用可能な形に改善した例を示します。以下では、**1つのエンドポイント**でリクエストの形式を判断する実装を示します。

---

### **コード例**

```csharp
[ApiController]
[Route("api")]
public class UnifiedController : ControllerBase
{
    [HttpPost("{format}")]
    public IActionResult PostData([FromRoute] string format)
    {
        MyRequestDto? request = null;

        switch (format.ToLower())
        {
            case "json":
                request = ParseJson(Request);
                break;

            case "keyvalue":
                request = ParseKeyValue(Request);
                break;

            default:
                return BadRequest($"Unsupported format: {format}");
        }

        if (request == null)
        {
            return BadRequest("Invalid request data.");
        }

        return Ok(new
        {
            message = $"{format.ToUpper()} data received",
            data = request
        });
    }

    // JSON形式のデータを解析
    private MyRequestDto? ParseJson(HttpRequest request)
    {
        try
        {
            using var reader = new StreamReader(request.Body);
            var body = reader.ReadToEndAsync().Result;
            return System.Text.Json.JsonSerializer.Deserialize<MyRequestDto>(body);
        }
        catch
        {
            return null;
        }
    }

    // Key-Value形式のデータを解析
    private MyRequestDto? ParseKeyValue(HttpRequest request)
    {
        try
        {
            var form = request.Form;
            return new MyRequestDto
            {
                Key1 = form["Key1"],
                Key2 = form["Key2"]
            };
        }
        catch
        {
            return null;
        }
    }
}

// リクエストデータ用のDTOクラス
public class MyRequestDto
{
    public string? Key1 { get; set; }
    public string? Key2 { get; set; }
}
```

---

### **ポイント**
1. **1つのエンドポイントで形式を判別**  
   `/api/{format}` の形式でパスを利用して、リクエストのフォーマット（`json` または `keyvalue`）を判別します。

2. **リクエスト形式ごとに処理を分岐**  
   - `json`: リクエストボディを JSON として解析します。
   - `keyvalue`: `application/x-www-form-urlencoded` として解析します。

3. **解析処理の統一**
   各形式の解析処理を専用のメソッド（`ParseJson` と `ParseKeyValue`）に分離しました。

---

### **リクエスト例**
#### JSON形式リクエスト
- **URL**: `https://example.com/api/json`
- **ヘッダー**: `Content-Type: application/json`
- **ボディ**:
  ```json
  {
      "Key1": "Value1",
      "Key2": "Value2"
  }
  ```

#### Key-Value形式リクエスト
- **URL**: `https://example.com/api/keyvalue`
- **ヘッダー**: `Content-Type: application/x-www-form-urlencoded`
- **ボディ**:
  ```
  Key1=Value1&Key2=Value2
  ```

---

### **統一されたコードでの利点**
- **再利用性**  
  新しいフォーマットが必要になった場合でも、`switch` にケースを追加するだけで対応可能です。
- **メンテナンス性**  
  リクエスト処理を統一し、形式ごとに独立した処理を分離しているため、コードの見通しが良くなります。
- **APIのシンプルさ**  
  エンドポイントを1つに統一しているため、クライアント側で使いやすい設計です。

---

### **拡張案**
- 入力データの検証（Validation）を追加して、不正なデータを早期に検出する。
- エラーメッセージやレスポンスの標準化を行う。

### user — 2024-12-24T04:21:39.882333+00:00

Swagger uiに表示

### assistant — 2024-12-24T04:22:20.464346+00:00

Swagger UI に対応するように上記コードを変更するには、`Swashbuckle.AspNetCore` を利用して API ドキュメントを生成します。リクエスト形式を統一し、エンドポイントが柔軟に対応できるようにするには、`SwaggerRequestExample` やカスタムフィルターを利用する方法が有効です。

以下に、Swagger UI に表示できる統合例を示します。

---

### **コード例**

#### **1. `UnifiedController`の変更**

```csharp
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api")]
public class UnifiedController : ControllerBase
{
    /// <summary>
    /// データを送信します。
    /// パスでフォーマットを指定します。
    /// </summary>
    /// <param name="format">json または keyvalue を指定してください。</param>
    /// <param name="jsonBody">JSON形式のデータ</param>
    /// <param name="keyValueBody">Key-Value形式のデータ</param>
    /// <returns>受け取ったデータを返します。</returns>
    [HttpPost("{format}")]
    public IActionResult PostData(
        [FromRoute] string format,
        [FromBody] MyRequestDto? jsonBody,
        [FromForm] MyRequestDto? keyValueBody)
    {
        MyRequestDto? request = format.ToLower() switch
        {
            "json" => jsonBody,
            "keyvalue" => keyValueBody,
            _ => null
        };

        if (request == null)
        {
            return BadRequest($"Invalid format or missing data for format: {format}");
        }

        return Ok(new
        {
            message = $"{format.ToUpper()} data received",
            data = request
        });
    }
}

// リクエストデータ用のDTOクラス
public class MyRequestDto
{
    /// <summary>
    /// 最初のキー
    /// </summary>
    public string? Key1 { get; set; }

    /// <summary>
    /// 2番目のキー
    /// </summary>
    public string? Key2 { get; set; }
}
```

---

#### **2. `Program.cs` の設定**

```csharp
using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

// Swaggerの設定
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "Unified API Example",
        Version = "v1",
        Description = "JSONまたはKey-Value形式でデータを送信できるAPI"
    });
});

var app = builder.Build();

// Swagger UI を有効化
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/swagger/v1/swagger.json", "Unified API Example V1");
    });
}

app.MapControllers();
app.Run();
```

---

#### **3. Swagger UI の表示**
上記の設定で Swagger UI を有効にすると、アプリケーションを実行して以下の URL にアクセスすることで API ドキュメントが表示されます。

```
https://localhost:<port>/swagger/index.html
```

---

### **Swagger UI のリクエスト例**

#### **JSON形式**
- **パス**: `/api/json`
- **Request Body**:
  ```json
  {
      "Key1": "Value1",
      "Key2": "Value2"
  }
  ```

#### **Key-Value形式**
- **パス**: `/api/keyvalue`
- **Request Body**:
  ```
  Key1=Value1&Key2=Value2
  ```

---

### **ポイント**
1. **Swaggerドキュメントの生成**
   `SwaggerGen` を使ってエンドポイントやパラメータの説明を追加し、API 利用者が各リクエスト形式を理解しやすくしました。

2. **ルートでフォーマットを指定**
   `format` のルートパラメータ（`json` または `keyvalue`）に基づいて、適切なリクエスト形式を受け取れるようにしています。

3. **リクエスト形式の切り替え**
   `FromBody` と `FromForm` を使って、JSON と key-value の両方をサポートするように実装しました。

---

### **Swagger の表示例**
Swagger UI には以下のようにエンドポイントが表示され、各フォーマットに対応したリクエストボディのサンプルが確認できます。

- `/api/{format}`  
   - `format`: json または keyvalue を指定。
   - JSON と Key-Value のリクエスト例を確認可能。

これにより、クライアント側でも柔軟に API を利用できるようになります。
