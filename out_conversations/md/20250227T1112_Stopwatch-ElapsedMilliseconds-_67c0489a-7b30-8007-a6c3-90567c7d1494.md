---
conversation_id: "67c0489a-7b30-8007-a6c3-90567c7d1494"
title: "Stopwatch ElapsedMilliseconds マイナス"
create_time: 1740654746.77983
update_time: 1740655190.224317
language_guess: "en"
num_messages: 7
part_index: 1
part_count: 1
---

### system — 2025-02-27T11:12:26.779830+00:00

_(empty)_

### user — 2025-02-27T11:12:26.783088+00:00

C#のStopwatchのElapsedMillisecondsがマイナスを示すことがあるのか

### assistant — 2025-02-27T11:12:26.862201+00:00

C# の `Stopwatch.ElapsedMilliseconds` が **マイナスの値を示すことは通常ありません**。しかし、以下のような場合に異常な値が発生する可能性があります。

### 1. **時間の巻き戻り**
`Stopwatch` は `QueryPerformanceCounter` (QPC) を使用するため、システムクロックの変更による影響は受けませんが、以下のようなケースでは異常が発生する可能性があります。

- **ハードウェアの不具合**  
  一部の CPU やマザーボードでは、QPC のタイマーが異常な挙動を示すことがあります。
- **仮想環境の影響**  
  一部の仮想マシン環境では、QPC が突然巻き戻るケースがあります。

### 2. **整数オーバーフロー**
- `Stopwatch.ElapsedMilliseconds` は `long` 型なので、通常の範囲ではオーバーフローしません。
- ただし、**`Stopwatch.ElapsedTicks` を int にキャストして計算する**とオーバーフローする可能性があります。

```csharp
Stopwatch sw = Stopwatch.StartNew();
Thread.Sleep(1000);
int elapsed = (int)sw.ElapsedMilliseconds; // long を int にキャスト → オーバーフローの可能性
Console.WriteLine(elapsed); // 予期しない値が出ることがある
```

### 3. **`Stopwatch.Restart()` を使用した場合**
- `Stopwatch.Restart()` を呼び出すと、内部的には `Stopwatch.Reset()` → `Stopwatch.Start()` の処理が行われます。
- その間に `ElapsedMilliseconds` を取得すると、異常な値が取得される可能性があります。

```csharp
Stopwatch sw = Stopwatch.StartNew();
Thread.Sleep(1000);
sw.Restart();  // ここでリセットされる
long elapsed = sw.ElapsedMilliseconds; // ほぼゼロになるはずだが、タイミング次第で異常な値を取る可能性
Console.WriteLine(elapsed);
```

### 4. **並行処理（マルチスレッド）**
- `Stopwatch` はスレッドセーフですが、異なるスレッドから `Restart()` を呼び出し、同時に `ElapsedMilliseconds` を取得すると、**期待しない結果**になることがあります。

```csharp
Stopwatch sw = Stopwatch.StartNew();

Task.Run(() =>
{
    sw.Restart();
});

Thread.Sleep(500);
Console.WriteLine(sw.ElapsedMilliseconds); // 予期しない値が出る可能性
```

---

## **対策**
1. **`ElapsedMilliseconds` を直接 int にキャストしない** (`long` のまま使う)  
2. **`Restart()` を頻繁に呼び出さない**（代わりに `Reset()` → `Start()` を個別に呼び出す）  
3. **並行処理で `Stopwatch` を共有しない**（スレッドごとに `Stopwatch` を作成する）  
4. **仮想環境やハードウェアの影響を考慮する**（異常が起こる場合は `DateTime.UtcNow.Ticks` の併用を検討）

これらの点をチェックしても問題が解決しない場合、**ハードウェアやOSのバグ**の可能性も考えられます。

### assistant — 2025-02-27T11:12:38.811825+00:00

_(empty)_

### user — 2025-02-27T11:19:21.229279+00:00

キャストした結果`ｰ3000になる場合の本当の値は

### assistant — 2025-02-27T11:19:21.315261+00:00

C# で `Stopwatch.ElapsedMilliseconds` の値を `int` にキャストした結果 `-3000` になる場合、本来の `long` の値は **符号なしの `uint` にキャストされた後のオーバーフロー** を考慮する必要があります。

## **符号付き `int` のオーバーフローについて**
C# の `int` (32-bit) は `-2,147,483,648` ～ `2,147,483,647` の範囲しか扱えません。  
`long` (64-bit) から `int` (32-bit) へキャストする場合、上位 32-bit は切り捨てられます。

このとき、**オーバーフローが発生すると `int` の範囲内に収まる値として解釈される** ため、本来の値を求めるには以下のような計算が必要です。

## **本来の値の推定**
C# の数値キャストは **下位 32-bit のみが残る** ので、元の `long` の値は以下の式で求められます：

\[
\text{元の値} = \text{キャスト後の値} + 2^{32} \times N
\]

ここで、`N` は `キャスト前の値` が `int` の範囲を超えていた回数（符号なしの `uint` を `int` に解釈した回数）。

### **例: `-3000` になった場合**
1. `int` の値が `-3000` (`0xFFFFF448` となる)
2. `uint` に変換すると `0xFFFFF448 = [[REDACTED_PHONE]]`
3. `long` の本来の値は `[[REDACTED_PHONE]]` か、それ以上（`2^32 = [[REDACTED_PHONE]]` を足す単位）

つまり、考えられる `long` の本来の値は：
```
[[REDACTED_PHONE]] + [[REDACTED_PHONE]] = [[REDACTED_PHONE]] + [[REDACTED_PHONE]] = [[REDACTED_PHONE]]
...
```

**結論:**
`Stopwatch.ElapsedMilliseconds` の値が `-3000` になる場合、**本来の値は `[[REDACTED_PHONE]]` + `N × [[REDACTED_PHONE]]`** のような値になっているはずです。

## **修正方法**
長時間 `Stopwatch` を動かす場合、`ElapsedMilliseconds` を `int` にキャストせず **`long` のまま扱う** のが安全です。

```csharp
Stopwatch sw = Stopwatch.StartNew();
Thread.Sleep(1000);
long elapsed = sw.ElapsedMilliseconds;  // int にキャストしない
Console.WriteLine(elapsed);
```

もし `int` を使いたい場合は、オーバーフローを考慮するため `checked` を使うか、適切な範囲で `mod` を取るのも手です。

```csharp
int elapsedSafe = (int)(sw.ElapsedMilliseconds % int.MaxValue);
```

こうすれば、オーバーフローの影響を避けられます。
