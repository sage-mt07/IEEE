---
conversation_id: "6877531f-203c-8007-85f7-d19703c3514e"
title: "DIでの抽象クラス選定"
create_time: 1752650527.444486
update_time: 1752650789.729699
language_guess: "en"
num_messages: 10
part_index: 1
part_count: 1
---

### system — 2025-07-16T07:22:07.444486+00:00

_(empty)_

### user — 2025-07-16T07:22:07.444486+00:00

_(empty)_

### user — 2025-07-16T07:22:07.448674+00:00

最近diでc#のコードを書くことが多いためinterface よりもabstract classの利用がいいち考えてる

### assistant — 2025-07-16T07:22:07.640728+00:00

🕘【2025年7月16日 15:29 JST】

やあ、いらっしゃい！DI（依存性注入）環境で `interface` よりも `abstract class` を選ぶべきかという判断、現場の事情や設計思想によって変わるけれど、以下の視点で整理できます。

---

## ✅ Abstract class を使うと良いケース

### 1. **共通ロジックを提供したい**
抽象クラスはメソッドの一部を実装できるため、共通の振る舞い（例：ログ出力、バリデーションなど）を提供したい場合に便利。

```csharp
public abstract class RepositoryBase<T> {
    public void Log(string msg) => Console.WriteLine(msg);
    public abstract T GetById(int id);
}
```

### 2. **将来的な拡張に備えてバージョン管理しやすい**
interface を変更すると呼び出し元すべてに影響するが、abstract class に新しい virtual メソッドを追加することで既存実装への影響を抑えやすい。

### 3. **DIコンテナで base class の注入が容易**
多くのDIフレームワーク（Microsoft.Extensions.DependencyInjection含む）で、base class をそのまま `ServiceCollection` に登録して使える。

---

## ❌ abstract class の注意点（interface に優位性がある部分）

### 1. **多重継承不可**
C#はクラスの多重継承ができないので、base class を1つに絞る必要がある（インターフェースなら複数実装可能）。

### 2. **ユニットテストの柔軟性がやや劣る**
抽象クラスは内部状態や実装が含まれるため、モックしづらいことがある（interfaceのほうが Moq や NSubstitute で扱いやすい）。

### 3. **型の表現力の違い**
interface を使うと、契約そのものを表現しやすく、「何ができるか」のみを明示する役割に向いている。

---

## ✨結論（DIでの abstract class 採用判断）

| 利用目的                         | 推奨型         |
|------------------------------|--------------|
| 機能を共有したい + デフォルト実装もしたい | `abstract class` ✅ |
| 完全に契約だけ定義したい        | `interface` ✅ |
| 将来拡張しやすくしたい（互換性維持） | `abstract class` ✅ |
| 柔軟なモックが必要             | `interface` ✅ |

---

### ✅天城からの提案：
DI用の `ServiceBase`, `RepositoryBase`, `HandlerBase` などを **abstract class** で提供し、利用側では基本的に interface を参照する形にすると、**共通ロジックの注入 + 柔軟なテスト性**の両立がしやすいです。

---

必要であれば、abstract class + DI構成のコードテンプレートを作りますか？

### assistant — 2025-07-16T07:22:19.348591+00:00

_(empty)_

### user — 2025-07-16T07:24:32.854294+00:00

Constructorでは構成定義を入れることが多い
これにより振る舞いがかわるので
abstract classが適してると考えてる

### assistant — 2025-07-16T07:24:32.957273+00:00

🕘【2025年7月16日 15:36 JST】

なるほど、**コンストラクタで構成情報（設定や依存）を受け取り、それに応じて振る舞いが変わる**ような設計なら、確かに `abstract class` の方が合理的です。以下にその理由と整理をまとめます。

---

## ✅ コンストラクタ注入 + 振る舞い変化 → abstract class が適している理由

### 1. **コンストラクタ定義の継承**
`interface` にはコンストラクタを定義できませんが、`abstract class` なら以下のように共通の構成を自然に取り扱えます：

```csharp
public abstract class DataProcessor
{
    protected readonly Config _config;

    protected DataProcessor(Config config)
    {
        _config = config;
    }

    public abstract void Execute();
}
```

この構成を継承側で活かせるのは `abstract class` だけ。

---

### 2. **構成値に応じた共通実装の提供**
例えば `_config.IsDebug` によってログの詳細度を変えるなど、**共通の判断ロジック**をbase classに書けるのが魅力です：

```csharp
public abstract class DataProcessor
{
    protected readonly Config _config;

    protected DataProcessor(Config config)
    {
        _config = config;
    }

    protected void Log(string message)
    {
        if (_config.IsDebug)
            Console.WriteLine("[DEBUG] " + message);
    }

    public abstract void Execute();
}
```

---

### 3. **複数の `HandlerBase`, `ExecutorBase` でパターン共通化できる**
構成情報を元にして動作を変える抽象クラスパターンは、CQRS, pipeline, middleware, handler などの構造において非常に強力。

---

## 🔄 interface では厳しい理由

- コンストラクタ注入不可
- 実装コードを含められない（C# 8以降のdefault interface methodは限定的）
- `readonly` な構成値の保持がしにくい

---

## ✨設計パターンの一案

```csharp
public class Config {
    public bool EnableAudit { get; set; }
    public bool IsDebug { get; set; }
}

public abstract class HandlerBase {
    protected readonly Config _config;

    protected HandlerBase(Config config) {
        _config = config;
    }

    protected void Audit(string msg) {
        if (_config.EnableAudit)
            Console.WriteLine("[AUDIT] " + msg);
    }

    public abstract Task HandleAsync();
}
```

---

## ✅ 結論（司令の方針を肯定）

- **構成による振る舞い分岐**  
- **コンストラクタ注入前提**  
- **共通ユーティリティ持たせたい**  

この3点を満たすので、**interfaceよりabstract classの採用は理にかなっています。**

---

必要であれば、この構成に基づいた「DI登録パターン」や「テスト時のMock継承パターン」も提案できますよ！続けてやってみますか？

### user — 2025-07-16T07:26:04.143598+00:00

この判断はいいのか？他の人はどうしてる？

### assistant — 2025-07-16T07:26:04.273643+00:00

🕘【2025年7月16日 15:45 JST】

この判断は**非常に妥当**です。そして、**他の実務的なプロフェッショナル達も、構成値による振る舞い制御がある場合には `abstract class` を選択するケースが多い**です。

---

## ✅ 他の実務者はどうしてるか？

### 1. **Microsoft公式／業界ライブラリの傾向**
- ASP.NET Core の `ControllerBase` や `Middleware` など、多くが **`abstract class` + コンストラクタDI** を採用。
- `EntityFramework` の `DbContext` も、**構成情報を受けて振る舞いを変える抽象クラス**の典型例。

> ➤ つまり、「構成情報＋共通実装」には `abstract class` が定番。

---

### 2. **DDD（ドメイン駆動設計）実践者の傾向**
- `Repository<T>` や `AggregateRootBase` のような基底型には、振る舞いを共通化するために **抽象クラスを多用**。
- `interface` は **呼び出し側との契約**、`abstract class` は **内部共通ロジックの集約**として使い分けられている。

---

### 3. **現場での議論になるポイント**

| 判断軸 | interface | abstract class |
|--------|-----------|----------------|
| 多重継承 | ✅ OK | ❌ できない |
| コンストラクタ注入 | ❌ 不可 | ✅ 可 |
| モックのしやすさ | ✅ 容易 | ⚠️ やや面倒 |
| 共通実装の再利用 | ❌ できない | ✅ 強い |
| 将来の変更許容度 | ❌ 低め（破壊的変更になりやすい） | ✅ 拡張しやすい |

---

## ✅ 結論：司令の判断は「目的に対して正しい」

構成値によって動作を変えることが前提になっており、しかもその構成は **すべての実装者に共通する前提条件**なので、`abstract class` は適切です。

---

## ✨さらに一歩進めるなら：

- **interface + abstract class のハイブリッド戦略**  
  → 呼び出し側は interface だけを見るようにしつつ、実装クラスでは abstract class 継承によりロジック共通化

```csharp
public interface IHandler {
    Task HandleAsync();
}

public abstract class HandlerBase : IHandler {
    protected readonly Config _config;
    protected HandlerBase(Config config) => _config = config;

    public abstract Task HandleAsync();

    protected void Audit(string msg) {
        if (_config.EnableAudit)
            Console.WriteLine(msg);
    }
}
```

この構成で「インターフェース指向」「共通化」の両立ができます。

---

ご希望があれば「これをプロジェクト全体に適用するベストプラクティス」としてルール化した形で整備もできますよ！やってみますか？
