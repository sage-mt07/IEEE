---
conversation_id: "6764fb85-f51c-8007-896f-0b5499f5d497"
title: "Memory StringBuilder 実装"
create_time: 1734671238.315368
update_time: 1734671357.169343
language_guess: "en"
num_messages: 7
part_index: 1
part_count: 1
---

### system — 2024-12-20T05:07:18.315368+00:00

_(empty)_

### user — 2024-12-20T05:07:18.325002+00:00

Net8 のstringbuilderをmemory<t>で実現する

### assistant — 2024-12-20T05:07:34.675633+00:00

_(empty)_

### assistant — 2024-12-20T05:07:34.675784+00:00

`StringBuilder` の代替として、.NET 8 で `Memory<T>` や `Span<T>` を活用する方法を説明します。`Memory<T>` や `Span<T>` は文字列データの効率的な操作を可能にし、GC の負荷を減らすことができます。ただし、`StringBuilder` の機能すべてを完全に再現するには、いくつかの工夫が必要です。

以下は、`Memory<char>` を使用して簡易的な `StringBuilder` の代替を実装する例です。

### 実装例

```csharp
using System;

public class MemoryStringBuilder
{
    private char[] _buffer;
    private int _position;

    public MemoryStringBuilder(int initialCapacity = 256)
    {
        _buffer = new char[initialCapacity];
        _position = 0;
    }

    public void Append(ReadOnlySpan<char> value)
    {
        EnsureCapacity(value.Length);
        value.CopyTo(_buffer.AsSpan(_position));
        _position += value.Length;
    }

    public void Append(char value)
    {
        EnsureCapacity(1);
        _buffer[_position] = value;
        _position++;
    }

    public override string ToString()
    {
        return new string(_buffer, 0, _position);
    }

    private void EnsureCapacity(int additionalLength)
    {
        if (_position + additionalLength > _buffer.Length)
        {
            Array.Resize(ref _buffer, Math.Max(_buffer.Length * 2, _position + additionalLength));
        }
    }

    public Memory<char> AsMemory()
    {
        return new Memory<char>(_buffer, 0, _position);
    }
}

class Program
{
    static void Main()
    {
        var builder = new MemoryStringBuilder();
        builder.Append("Hello, ");
        builder.Append("World!".AsSpan());
        builder.Append('!');

        Console.WriteLine(builder.ToString()); // "Hello, World!!"

        var memory = builder.AsMemory();
        Console.WriteLine(new string(memory.Span)); // "Hello, World!!"
    }
}
```

### 解説

1. **内部バッファとして `char[]` を使用**  
   `Memory<char>` や `Span<char>` の基盤となる配列を用意します。

2. **`EnsureCapacity` メソッドで容量を管理**  
   必要に応じて内部バッファのサイズを拡張します。

3. **`Append` メソッドで文字列や文字を追加**  
   `ReadOnlySpan<char>` を使って効率的に文字列をコピーします。

4. **`ToString` メソッドで文字列を取得**  
   現在のデータを `string` として返します。

5. **`AsMemory` メソッドで `Memory<char>` を提供**  
   他の処理と連携する際に、効率よくメモリスライスを取得できます。

### 利点
- **GC の負荷を低減**: 必要以上に文字列インスタンスを生成しません。
- **効率的なメモリ操作**: `Span<T>` や `Memory<T>` を利用してコピーや操作が効率的に行われます。

### 注意点
- この実装は `StringBuilder` のすべての機能（例: フォーマット、特定インデックスへの挿入など）を提供するわけではありません。
- スレッドセーフではありません。同時アクセスが必要な場合は追加のロック機構を実装する必要があります。

用途に応じて、このようなカスタム実装を拡張できます。

### user — 2024-12-20T05:09:04.435782+00:00

tostringを実装

### assistant — 2024-12-20T05:09:16.750976+00:00

`ToString` メソッドを実装する際、`Memory<T>` や `Span<T>` を活用して現在の文字列内容を効率的に生成します。以下に、`ToString` メソッドを `MemoryStringBuilder` に実装する例を示します。

### 実装例

```csharp
public override string ToString()
{
    return new string(_buffer.AsSpan(0, _position));
}
```

### 解説

- **`new string(ReadOnlySpan<char>)` の活用**  
  .NET Core 2.1 以降、`string` のコンストラクタで `ReadOnlySpan<char>` を受け取るオーバーロードが追加されており、既存の配列やスパンから効率的に文字列を生成できます。

- **`_buffer.AsSpan(0, _position)`**  
  内部バッファ配列 `_buffer` の先頭から現在のデータ長 `_position` までをスライスして渡します。この範囲のみを `string` に変換することで、余計なメモリコピーを回避します。

### 完成版コード

以下に、`ToString` を含む完成版コードを示します。

```csharp
using System;

public class MemoryStringBuilder
{
    private char[] _buffer;
    private int _position;

    public MemoryStringBuilder(int initialCapacity = 256)
    {
        _buffer = new char[initialCapacity];
        _position = 0;
    }

    public void Append(ReadOnlySpan<char> value)
    {
        EnsureCapacity(value.Length);
        value.CopyTo(_buffer.AsSpan(_position));
        _position += value.Length;
    }

    public void Append(char value)
    {
        EnsureCapacity(1);
        _buffer[_position] = value;
        _position++;
    }

    public override string ToString()
    {
        return new string(_buffer.AsSpan(0, _position));
    }

    private void EnsureCapacity(int additionalLength)
    {
        if (_position + additionalLength > _buffer.Length)
        {
            Array.Resize(ref _buffer, Math.Max(_buffer.Length * 2, _position + additionalLength));
        }
    }

    public Memory<char> AsMemory()
    {
        return new Memory<char>(_buffer, 0, _position);
    }
}

class Program
{
    static void Main()
    {
        var builder = new MemoryStringBuilder();
        builder.Append("Hello, ");
        builder.Append("World!".AsSpan());
        builder.Append('!');

        Console.WriteLine(builder.ToString()); // "Hello, World!!"

        var memory = builder.AsMemory();
        Console.WriteLine(new string(memory.Span)); // "Hello, World!!"
    }
}
```

### `ToString` 実装の利点
- メモリ効率が良い: 余分な配列コピーやメモリ割り当てが発生しません。
- 高速: 内部バッファの特定範囲を直接文字列化します。

このようにして、`MemoryStringBuilder` のデータを効率的に `string` に変換できます。
