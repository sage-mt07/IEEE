---
conversation_id: "62a70ce9-e1e2-4113-95ab-7a899a839602"
title: "バージョン管理の提案"
create_time: 1722693852.386381
update_time: 1722695544.387566
language_guess: "en"
num_messages: 14
part_index: 1
part_count: 1
---

### system — 2024-08-03T14:04:12.386381+00:00

_(empty)_

### user — 2024-08-03T14:04:12.389429+00:00

Azure DevOpsでパッケージを作成しバージョン管理をおこなう
バージョン番号の付与案を示せ

### assistant — 2024-08-03T14:04:37.997109+00:00

_(empty)_

### assistant — 2024-08-03T14:04:37.997197+00:00

Azure DevOpsでパッケージを作成し、バージョン管理を行うためのバージョン番号の付与案として、以下の方法を提案します。

## バージョン番号付与の基本ルール

### セマンティックバージョニング
セマンティックバージョニング（Semantic Versioning, SemVer）は、一般的に使用されるバージョニング方式です。バージョン番号は `MAJOR.MINOR.PATCH` という形式を取り、以下のルールに従います。

- **MAJOR** バージョン: 互換性のないAPI変更が行われた場合に増加
- **MINOR** バージョン: 後方互換性のある機能追加が行われた場合に増加
- **PATCH** バージョン: 後方互換性のあるバグ修正が行われた場合に増加

### プレリリースおよびビルドメタデータ
セマンティックバージョニングには、プレリリース（`-alpha`, `-beta`, `-rc` など）やビルドメタデータ（`+build.12345` など）を含めることも可能です。

## バージョン番号の付与案

### 1. 手動でのバージョン管理
- **MAJOR.MINOR.PATCH** の形式を使用し、リリースごとに手動でバージョン番号を更新します。
- プレリリースやビルドメタデータを使用して、開発中のバージョンやCIビルドを区別します。
- 例: `1.0.0`, `1.1.0-beta.1`, `1.1.0`, `2.0.0`

### 2. Azure Pipelinesを用いた自動バージョン管理
Azure Pipelinesのビルドパイプラインを設定し、ビルドごとに自動的にバージョン番号を生成します。以下のようなルールを設定できます。

- **MAJOR** バージョン: 手動で変更
- **MINOR** バージョン: 手動で変更
- **PATCH** バージョン: 自動的に増加

### 自動バージョン付与のスクリプト例
Azure PipelinesのYAMLファイルで、ビルド番号を自動的に生成するスクリプトの一例です。

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  major: 1
  minor: 0
  patch: $[counter(variables['Build.SourceBranchName'], 0)]
  semVer: $(major).$(minor).$(patch)

steps:
- script: echo "##vso[build.updatebuildnumber]$(semVer)"
  displayName: 'Set Version Number'

- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x'
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: DotNetCoreCLI@2
  inputs:
    command: 'build'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  inputs:
    command: 'pack'
    packagesToPack: '**/*.csproj'
    versioningScheme: 'byBuildNumber'
    version: '$(semVer)'
    includeSymbols: false
    includesource: false
```

このスクリプトは、`main` ブランチがトリガーされた際にビルドを実行し、バージョン番号を自動的に生成します。 `major` および `minor` バージョンは手動で設定し、 `patch` バージョンはブランチごとにカウンターを使用して自動的に増加します。これにより、毎回異なるビルド番号を生成することができます。

### 3. Git タグを用いたバージョン管理
Git タグを使用してバージョンを管理し、Azure Pipelinesでビルド時に最新のタグを取得してバージョン番号として使用します。

#### Git タグの付与例
```bash
git tag -a v1.0.0 -m "Initial release"
git push origin v1.0.0
```

#### Azure PipelinesでのGitタグを用いたバージョン番号設定例
```yaml
steps:
- script: |
    git fetch --tags
    TAG=$(git describe --tags `git rev-list --tags --max-count=1`)
    echo "##vso[build.updatebuildnumber]$TAG"
  displayName: 'Set Version Number from Git Tag'
```

このスクリプトは、最新のGitタグを取得してバージョン番号として設定します。

以上がAzure DevOpsでパッケージのバージョン管理を行うためのバージョン番号付与案です。これにより、一貫性のあるバージョン管理と自動化されたビルドプロセスを実現できます。

### user — 2024-08-03T14:05:25.024664+00:00

Major,Minor,Patchについてブランチ管理と合わせて番号付与方法を示せ

### assistant — 2024-08-03T14:05:49.556861+00:00

ブランチ管理と合わせて、バージョン番号を付与する方法について具体的な案を示します。以下の構成を例に説明します。

## ブランチ戦略
- **main** ブランチ: リリースされた安定版が存在するブランチ
- **develop** ブランチ: 次のリリースのための開発中のコードが存在するブランチ
- **feature/** ブランチ: 新機能の開発用ブランチ
- **bugfix/** ブランチ: バグ修正用ブランチ
- **release/** ブランチ: リリース準備中のコードが存在するブランチ
- **hotfix/** ブランチ: 緊急修正用ブランチ

## バージョン番号付与のルール
- **MAJOR** バージョン: main ブランチで互換性のない変更をリリースする場合に増加
- **MINOR** バージョン: main ブランチで後方互換性のある新機能をリリースする場合に増加
- **PATCH** バージョン: main ブランチで後方互換性のあるバグ修正をリリースする場合に増加

### 各ブランチでのバージョン番号付与方法

1. **main ブランチ**
   - `MAJOR.MINOR.PATCH` の形式でバージョン番号を付与
   - リリースのたびにバージョン番号を更新
   - 例: `1.0.0`, `1.1.0`, `2.0.0`

2. **develop ブランチ**
   - 次のリリースの準備として `MAJOR.MINOR.PATCH-dev.BUILD` の形式でバージョン番号を付与
   - `BUILD` はビルド番号やコミットハッシュなどの識別子
   - 例: `1.1.0-dev.1234`

3. **feature ブランチ**
   - 開発中の新機能には `MAJOR.MINOR.PATCH-feature.FEATURE_NAME.BUILD` の形式でバージョン番号を付与
   - `FEATURE_NAME` は機能名や識別子
   - 例: `1.1.0-feature.login.1234`

4. **bugfix ブランチ**
   - バグ修正には `MAJOR.MINOR.PATCH-bugfix.BUGFIX_NAME.BUILD` の形式でバージョン番号を付与
   - `BUGFIX_NAME` はバグ修正の識別子
   - 例: `1.1.0-bugfix.ui.1234`

5. **release ブランチ**
   - リリース準備中のバージョンには `MAJOR.MINOR.PATCH-rc.RELEASE_CANDIDATE.BUILD` の形式でバージョン番号を付与
   - `RELEASE_CANDIDATE` はリリース候補の識別子
   - 例: `1.1.0-rc.1`

6. **hotfix ブランチ**
   - 緊急修正には `MAJOR.MINOR.PATCH-hotfix.HOTFIX_NAME.BUILD` の形式でバージョン番号を付与
   - `HOTFIX_NAME` は緊急修正の識別子
   - 例: `1.1.1-hotfix.critical.1234`

## Azure Pipelinesでの自動バージョン付与
Azure PipelinesのYAMLファイルを使用して、上記のバージョン付与ルールに従って自動的にバージョン番号を生成する例を示します。

```yaml
trigger:
- main
- develop
- feature/*
- bugfix/*
- release/*
- hotfix/*

pool:
  vmImage: 'ubuntu-latest'

variables:
  major: 1
  minor: 0
  patch: 0

jobs:
- job: setVersion
  steps:
  - script: |
      BRANCH_NAME=$(Build.SourceBranchName)
      if [[ "$BRANCH_NAME" == "main" ]]; then
        VERSION="$major.$minor.$patch"
      elif [[ "$BRANCH_NAME" == "develop" ]]; then
        VERSION="$major.$minor.$patch-dev.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == feature/* ]]; then
        FEATURE_NAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-feature.$FEATURE_NAME.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == bugfix/* ]]; then
        BUGFIX_NAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-bugfix.$BUGFIX_NAME.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == release/* ]]; then
        RC_VERSION=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-rc.$RC_VERSION.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == hotfix/* ]]; then
        HOTFIX_NAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-hotfix.$HOTFIX_NAME.$(Build.BuildId)"
      else
        VERSION="$major.$minor.$patch-unknown.$(Build.BuildId)"
      fi
      echo "##vso[build.updatebuildnumber]$VERSION"
    displayName: 'Set Version Number'

- job: buildAndPack
  dependsOn: setVersion
  steps:
  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      version: '6.x'
      installationPath: $(Agent.ToolsDirectory)/dotnet

  - task: DotNetCoreCLI@2
    inputs:
      command: 'build'
      projects: '**/*.csproj'

  - task: DotNetCoreCLI@2
    inputs:
      command: 'pack'
      packagesToPack: '**/*.csproj'
      versioningScheme: 'byBuildNumber'
      version: '$(Build.BuildNumber)'
      includeSymbols: false
      includesource: false
```

このYAMLファイルでは、ビルドプロセスの開始時にブランチ名に基づいてバージョン番号を生成し、その後のビルドおよびパッケージングステップでそのバージョン番号を使用します。これにより、一貫性のあるバージョン番号を自動的に付与することができます。

### user — 2024-08-03T14:06:16.756909+00:00

例えばnet6対応のライブラリからnet8対応のライブラリに変更した場合はどのようになるのか

### assistant — 2024-08-03T14:06:35.102933+00:00

.NETのメジャーバージョンが変更された場合、セマンティックバージョニングのルールに従ってメジャーバージョンを更新することが一般的です。つまり、.NET 6から.NET 8への変更は互換性のない変更とみなされるため、**MAJOR**バージョンを増加させます。

以下に、そのような変更が行われた場合のバージョン管理の一例を示します。

## バージョン番号の変更例

### 変更前
- .NET 6対応のバージョン: `1.2.3`
  - 例: `1.2.3`

### 変更後
- .NET 8対応に変更されたバージョン: `2.0.0`
  - 例: `2.0.0`

## Azure Pipelinesでのバージョン管理

Azure PipelinesのYAMLファイルにおいて、メジャーバージョンの変更を反映させるためには、手動でメジャーバージョンを増加させます。その後のバージョン付与は既存のルールに従います。

```yaml
trigger:
- main
- develop
- feature/*
- bugfix/*
- release/*
- hotfix/*

pool:
  vmImage: 'ubuntu-latest'

variables:
  major: 2  # メジャーバージョンを手動で更新
  minor: 0
  patch: 0

jobs:
- job: setVersion
  steps:
  - script: |
      BRANCH_NAME=$(Build.SourceBranchName)
      if [[ "$BRANCH_NAME" == "main" ]]; then
        VERSION="$major.$minor.$patch"
      elif [[ "$BRANCH_NAME" == "develop" ]]; then
        VERSION="$major.$minor.$patch-dev.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == feature/* ]]; then
        FEATURE_NAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-feature.$FEATURE_NAME.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == bugfix/* ]]; then
        BUGFIX_NAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-bugfix.$BUGFIX_NAME.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == release/* ]]; then
        RC_VERSION=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-rc.$RC_VERSION.$(Build.BuildId)"
      elif [[ "$BRANCH_NAME" == hotfix/* ]]; then
        HOTFIX_NAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-hotfix.$HOTFIX_NAME.$(Build.BuildId)"
      else
        VERSION="$major.$minor.$patch-unknown.$(Build.BuildId)"
      fi
      echo "##vso[build.updatebuildnumber]$VERSION"
    displayName: 'Set Version Number'

- job: buildAndPack
  dependsOn: setVersion
  steps:
  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      version: '8.x'  # .NET 8対応に変更
      installationPath: $(Agent.ToolsDirectory)/dotnet

  - task: DotNetCoreCLI@2
    inputs:
      command: 'build'
      projects: '**/*.csproj'

  - task: DotNetCoreCLI@2
    inputs:
      command: 'pack'
      packagesToPack: '**/*.csproj'
      versioningScheme: 'byBuildNumber'
      version: '$(Build.BuildNumber)'
      includeSymbols: false
      includesource: false
```

この例では、`major` 変数の値を `2` に手動で更新することで、.NET 6から.NET 8への変更を反映しています。また、`UseDotNet` タスクの `version` パラメータも `8.x` に変更し、.NET 8対応にしています。これにより、次のリリースからメジャーバージョンが更新され、互換性のない変更が正しく反映されます。

### user — 2024-08-03T14:31:17.177973+00:00

この流れでRCから製品版に更新した際にテストは必要か？

### assistant — 2024-08-03T14:31:37.089092+00:00

_(empty)_

### assistant — 2024-08-03T14:31:37.089178+00:00

RC（リリース候補）から製品版に更新する際には、テストは非常に重要です。以下の理由から、RCから製品版に更新する前には十分なテストを実施することが推奨されます。

## テストの重要性

### 1. 安定性と信頼性の確認
RC版ではすべての機能が実装されているものの、予期せぬバグやパフォーマンスの問題が残っている可能性があります。製品版としてリリースする前に、すべての機能が期待通りに動作し、安定していることを確認するためのテストが必要です。

### 2. 回帰テスト
RCから製品版に移行する際、バグ修正や最終的な調整が行われる場合があります。これらの変更が他の部分に悪影響を与えていないことを確認するために、回帰テストを実施します。

### 3. ユーザー体験の確認
ユーザーインターフェースやユーザー体験が期待通りであるかを確認するためのテストも必要です。RC版のフィードバックをもとに、最終的な調整が必要になることがあります。

## テストの種類

### 1. 単体テスト
各機能が個別に正しく動作することを確認します。

### 2. 統合テスト
異なるコンポーネントやモジュールが正しく連携して動作することを確認します。

### 3. システムテスト
システム全体が仕様通りに動作することを確認します。

### 4. 回帰テスト
過去にテストした機能が、最新の変更によって影響を受けていないことを確認します。

### 5. ユーザー受け入れテスト (UAT)
実際のユーザーが製品を使用して、期待通りの動作をするかを確認します。

### 6. パフォーマンステスト
システムのパフォーマンスが期待通りであるかを確認します。

## Azure DevOpsでのテスト自動化

Azure Pipelinesを使用して、RCから製品版への更新前に自動化されたテストを実行する方法を示します。

```yaml
trigger:
- release/*

pool:
  vmImage: 'ubuntu-latest'

variables:
  major: 2
  minor: 0
  patch: 0

jobs:
- job: setVersion
  steps:
  - script: |
      BRANCH_NAME=$(Build.SourceBranchName)
      if [[ "$BRANCH_NAME" == release/* ]]; then
        RC_VERSION=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-rc.$RC_VERSION.$(Build.BuildId)"
      else
        VERSION="$major.$minor.$patch-unknown.$(Build.BuildId)"
      fi
      echo "##vso[build.updatebuildnumber]$VERSION"
    displayName: 'Set Version Number'

- job: buildAndTest
  dependsOn: setVersion
  steps:
  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      version: '8.x'
      installationPath: $(Agent.ToolsDirectory)/dotnet

  - task: DotNetCoreCLI@2
    inputs:
      command: 'restore'
      projects: '**/*.csproj'

  - task: DotNetCoreCLI@2
    inputs:
      command: 'build'
      projects: '**/*.csproj'

  - task: DotNetCoreCLI@2
    inputs:
      command: 'test'
      projects: '**/*.csproj'
      arguments: '--configuration Release --collect "Code Coverage"'
    displayName: 'Run Tests and Collect Code Coverage'

  - task: PublishTestResults@2
    inputs:
      testRunner: 'VSTest'
      testResultsFiles: '**/TestResults/*.trx'
    displayName: 'Publish Test Results'

  - task: PublishCodeCoverageResults@1
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: '**/coverage.cobertura.xml'
      reportDirectory: '$(Build.ArtifactStagingDirectory)/CodeCoverage'
    displayName: 'Publish Code Coverage Results'

- job: deploy
  dependsOn: buildAndTest
  condition: succeeded()
  steps:
  - script: echo "Deploy to Production"
    displayName: 'Deploy to Production'
```

このパイプラインは、次のように構成されています。

1. **バージョン設定**: ブランチ名に基づいてバージョン番号を設定します。
2. **ビルドとテスト**: .NET SDKを使用してプロジェクトをビルドし、テストを実行します。テスト結果とコードカバレッジを収集して公開します。
3. **デプロイ**: テストが成功した場合、プロダクション環境にデプロイします。

これにより、RCから製品版に更新する際に、必要なテストを自動的に実行し、製品版の品質を確保できます。

### user — 2024-08-03T14:31:59.632096+00:00

RC版と製品版ではソースコードの変更は発生していないがテストの必要性は

### assistant — 2024-08-03T14:32:23.936617+00:00

RC版と製品版の間でソースコードの変更が発生していない場合でも、テストは依然として重要です。以下に、テストの必要性を説明します。

## テストの必要性

### 1. 環境の差異
RC版と製品版のビルドおよびデプロイ環境が異なる可能性があります。異なる環境で動作を確認することで、環境依存の問題を検出できます。

### 2. ビルドプロセスの検証
製品版のビルドプロセスに問題がないことを確認するために、テストを実行することが重要です。ビルドプロセスの違いが動作に影響を与える場合があります。

### 3. 最終確認
RC版でのテストをクリアしたとしても、製品版のリリース前には最終確認としてテストを実施することで、最終的な品質保証を行います。

### 4. ユーザー受け入れテスト (UAT)
RC版がユーザーによってテストされている場合でも、製品版としてリリースする前にもう一度ユーザー受け入れテストを実施することで、最終的なフィードバックを得ることができます。

## 最小限のテストアプローチ

ソースコードが変更されていない場合でも、以下の最小限のテストを実行することを推奨します。

### 1. スモークテスト
基本的な機能が動作することを確認するためのテストを実施します。これにより、重大な問題がないことを迅速に確認できます。

### 2. 回帰テスト
既存のテストケースを再実行し、以前と同じ結果が得られることを確認します。これにより、予期せぬ不具合の発生を防ぎます。

### 3. 環境確認テスト
製品版が実行される環境で、すべての主要な機能が期待通りに動作することを確認します。

## Azure Pipelinesでの最小限のテスト実行例

Azure PipelinesのYAMLファイルにおいて、最小限のテストを実行する設定を示します。

```yaml
trigger:
- main
- release/*

pool:
  vmImage: 'ubuntu-latest'

variables:
  major: 2
  minor: 0
  patch: 0

jobs:
- job: setVersion
  steps:
  - script: |
      BRANCH_NAME=$(Build.SourceBranchName)
      if [[ "$BRANCH_NAME" == release/* ]]; then
        RC_VERSION=$(echo $BRANCH_NAME | cut -d'/' -f2)
        VERSION="$major.$minor.$patch-rc.$RC_VERSION.$(Build.BuildId)"
      else
        VERSION="$major.$minor.$patch-unknown.$(Build.BuildId)"
      fi
      echo "##vso[build.updatebuildnumber]$VERSION"
    displayName: 'Set Version Number'

- job: buildAndTest
  dependsOn: setVersion
  steps:
  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      version: '8.x'
      installationPath: $(Agent.ToolsDirectory)/dotnet

  - task: DotNetCoreCLI@2
    inputs:
      command: 'restore'
      projects: '**/*.csproj'

  - task: DotNetCoreCLI@2
    inputs:
      command: 'build'
      projects: '**/*.csproj'

  - task: DotNetCoreCLI@2
    inputs:
      command: 'test'
      projects: '**/*.csproj'
      arguments: '--configuration Release --filter Category=SmokeTest'
    displayName: 'Run Smoke Tests'

  - task: PublishTestResults@2
    inputs:
      testRunner: 'VSTest'
      testResultsFiles: '**/TestResults/*.trx'
    displayName: 'Publish Test Results'

- job: deploy
  dependsOn: buildAndTest
  condition: succeeded()
  steps:
  - script: echo "Deploy to Production"
    displayName: 'Deploy to Production'
```

このパイプラインは、次のように構成されています。

1. **バージョン設定**: ブランチ名に基づいてバージョン番号を設定します。
2. **ビルドと最小限のテスト**: .NET SDKを使用してプロジェクトをビルドし、スモークテストを実行します。テスト結果を収集して公開します。
3. **デプロイ**: テストが成功した場合、プロダクション環境にデプロイします。

これにより、RCから製品版への移行時に最小限のテストを実施し、製品版の品質を確保することができます。
