---
conversation_id: "686de7cc-3d88-8007-aa14-1369889279ca"
title: "AIの名前と役割"
create_time: 1752033228.69942
update_time: 1752106832.918086
language_guess: "en"
num_messages: 239
part_index: 3
part_count: 3
---

### tool — 2025-07-10T00:15:03.513198+00:00

// ===================================================================
// 5. Producer/Consumer統合 - 完全AVRO Key/Value分離対応
// ===================================================================

namespace Kafka.Ksql.Linq.Messaging.Producers
{
    /// <summary>
    /// 完全AVRO対応Key/Value分離Producer
    /// </summary>
    public class AvroKeyValueProducer<T> where T : class
    {
        private readonly IProducer<byte[], byte[]> _producer; // ← Key/Value共にAVRO bytes
        private readonly IAvroKeyValueSerializationManager<T> _serializationManager;
        private readonly string _topicName;

        public AvroKeyValueProducer(
            IProducer<byte[], byte[]> producer, // ← AVRO bytesのProducer
            IAvroKeyValueSerializationManager<T> serializationManager,
            string topicName)
        {
            _producer = producer ?? throw new ArgumentNullException(nameof(producer));
            _serializationManager = serializationManager ?? throw new ArgumentNullException(nameof(serializationManager));
            _topicName = topicName ?? throw new ArgumentNullException(nameof(topicName));
        }

        /// <summary>
        /// エンティティをAVRO Key/Value分離で送信
        /// </summary>
        public async Task<DeliveryResult<byte[], byte[]>> ProduceAsync(T entity, CancellationToken cancellationToken = default)
        {
            // Key/Value別々にAVROシリアライズ
            var keyBytes = await _serializationManager.SerializeKeyAsync(entity);    // ← AVRO bytes
            var valueBytes = await _serializationManager.SerializeValueAsync(entity); // ← AVRO bytes

            var message = new Message<byte[], byte[]>
            {
                Key = keyBytes,   // ← AVRO形式 (Magic Byte + Schema ID + AVRO data)
                Value = valueBytes, // ← AVRO形式 (Magic Byte + Schema ID + AVRO data)
                Timestamp = new Timestamp(DateTime.UtcNow),
                Headers = new Headers
                {
                    { "content-type-key", Encoding.UTF8.GetBytes("application/avro") },
                    { "content-type-value", Encoding.UTF8.GetBytes("application/avro") },
                    { "entity-type", Encoding.UTF8.GetBytes(typeof(T).FullName!) }
                }
            };

            Console.WriteLine($"📤 Sending AVRO message to {_topicName}:");
            Console.WriteLine($"   Key: {keyBytes.Length} bytes (AVRO)");
            Console.WriteLine($"   Value: {valueBytes.Length} bytes (AVRO)");

            return await _producer.ProduceAsync(_topicName, message, cancellationToken);
        }

        /// <summary>
        /// 複数エンティティの一括送信
        /// </summary>
        public async Task<List<DeliveryResult<byte[], byte[]>>> ProduceBatchAsync(
            IEnumerable<T> entities, 
            CancellationToken cancellationToken = default)
        {
            var results = new List<DeliveryResult<byte[], byte[]>>();
            
            foreach (var entity in entities)
            {
                var result = await ProduceAsync(entity, cancellationToken);
                results.Add(result);
            }

            return results;
        }

        public void Dispose()
        {
            _cancellationTokenSource?.Cancel();
            _consumer?.Dispose();
            _cancellationTokenSource?.Dispose();
        }
    }
}

// ===================================================================
// 6. 完全AVRO統合例 - QuerySchema → AVRO Serializer 連携
// ===================================================================

namespace Kafka.Ksql.Linq.Examples
{
    /// <summary>
    /// QuerySchema から 完全AVRO Serializer への統合例
    /// </summary>
    public class AvroQuerySchemaIntegrationExample
    {
        public async Task DemonstrateFullAvroIntegrationAsync()
        {
            Console.WriteLine("🚀 Starting AVRO QuerySchema Integration Demo");

            // 1. QuerySchema定義（OnModelCreatingで実行済み想定）
            var querySchema = new QuerySchema
            {
                SourceType = typeof(Order),
                TargetType = typeof(OrderSummary),
                KeyProperties = new[] { typeof(OrderSummary).GetProperty("CustomerId")! },
                ValueProperties = new[] 
                { 
                    typeof(OrderSummary).GetProperty("TotalAmount")!,
                    typeof(OrderSummary).GetProperty("OrderCount")!,
                    typeof(OrderSummary).GetProperty("LastOrderDate")!
                },
                TopicName = "order_summaries",
                IsValid = true
            };

            Console.WriteLine("✅ QuerySchema created");

            // 2. QuerySchema → AvroEntityConfiguration 変換
            var avroConfig = AvroEntityConfiguration.FromQuerySchema(querySchema);
            Console.WriteLine("✅ AvroEntityConfiguration created from QuerySchema");

            // 3. Schema Registry に Key/Value分離AVRO登録
            var schemaRegistryClient = new CachedSchemaRegistryClient(new SchemaRegistryConfig 
            { 
                Url = "http://localhost:8081",
                MaxCachedSchemas = 100
            });
            
            var registrationService = new AvroSchemaRegistrationService(schemaRegistryClient);
            var schemaIds = await registrationService.RegisterKeyValueSchemaAsync<OrderSummary>(avroConfig);
            
            Console.WriteLine($"✅ AVRO schemas registered:");
            Console.WriteLine($"   Key Subject: {schemaIds.GetKeySubject()} (ID: {schemaIds.KeySchemaId})");
            Console.WriteLine($"   Value Subject: {schemaIds.GetValueSubject()} (ID: {schemaIds.ValueSchemaId})");

            // 4. AVRO SerializationManager作成
            var avroSerializationManager = new AvroKeyValueSerializationManager<OrderSummary>(
                avroConfig, schemaIds, schemaRegistryClient);
            
            Console.WriteLine("✅ AVRO Key/Value SerializationManager created");

            // 5. AVRO Producer作成・使用
            var producerConfig = new ProducerConfig 
            { 
                BootstrapServers = "localhost:9092",
                Acks = Acks.All,
                Retries = 3,
                EnableIdempotence = true
            };
            
            var producer = new ProducerBuilder<byte[], byte[]>(producerConfig).Build(); // ← AVRO bytes
            var avroProducer = new AvroKeyValueProducer<OrderSummary>(producer, avroSerializationManager, "order_summaries");

            // テストデータ送信
            var orderSummaries = new[]
            {
                new OrderSummary
                {
                    CustomerId = "CUST001",      // ← Key (AVRO string)
                    TotalAmount = 1500.00m,     // ← Value (AVRO decimal→string)
                    OrderCount = 5,             // ← Value (AVRO int)
                    LastOrderDate = DateTime.UtcNow.AddDays(-1) // ← Value (AVRO long)
                },
                new OrderSummary
                {
                    CustomerId = "CUST002",      // ← Key (AVRO string)
                    TotalAmount = 2300.50m,     // ← Value (AVRO decimal→string)
                    OrderCount = 8,             // ← Value (AVRO int)
                    LastOrderDate = DateTime.UtcNow.AddHours(-3) // ← Value (AVRO long)
                }
            };

            foreach (var summary in orderSummaries)
            {
                var result = await avroProducer.ProduceAsync(summary);
                Console.WriteLine($"📤 AVRO message sent: Partition={result.Partition}, Offset={result.Offset}");
            }

            Console.WriteLine("✅ AVRO messages sent successfully");

            // 6. AVRO Consumer作成・使用
            var consumerConfig = new ConsumerConfig 
            { 
                BootstrapServers = "localhost:9092",
                GroupId = "avro-test-group",
                AutoOffsetReset = AutoOffsetReset.Earliest,
                EnableAutoCommit = false
            };
            
            var consumer = new ConsumerBuilder<byte[], byte[]>(consumerConfig).Build(); // ← AVRO bytes
            var avroConsumer = new AvroKeyValueConsumer<OrderSummary>(consumer, avroSerializationManager);
            
            consumer.Subscribe("order_summaries");
            Console.WriteLine("✅ AVRO Consumer subscribed to topic");

            // メッセージ受信テスト
            Console.WriteLine("📥 Starting AVRO message consumption...");
            var receivedCount = 0;
            var timeout = TimeSpan.FromSeconds(10);
            var startTime = DateTime.UtcNow;

            while (receivedCount < orderSummaries.Length && DateTime.UtcNow - startTime < timeout)
            {
                try
                {
                    var receivedEntity = await avroConsumer.ConsumeAsync(CancellationToken.None);
                    if (receivedEntity != null)
                    {
                        receivedCount++;
                        Console.WriteLine($"📥 AVRO message #{receivedCount} received:");
                        Console.WriteLine($"   CustomerId: {receivedEntity.CustomerId} (Key)");
                        Console.WriteLine($"   TotalAmount: {receivedEntity.TotalAmount} (Value)");
                        Console.WriteLine($"   OrderCount: {receivedEntity.OrderCount} (Value)");
                        Console.WriteLine($"   LastOrderDate: {receivedEntity.LastOrderDate} (Value)");
                        
                        // コミット（AVRO処理成功）
                        consumer.Commit();
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ AVRO consumption error: {ex.Message}");
                }
            }

            Console.WriteLine($"✅ AVRO Integration Demo completed. Processed {receivedCount} messages.");

            // リソース解放
            avroProducer.Dispose();
            avroConsumer.Dispose();
        }

        /// <summary>
        /// AVRO スキーマ情報の表示
        /// </summary>
        public async Task DisplayAvroSchemasAsync()
        {
            var schemaRegistryClient = new CachedSchemaRegistryClient(new SchemaRegistryConfig 
            { 
                Url = "http://localhost:8081" 
            });

            try
            {
                // Key スキーマ取得
                var keySchema = await schemaRegistryClient.GetLatestSchemaAsync("order_summaries-key");
                Console.WriteLine("📋 AVRO Key Schema:");
                Console.WriteLine(keySchema.SchemaString);
                Console.WriteLine();

                // Value スキーマ取得
                var valueSchema = await schemaRegistryClient.GetLatestSchemaAsync("order_summaries-value");
                Console.WriteLine("📋 AVRO Value Schema:");
                Console.WriteLine(valueSchema.SchemaString);
                Console.WriteLine();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ Schema retrieval error: {ex.Message}");
            }
            finally
            {
                schemaRegistryClient.Dispose();
            }
        }

        /// <summary>
        /// AVRO バイナリデータの検証
        /// </summary>
        public void AnalyzeAvroBytes(byte[] avroBytes, string description)
        {
            Console.WriteLine($"🔍 AVRO Binary Analysis - {description}:");
            Console.WriteLine($"   Length: {avroBytes.Length} bytes");
            
            if (avroBytes.Length >= 5)
            {
                var magicByte = avroBytes[0];
                var schemaId = BitConverter.ToInt32(avroBytes, 1);
                
                Console.WriteLine($"   Magic Byte: 0x{magicByte:X2} {(magicByte == 0x00 ? "✅" : "❌")}");
                Console.WriteLine($"   Schema ID: {schemaId}");
                Console.WriteLine($"   Data Length: {avroBytes.Length - 5} bytes");
                
                // 最初の数バイトをHEX表示
                var hexSample = string.Join(" ", avroBytes.Take(Math.Min(20, avroBytes.Length)).Select(b => $"{b:X2}"));
                Console.WriteLine($"   Hex Sample: {hexSample}");
            }
            else
            {
                Console.WriteLine("   ❌ Invalid AVRO format (too short)");
            }
            
            Console.WriteLine();
        }
    }

    // ===================================================================
    // 7. EventSet統合 - 完全AVRO対応
    // ===================================================================

    /// <summary>
    /// 完全AVRO対応EventSet
    /// </summary>
    public class AvroEventSet<T> : EventSet<T> where T : class
    {
        private readonly IAvroKeyValueSerializationManager<T> _avroSerializationManager;
        private readonly AvroKeyValueProducer<T> _avroProducer;
        private readonly AvroKeyValueConsumer<T> _avroConsumer;

        public AvroEventSet(
            IKsqlContext context, 
            EntityModel entityModel,
            IAvroKeyValueSerializationManager<T> avroSerializationManager,
            AvroKeyValueProducer<T> avroProducer,
            AvroKeyValueConsumer<T> avroConsumer) 
            : base(context, entityModel)
        {
            _avroSerializationManager = avroSerializationManager ?? throw new ArgumentNullException(nameof(avroSerializationManager));
            _avroProducer = avroProducer ?? throw new ArgumentNullException(nameof(avroProducer));
            _avroConsumer = avroConsumer ?? throw new ArgumentNullException(nameof(avroConsumer));
        }

        /// <summary>
        /// AVRO形式でエンティティを送信
        /// </summary>
        protected override async Task SendEntityAsync(T entity, CancellationToken cancellationToken)
        {
            try
            {
                var result = await _avroProducer.ProduceAsync(entity, cancellationToken);
                Console.WriteLine($"✅ AVRO entity sent: {typeof(T).Name} to partition {result.Partition}, offset {result.Offset}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ AVRO send failed for {typeof(T).Name}: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// AVRO形式でエンティティを継続受信
        /// </summary>
        public override async IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            Console.WriteLine($"🔄 Starting AVRO streaming for {typeof(T).Name}");
            
            await foreach (var entity in _avroConsumer.ConsumeStreamAsync(cancellationToken))
            {
                yield return entity;
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _avroProducer?.Dispose();
                _avroConsumer?.Dispose();
            }
            base.Dispose(disposing);
        }
    }

    // ===================================================================
    // 8. 完全統合ファクトリ
    // ===================================================================

    /// <summary>
    /// QuerySchema → AVRO Serializer の完全統合ファクトリ
    /// </summary>
    public static class AvroQuerySchemaFactory
    {
        /// <summary>
        /// QuerySchemaからAVRO EventSetを作成
        /// </summary>
        public static async Task<AvroEventSet<T>> CreateAvroEventSetAsync<T>(
            QuerySchema querySchema,
            IKsqlContext context,
            EntityModel entityModel,
            string bootstrapServers = "localhost:9092",
            string schemaRegistryUrl = "http://localhost:8081",
            string? consumerGroupId = null) where T : class
        {
            // 1. AvroEntityConfiguration作成
            var avroConfig = AvroEntityConfiguration.FromQuerySchema(querySchema);

            // 2. Schema Registry Client作成
            var schemaRegistryClient = new CachedSchemaRegistryClient(new SchemaRegistryConfig 
            { 
                Url = schemaRegistryUrl 
            });

            // 3. AVRO Schema登録
            var registrationService = new AvroSchemaRegistrationService(schemaRegistryClient);
            var schemaIds = await registrationService.RegisterKeyValueSchemaAsync<T>(avroConfig);

            // 4. AVRO SerializationManager作成
            var serializationManager = new AvroKeyValueSerializationManager<T>(
                avroConfig, schemaIds, schemaRegistryClient);

            // 5. Producer作成
            var producerConfig = new ProducerConfig { BootstrapServers = bootstrapServers };
            var producer = new ProducerBuilder<byte[], byte[]>(producerConfig).Build();
            var avroProducer = new AvroKeyValueProducer<T>(producer, serializationManager, querySchema.TopicName);

            // 6. Consumer作成
            var consumerConfig = new ConsumerConfig 
            { 
                BootstrapServers = bootstrapServers,
                GroupId = consumerGroupId ?? $"{typeof(T).Name.ToLower()}-group"
            };
            var consumer = new ConsumerBuilder<byte[], byte[]>(consumerConfig).Build();
            var avroConsumer = new AvroKeyValueConsumer<T>(consumer, serializationManager);

            // 7. AvroEventSet作成
            return new AvroEventSet<T>(context, entityModel, serializationManager, avroProducer, avroConsumer);
        }

        /// <summary>
        /// KsqlContextでのAVRO EventSet一括作成
        /// </summary>
        public static async Task<Dictionary<Type, object>> CreateAllAvroEventSetsAsync(
            KsqlContext ksqlContext,
            string bootstrapServers = "localhost:9092",
            string schemaRegistryUrl = "http://localhost:8081")
        {
            var avroEventSets = new Dictionary<Type, object>();
            var querySchemas = ksqlContext.GetAllQuerySchemas();
            var entityModels = ksqlContext.GetEntityModels();

            foreach (var (type, querySchema) in querySchemas)
            {
                if (entityModels.TryGetValue(type, out var entityModel))
                {
                    var method = typeof(AvroQuerySchemaFactory)
                        .GetMethod(nameof(CreateAvroEventSetAsync))!
                        .MakeGenericMethod(type);

                    var avroEventSet = await (Task<object>)method.Invoke(null, new object[]
                    {
                        querySchema, ksqlContext, entityModel, bootstrapServers, schemaRegistryUrl, null
                    })!;

                    avroEventSets[type] = avroEventSet;
                }
            }

            Console.WriteLine($"✅ Created {avroEventSets.Count} AVRO EventSets");
            return avroEventSets;
        }
    }

    // エンティティ定義例（AVRO対応）
    [Topic("orders")]
    public class Order
    {
        public int OrderId { get; set; }
        public string CustomerId { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public DateTime OrderDate { get; set; }
        public string Status { get; set; } = string.Empty;
    }

    [Topic("order_summaries")]
    public class OrderSummary
    {
        public string CustomerId { get; set; } = string.Empty;  // Key (AVRO string)
        public decimal TotalAmount { get; set; }               // Value (AVRO string - decimal)
        public int OrderCount { get; set; }                    // Value (AVRO int)
        public DateTime LastOrderDate { get; set; }           // Value (AVRO long - timestamp)
    }
}

/*
=== 完全AVRO統合完了 ===

QuerySchema → AVRO Serializer の完全な統合フローを実装しました：

🔄 AVRO統合フロー:
1. ✅ QuerySchema定義 (.HasQuery()で自動生成)
2. ✅ AvroEntityConfiguration変換 (Key/Value分離対応)  
3. ✅ AVRO Schema Registry登録 (Key/Value別々のAVROスキーマ)
4. ✅ AVRO SerializationManager (完全AVRO Key/Value分離シリアライズ)
5. ✅ AVRO Producer/Consumer (Key/Value共にAVRO bytes送受信)
6. ✅ EventSet統合 (既存APIでAVRO自動対応)

📋 AVRO対応の特徴:
- Key/Value共にConfluentAVRO形式 (Magic Byte + Schema ID + AVRO data)
- Schema Registryでのスキーマバージョン管理
- スキーマ進化への自動対応
- 型安全なシリアライズ/デシリアライズ
- パフォーマンス最適化（バイナリ形式）

🎯 使用方法:
```csharp
// OnModelCreatingでの定義
modelBuilder.Entity<OrderSummary>()
    .HasQuery<Order>(orders => orders.GroupBy(o => o.CustomerId)...)
    .AsTable("order_summaries");

// 自動AVRO統合
this.RegisterQuerySchemas(); // ← この1行で全てAVRO対応
```

これにより、LINQクエリ定義から完全AVROベースの
Kafka送受信まで、全て自動化されます。
*/d Dispose()
        {
            _producer?.Dispose();
        }
    }
}

namespace Kafka.Ksql.Linq.Messaging.Consumers
{
    /// <summary>
    /// 完全AVRO対応Key/Value分離Consumer
    /// </summary>
    public class AvroKeyValueConsumer<T> where T : class
    {
        private readonly IConsumer<byte[], byte[]> _consumer; // ← Key/Value共にAVRO bytes
        private readonly IAvroKeyValueSerializationManager<T> _serializationManager;
        private readonly CancellationTokenSource _cancellationTokenSource = new();

        public AvroKeyValueConsumer(
            IConsumer<byte[], byte[]> consumer, // ← AVRO bytesのConsumer
            IAvroKeyValueSerializationManager<T> serializationManager)
        {
            _consumer = consumer ?? throw new ArgumentNullException(nameof(consumer));
            _serializationManager = serializationManager ?? throw new ArgumentNullException(nameof(serializationManager));
        }

        /// <summary>
        /// AVRO Key/Value分離でメッセージを受信
        /// </summary>
        public async Task<T?> ConsumeAsync(CancellationToken cancellationToken = default)
        {
            try
            {
                var consumeResult = _consumer.Consume(cancellationToken);
                
                if (consumeResult?.Message == null) return null;

                // AVRO形式の検証
                ValidateAvroMessage(consumeResult.Message);

                Console.WriteLine($"📥 Received AVRO message from {consumeResult.Topic}:");
                Console.WriteLine($"   Partition: {consumeResult.Partition}, Offset: {consumeResult.Offset}");
                Console.WriteLine($"   Key: {consumeResult.Message.Key?.Length ?? 0} bytes (AVRO)");
                Console.WriteLine($"   Value: {consumeResult.Message.Value?.Length ?? 0} bytes (AVRO)");

                // AVRO Key/Valueからエンティティをデシリアライズ
                var entity = await _serializationManager.DeserializeAsync(
                    consumeResult.Message.Key ?? Array.Empty<byte>(),    // ← AVRO bytes
                    consumeResult.Message.Value ?? Array.Empty<byte>()   // ← AVRO bytes
                );
                
                return entity;
            }
            catch (ConsumeException ex)
            {
                Console.WriteLine($"❌ AVRO消費エラー: {ex.Error.Reason}");
                throw;
            }
        }

        /// <summary>
        /// 継続的なAVROストリーミング受信
        /// </summary>
        public async IAsyncEnumerable<T> ConsumeStreamAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, _cancellationTokenSource.Token);
            
            while (!linkedCts.Token.IsCancellationRequested)
            {
                var entity = await ConsumeAsync(linkedCts.Token);
                if (entity != null)
                {
                    yield return entity;
                }
            }
        }

        /// <summary>
        /// AVRO形式メッセージの検証
        /// </summary>
        private static void ValidateAvroMessage(Message<byte[], byte[]> message)
        {
            // AVRO Magic Byte検証 (0x00)
            if (message.Key != null && message.Key.Length > 0 && message.Key[0] != 0x00)
            {
                Console.WriteLine("⚠️ Warning: Key does not start with AVRO magic byte");
            }

            if (message.Value != null && message.Value.Length > 0 && message.Value[0] != 0x00)
            {
                Console.WriteLine("⚠️ Warning: Value does not start with AVRO magic byte");
            }

            // ヘッダー検証
            if (message.Headers != null)
            {
                var keyContentType = message.Headers.FirstOrDefault(h => h.Key == "content-type-key");
                var valueContentType = message.Headers.FirstOrDefault(h => h.Key == "content-type-value");
                
                if (keyContentType != null)
                {
                    var keyType = Encoding.UTF8.GetString(keyContentType.GetValueBytes());
                    if (keyType != "application/avro")
                    {
                        Console.WriteLine($"⚠️ Warning: Key content-type is {keyType}, expected application/avro");
                    }
                }
                
                if (valueContentType != null)
                {
                    var valueType = Encoding.UTF8.GetString(valueContentType.GetValueBytes());
                    if (valueType != "application/avro")
                    {
                        Console.WriteLine($"⚠️ Warning: Value content-type is {valueType}, expected application/avro");
                    }
                }
            }
        }

        public voi// ===================================================================
// 1. QuerySchema → Serializer 統合フロー概要
// ===================================================================

/*
フロー概要:
1. OnModelCreating で .HasQuery() を使って QuerySchema を定義
2. KsqlContext.RegisterQuerySchemas() で QuerySchema → AvroEntityConfiguration 変換
3. AvroSchemaRegistrationService が Key/Value分離スキーマを Schema Registry に登録
4. SerializationManager が登録済みスキーマIDを使ってシリアライザ作成
5. Producer/Consumer が Key/Value別々にシリアライズ/デシリアライズ

具体例:
OrderSummary { CustomerId(Key), TotalAmount(Value), OrderCount(Value) }
↓
KeySchema: { "CustomerId": "string" }
ValueSchema: { "TotalAmount": "decimal", "OrderCount": "int" }
↓
Schema Registry: order_summaries-key (ID: 1), order_summaries-value (ID: 2)
↓
Producer: Key用Serializer(ID:1) + Value用Serializer(ID:2)
*/

// ===================================================================
// 2. AvroEntityConfiguration拡張 - QuerySchema対応
// ===================================================================

using Kafka.Ksql.Linq.Query.Schema;
using Kafka.Ksql.Linq.Serialization.Abstractions;
using System.Reflection;

namespace Kafka.Ksql.Linq.Serialization.Abstractions
{
    /// <summary>
    /// AvroEntityConfiguration を QuerySchema 対応に拡張
    /// </summary>
    public class AvroEntityConfiguration
    {
        public Type EntityType { get; set; } = default!;
        public string? TopicName { get; set; }
        public PropertyInfo[] KeyProperties { get; set; } = Array.Empty<PropertyInfo>();
        public PropertyInfo[] ValueProperties { get; set; } = Array.Empty<PropertyInfo>(); // 新規追加
        public bool EnableCaching { get; set; }
        
        // QuerySchema から生成されたかどうかのフラグ
        public bool IsFromQuerySchema { get; set; }
        public QuerySchema? SourceQuerySchema { get; set; } // 新規追加

        public AvroEntityConfiguration(Type entityType)
        {
            EntityType = entityType ?? throw new ArgumentNullException(nameof(entityType));
        }

        /// <summary>
        /// QuerySchemaからAvroEntityConfigurationを作成
        /// </summary>
        public static AvroEntityConfiguration FromQuerySchema(QuerySchema querySchema)
        {
            if (querySchema == null)
                throw new ArgumentNullException(nameof(querySchema));

            return new AvroEntityConfiguration(querySchema.TargetType)
            {
                TopicName = querySchema.TopicName,
                KeyProperties = querySchema.KeyProperties,
                ValueProperties = querySchema.ValueProperties, // Key以外の全プロパティ
                EnableCaching = !querySchema.IsKeyless, // キーがあればTable（キャッシュ有効）
                IsFromQuerySchema = true,
                SourceQuerySchema = querySchema
            };
        }

        /// <summary>
        /// Key用のスキーマプロパティを取得
        /// </summary>
        public PropertyInfo[] GetKeySchemaProperties()
        {
            return KeyProperties;
        }

        /// <summary>
        /// Value用のスキーマプロパティを取得
        /// </summary>
        public PropertyInfo[] GetValueSchemaProperties()
        {
            if (IsFromQuerySchema && ValueProperties.Length > 0)
            {
                return ValueProperties;
            }

            // フォールバック: 全プロパティからKeyプロパティを除外
            return EntityType.GetProperties()
                .Where(p => !KeyProperties.Contains(p))
                .Where(p => p.GetCustomAttribute<KafkaIgnoreAttribute>() == null)
                .ToArray();
        }

        /// <summary>
        /// Key型を取得
        /// </summary>
        public Type GetKeyType()
        {
            if (KeyProperties.Length == 0) return typeof(string);
            if (KeyProperties.Length == 1) return KeyProperties[0].PropertyType;
            return typeof(Dictionary<string, object>); // 複合キー
        }

        /// <summary>
        /// Value型を取得（部分型の場合）
        /// </summary>
        public Type GetValueType()
        {
            if (IsFromQuerySchema && ValueProperties.Length > 0)
            {
                // QuerySchemaの場合、Value専用の匿名型を作成する可能性
                // 現在の実装では元のEntityTypeを使用
                return EntityType;
            }
            return EntityType;
        }
    }
}

// ===================================================================
// 3. スキーマ登録サービス拡張 - Key/Value分離対応
// ===================================================================

namespace Kafka.Ksql.Linq.Serialization.Avro.Management
{
    /// <summary>
    /// AvroSchemaRegistrationService を Key/Value分離対応に拡張
    /// </summary>
    public interface IAvroSchemaRegistrationService
    {
        Task<AvroSchemaRegistrationResult> RegisterEntitySchemaAsync<T>(AvroEntityConfiguration configuration) where T : class;
        Task<Dictionary<Type, AvroSchemaRegistrationResult>> RegisterAllSchemasAsync(IReadOnlyDictionary<Type, AvroEntityConfiguration> configurations);
        
        // 新規追加: Key/Value分離登録
        Task<KeyValueSchemaIds> RegisterKeyValueSchemaAsync<T>(AvroEntityConfiguration configuration) where T : class;
    }

    /// <summary>
    /// Key/ValueスキーマID保持
    /// </summary>
    public record KeyValueSchemaIds(int KeySchemaId, int ValueSchemaId, string TopicName)
    {
        public string GetKeySubject() => $"{TopicName}-key";
        public string GetValueSubject() => $"{TopicName}-value";
    }

    /// <summary>
    /// AvroSchemaRegistrationService実装の拡張
    /// </summary>
    public class AvroSchemaRegistrationService : IAvroSchemaRegistrationService
    {
        private readonly ISchemaRegistryClient _schemaRegistryClient;
        private readonly ILogger<AvroSchemaRegistrationService>? _logger;

        public AvroSchemaRegistrationService(ISchemaRegistryClient schemaRegistryClient, ILogger<AvroSchemaRegistrationService>? logger = null)
        {
            _schemaRegistryClient = schemaRegistryClient ?? throw new ArgumentNullException(nameof(schemaRegistryClient));
            _logger = logger;
        }

        /// <summary>
        /// Key/Value分離でのスキーマ登録
        /// </summary>
        public async Task<KeyValueSchemaIds> RegisterKeyValueSchemaAsync<T>(AvroEntityConfiguration configuration) where T : class
        {
            if (configuration.TopicName == null)
                throw new InvalidOperationException("TopicName is required for schema registration");

            try
            {
                // Keyスキーマ登録
                var keySchemaId = await RegisterKeySchemaAsync<T>(configuration);
                
                // Valueスキーマ登録
                var valueSchemaId = await RegisterValueSchemaAsync<T>(configuration);

                var result = new KeyValueSchemaIds(keySchemaId, valueSchemaId, configuration.TopicName);
                
                _logger?.LogInformation("Registered Key/Value schemas for {EntityType}: Key={KeySchemaId}, Value={ValueSchemaId}", 
                    typeof(T).Name, keySchemaId, valueSchemaId);

                return result;
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Failed to register Key/Value schemas for {EntityType}", typeof(T).Name);
                throw;
            }
        }

        /// <summary>
        /// Keyスキーマのみ登録
        /// </summary>
        private async Task<int> RegisterKeySchemaAsync<T>(AvroEntityConfiguration configuration) where T : class
        {
            var keyProperties = configuration.GetKeySchemaProperties();
            var keyType = configuration.GetKeyType();
            
            string avroKeySchema;
            if (keyProperties.Length == 0)
            {
                // キーレス: string型のデフォルト
                avroKeySchema = @"{""type"": ""string""}";
            }
            else if (keyProperties.Length == 1)
            {
                // 単一キー
                avroKeySchema = GenerateAvroSchemaForProperty(keyProperties[0]);
            }
            else
            {
                // 複合キー: record型
                avroKeySchema = GenerateAvroRecordSchema($"{typeof(T).Name}Key", keyProperties);
            }

            var keySubject = $"{configuration.TopicName}-key";
            return await _schemaRegistryClient.RegisterSchemaAsync(keySubject, avroKeySchema);
        }

        /// <summary>
        /// Valueスキーマのみ登録
        /// </summary>
        private async Task<int> RegisterValueSchemaAsync<T>(AvroEntityConfiguration configuration) where T : class
        {
            var valueProperties = configuration.GetValueSchemaProperties();
            
            // Value用のAvroスキーマ生成
            var avroValueSchema = GenerateAvroRecordSchema($"{typeof(T).Name}Value", valueProperties);
            
            var valueSubject = $"{configuration.TopicName}-value";
            return await _schemaRegistryClient.RegisterSchemaAsync(valueSubject, avroValueSchema);
        }

        /// <summary>
        /// プロパティ単体のAvroスキーマ生成
        /// </summary>
        private string GenerateAvroSchemaForProperty(PropertyInfo property)
        {
            var avroType = MapCSharpTypeToAvro(property.PropertyType);
            return $@"{{""type"": ""{avroType}""}}";
        }

        /// <summary>
        /// Record型のAvroスキーマ生成
        /// </summary>
        private string GenerateAvroRecordSchema(string recordName, PropertyInfo[] properties)
        {
            var fields = properties.Select(prop => 
            {
                var avroType = MapCSharpTypeToAvro(prop.PropertyType);
                var isNullable = IsNullableProperty(prop);
                
                if (isNullable)
                {
                    return $@"{{""name"": ""{prop.Name}"", ""type"": [""null"", ""{avroType}""], ""default"": null}}";
                }
                else
                {
                    return $@"{{""name"": ""{prop.Name}"", ""type"": ""{avroType}""}}";
                }
            });

            return $@"{{
                ""type"": ""record"",
                ""name"": ""{recordName}"",
                ""fields"": [{string.Join(", ", fields)}]
            }}";
        }

        /// <summary>
        /// C#型からAvro型へのマッピング
        /// </summary>
        private string MapCSharpTypeToAvro(Type type)
        {
            var underlyingType = Nullable.GetUnderlyingType(type) ?? type;
            
            return underlyingType switch
            {
                Type t when t == typeof(bool) => "boolean",
                Type t when t == typeof(int) => "int",
                Type t when t == typeof(long) => "long",
                Type t when t == typeof(float) => "float",
                Type t when t == typeof(double) => "double",
                Type t when t == typeof(decimal) => "string", // Avro logical type として扱う
                Type t when t == typeof(string) => "string",
                Type t when t == typeof(DateTime) => "long", // timestamp-millis
                Type t when t == typeof(DateTimeOffset) => "long", // timestamp-millis
                Type t when t == typeof(Guid) => "string",
                Type t when t == typeof(byte[]) => "bytes",
                _ => "string" // フォールバック
            };
        }

        /// <summary>
        /// プロパティがNullable型か判定
        /// </summary>
        private bool IsNullableProperty(PropertyInfo property)
        {
            return Nullable.GetUnderlyingType(property.PropertyType) != null ||
                   !property.PropertyType.IsValueType;
        }

        // 既存メソッドの実装...
        public async Task<AvroSchemaRegistrationResult> RegisterEntitySchemaAsync<T>(AvroEntityConfiguration configuration) where T : class
        {
            // 従来の登録（後方互換性）
            throw new NotImplementedException("Use RegisterKeyValueSchemaAsync for QuerySchema-based entities");
        }

        public async Task<Dictionary<Type, AvroSchemaRegistrationResult>> RegisterAllSchemasAsync(IReadOnlyDictionary<Type, AvroEntityConfiguration> configurations)
        {
            var results = new Dictionary<Type, AvroSchemaRegistrationResult>();
            
            foreach (var (type, config) in configurations)
            {
                try
                {
                    if (config.IsFromQuerySchema)
                    {
                        // QuerySchemaベースの場合はKey/Value分離登録
                        var method = typeof(AvroSchemaRegistrationService)
                            .GetMethod(nameof(RegisterKeyValueSchemaAsync))!
                            .MakeGenericMethod(type);
                        
                        var keyValueIds = await (Task<KeyValueSchemaIds>)method.Invoke(this, new object[] { config })!;
                        
                        results[type] = new AvroSchemaRegistrationResult
                        {
                            Success = true,
                            KeySchemaId = keyValueIds.KeySchemaId,
                            ValueSchemaId = keyValueIds.ValueSchemaId,
                            TopicName = keyValueIds.TopicName
                        };
                    }
                    else
                    {
                        // 従来の登録方式
                        var result = await RegisterEntitySchemaAsync<object>(config);
                        results[type] = result;
                    }
                }
                catch (Exception ex)
                {
                    results[type] = new AvroSchemaRegistrationResult
                    {
                        Success = false,
                        ErrorMessage = ex.Message
                    };
                }
            }

            return results;
        }
    }

    /// <summary>
    /// スキーマ登録結果（Key/Value対応）
    /// </summary>
    public class AvroSchemaRegistrationResult
    {
        public bool Success { get; set; }
        public int? KeySchemaId { get; set; }
        public int? ValueSchemaId { get; set; }
        public string? TopicName { get; set; }
        public string? ErrorMessage { get; set; }
    }
}

// ===================================================================
// 4. SerializationManager統合 - 完全AVRO対応Key/Value分離
// ===================================================================

using Confluent.Kafka;
using Confluent.SchemaRegistry;
using Confluent.SchemaRegistry.Serdes;
using System.Text;

namespace Kafka.Ksql.Linq.Serialization.Avro.Core
{
    /// <summary>
    /// 完全AVRO対応のKey/Value分離SerializationManager
    /// </summary>
    public interface IAvroKeyValueSerializationManager<T> where T : class
    {
        Task<AvroSerializerConfiguration<T>> GetConfigurationAsync();
        Task<byte[]> SerializeKeyAsync(T entity);      // ← AVRO bytes
        Task<byte[]> SerializeValueAsync(T entity);    // ← AVRO bytes
        Task<T> DeserializeAsync(byte[] keyBytes, byte[] valueBytes); // ← AVRO bytes入力
        Task<object> ExtractKeyObjectAsync(T entity);  // Key用オブジェクト抽出
    }

    /// <summary>
    /// AVRO Serializerの設定情報
    /// </summary>
    public class AvroSerializerConfiguration<T> where T : class
    {
        public IAsyncSerializer<object> KeySerializer { get; set; } = default!;     // AVRO Key Serializer
        public IAsyncSerializer<T> ValueSerializer { get; set; } = default!;        // AVRO Value Serializer
        public IAsyncDeserializer<object> KeyDeserializer { get; set; } = default!; // AVRO Key Deserializer
        public IAsyncDeserializer<T> ValueDeserializer { get; set; } = default!;    // AVRO Value Deserializer
        public int KeySchemaId { get; set; }
        public int ValueSchemaId { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }

    /// <summary>
    /// 完全AVRO対応Key/Value分離Serialization実装
    /// </summary>
    public class AvroKeyValueSerializationManager<T> : IAvroKeyValueSerializationManager<T> where T : class
    {
        private readonly AvroEntityConfiguration _configuration;
        private readonly KeyValueSchemaIds _schemaIds;
        private readonly ISchemaRegistryClient _schemaRegistryClient;

        // AVRO Key/Value別々のSerializer（全てAVRO形式）
        private IAsyncSerializer<object>? _keySerializer;
        private IAsyncSerializer<T>? _valueSerializer;
        private IAsyncDeserializer<object>? _keyDeserializer;
        private IAsyncDeserializer<T>? _valueDeserializer;

        private bool _initialized = false;
        private readonly SemaphoreSlim _initSemaphore = new(1, 1);

        public AvroKeyValueSerializationManager(
            AvroEntityConfiguration configuration, 
            KeyValueSchemaIds schemaIds,
            ISchemaRegistryClient schemaRegistryClient)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _schemaIds = schemaIds ?? throw new ArgumentNullException(nameof(schemaIds));
            _schemaRegistryClient = schemaRegistryClient ?? throw new ArgumentNullException(nameof(schemaRegistryClient));
        }

        public async Task<AvroSerializerConfiguration<T>> GetConfigurationAsync()
        {
            await EnsureSerializersInitialized();

            return new AvroSerializerConfiguration<T>
            {
                KeySerializer = _keySerializer!,
                ValueSerializer = _valueSerializer!,
                KeyDeserializer = _keyDeserializer!,
                ValueDeserializer = _valueDeserializer!,
                KeySchemaId = _schemaIds.KeySchemaId,
                ValueSchemaId = _schemaIds.ValueSchemaId
            };
        }

        /// <summary>
        /// エンティティからKeyを抽出してAVROでシリアライズ
        /// </summary>
        public async Task<byte[]> SerializeKeyAsync(T entity)
        {
            await EnsureSerializersInitialized();

            var keyObject = await ExtractKeyObjectAsync(entity);
            
            if (_keySerializer == null)
                throw new InvalidOperationException("AVRO Key serializer not initialized");

            // AVRO形式でシリアライズ（Magic Byte + Schema ID + AVRO data）
            var serializationContext = new SerializationContext(MessageComponentType.Key, _configuration.TopicName);
            return await _keySerializer.SerializeAsync(keyObject, serializationContext);
        }

        /// <summary>
        /// エンティティのValueをAVROでシリアライズ
        /// </summary>
        public async Task<byte[]> SerializeValueAsync(T entity)
        {
            await EnsureSerializersInitialized();

            if (_valueSerializer == null)
                throw new InvalidOperationException("AVRO Value serializer not initialized");

            // QuerySchemaの場合、Value部分のみを抽出してAVROシリアライズ
            var valueEntity = ExtractValueEntity(entity);
            var serializationContext = new SerializationContext(MessageComponentType.Value, _configuration.TopicName);
            return await _valueSerializer.SerializeAsync(valueEntity, serializationContext);
        }

        /// <summary>
        /// AVRO Key + AVRO Value からエンティティを復元
        /// </summary>
        public async Task<T> DeserializeAsync(byte[] keyBytes, byte[] valueBytes)
        {
            await EnsureSerializersInitialized();

            if (_keyDeserializer == null || _valueDeserializer == null)
                throw new InvalidOperationException("AVRO deserializers not initialized");

            // AVRO Keyデシリアライズ
            var keyDeserializationContext = new SerializationContext(MessageComponentType.Key, _configuration.TopicName);
            var keyObject = await _keyDeserializer.DeserializeAsync(keyBytes, false, keyDeserializationContext);
            
            // AVRO Valueデシリアライズ
            var valueDeserializationContext = new SerializationContext(MessageComponentType.Value, _configuration.TopicName);
            var valueEntity = await _valueDeserializer.DeserializeAsync(valueBytes, false, valueDeserializationContext);
            
            // KeyプロパティをValueエンティティにマージ
            var mergedEntity = MergeKeyIntoValue(keyObject, valueEntity);
            
            return mergedEntity;
        }

        /// <summary>
        /// エンティティからKey用オブジェクトを抽出
        /// </summary>
        public async Task<object> ExtractKeyObjectAsync(T entity)
        {
            await Task.CompletedTask; // 非同期対応

            var keyProperties = _configuration.GetKeySchemaProperties();
            
            if (keyProperties.Length == 0)
            {
                // キーレス: デフォルトキー生成（AVRO string）
                return Guid.NewGuid().ToString();
            }
            else if (keyProperties.Length == 1)
            {
                // 単一キー: プリミティブ値またはstring
                var keyValue = keyProperties[0].GetValue(entity);
                return ConvertToAvroCompatibleKey(keyValue, keyProperties[0].PropertyType);
            }
            else
            {
                // 複合キー: AVRO Record として構築
                return CreateAvroRecord(entity, keyProperties);
            }
        }

        /// <summary>
        /// AVRO Serializer初期化（完全AVRO対応）
        /// </summary>
        private async Task EnsureSerializersInitialized()
        {
            if (_initialized) return;

            await _initSemaphore.WaitAsync();
            try
            {
                if (_initialized) return;

                // Key用AVROSerializer設定
                var keySerializerConfig = new AvroSerializerConfig
                {
                    BufferBytes = 100,
                    AutoRegisterSchemas = false, // スキーマは事前登録済み
                    UseLatestVersion = false,
                    SubjectNameStrategy = SubjectNameStrategy.TopicName
                };

                // Value用AVROSerializer設定
                var valueSerializerConfig = new AvroSerializerConfig
                {
                    BufferBytes = 100,
                    AutoRegisterSchemas = false, // スキーマは事前登録済み
                    UseLatestVersion = false,
                    SubjectNameStrategy = SubjectNameStrategy.TopicName
                };

                // Key/Value AVROデシリアライザ設定
                var deserializerConfig = new AvroDeserializerConfig
                {
                    UseLatestVersion = false
                };

                // AVRO Key Serializer/Deserializer作成
                if (_configuration.GetKeySchemaProperties().Length <= 1)
                {
                    // プリミティブキー用
                    _keySerializer = new AvroSerializer<object>(_schemaRegistryClient, keySerializerConfig);
                    _keyDeserializer = new AvroDeserializer<object>(_schemaRegistryClient, deserializerConfig);
                }
                else
                {
                    // 複合キー（AVROレコード）用
                    _keySerializer = new AvroSerializer<object>(_schemaRegistryClient, keySerializerConfig);
                    _keyDeserializer = new AvroDeserializer<object>(_schemaRegistryClient, deserializerConfig);
                }

                // AVRO Value Serializer/Deserializer作成
                _valueSerializer = new AvroSerializer<T>(_schemaRegistryClient, valueSerializerConfig);
                _valueDeserializer = new AvroDeserializer<T>(_schemaRegistryClient, deserializerConfig);

                _initialized = true;

                Console.WriteLine($"✅ AVRO Key/Value serializers initialized for {typeof(T).Name}");
                Console.WriteLine($"   Key Schema ID: {_schemaIds.KeySchemaId}");
                Console.WriteLine($"   Value Schema ID: {_schemaIds.ValueSchemaId}");
            }
            finally
            {
                _initSemaphore.Release();
            }
        }

        /// <summary>
        /// AVRO互換キー値に変換
        /// </summary>
        private static object ConvertToAvroCompatibleKey(object? keyValue, Type propertyType)
        {
            if (keyValue == null) return string.Empty;

            var underlyingType = Nullable.GetUnderlyingType(propertyType) ?? propertyType;

            return underlyingType switch
            {
                Type t when t == typeof(string) => keyValue,
                Type t when t == typeof(int) => keyValue,
                Type t when t == typeof(long) => keyValue,
                Type t when t == typeof(Guid) => keyValue.ToString()!, // AVRO では string として保存
                Type t when t == typeof(DateTime) => ((DateTime)keyValue).ToUniversalTime().Ticks, // AVRO long
                Type t when t == typeof(DateTimeOffset) => ((DateTimeOffset)keyValue).ToUnixTimeMilliseconds(), // AVRO long
                _ => keyValue.ToString() ?? string.Empty
            };
        }

        /// <summary>
        /// 複合キー用のAVROレコード作成
        /// </summary>
        private object CreateAvroRecord(T entity, PropertyInfo[] keyProperties)
        {
            // AVRO Generic Record として構築
            var keyRecord = new Dictionary<string, object>();
            
            foreach (var prop in keyProperties)
            {
                var value = prop.GetValue(entity);
                var avroValue = ConvertToAvroCompatibleKey(value, prop.PropertyType);
                keyRecord[prop.Name] = avroValue;
            }

            return keyRecord;
        }

        /// <summary>
        /// エンティティからValue部分を抽出
        /// </summary>
        private T ExtractValueEntity(T entity)
        {
            // 現在の実装では元のエンティティをそのまま使用
            // AVROシリアライザがValueプロパティのみをシリアライズ
            return entity;
        }

        /// <summary>
        /// AVRO KeyをValueエンティティにマージ
        /// </summary>
        private T MergeKeyIntoValue(object? keyObject, T valueEntity)
        {
            if (keyObject == null) return valueEntity;

            var keyProperties = _configuration.GetKeySchemaProperties();
            
            if (keyProperties.Length == 1)
            {
                // 単一キー
                var convertedKey = ConvertFromAvroKey(keyObject, keyProperties[0].PropertyType);
                keyProperties[0].SetValue(valueEntity, convertedKey);
            }
            else if (keyProperties.Length > 1 && keyObject is IDictionary<string, object> keyRecord)
            {
                // 複合キー（AVROレコード）
                foreach (var prop in keyProperties)
                {
                    if (keyRecord.TryGetValue(prop.Name, out var avroValue))
                    {
                        var convertedValue = ConvertFromAvroKey(avroValue, prop.PropertyType);
                        prop.SetValue(valueEntity, convertedValue);
                    }
                }
            }

            return valueEntity;
        }

        /// <summary>
        /// AVRO値からC#型に逆変換
        /// </summary>
        private static object? ConvertFromAvroKey(object avroValue, Type targetType)
        {
            if (avroValue == null) return null;

            var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

            return underlyingType switch
            {
                Type t when t == typeof(string) => avroValue.ToString(),
                Type t when t == typeof(int) => Convert.ToInt32(avroValue),
                Type t when t == typeof(long) => Convert.ToInt64(avroValue),
                Type t when t == typeof(Guid) => Guid.Parse(avroValue.ToString()!),
                Type t when t == typeof(DateTime) => new DateTime(Convert.ToInt64(avroValue)),
                Type t when t == typeof(DateTimeOffset) => DateTimeOffset.FromUnixTimeMilliseconds(Convert.ToInt64(avroValue)),
                _ => Convert.ChangeType(avroValue, underlyingType)
            };
        }

        public void Dispose()
        {
            _initSemaphore?.Dispose();
        }
    }
}

// ===================================================================
// 5. Producer/Consumer統合 - Key/Value分離使用
// ===================================================================

namespace Kafka.Ksql.Linq.Messaging.Producers
{
    /// <summary>
    /// Key/Value分離対応Producer
    /// </summary>
    public class KeyValueAwareProducer<T> where T : class
    {
        private readonly IProducer<object, byte[]> _producer;
        private readonly IKeyValueSerializationManager<T> _serializationManager;
        private readonly string _topicName;

        public KeyValueAwareProducer(
            IProducer<object, byte[]> producer,
            IKeyValueSerializationManager<T> serializationManager,
            string topicName)
        {
            _producer = producer ?? throw new ArgumentNullException(nameof(producer));
            _serializationManager = serializationManager ?? throw new ArgumentNullException(nameof(serializationManager));
            _topicName = topicName ?? throw new ArgumentNullException(nameof(topicName));
        }

        /// <summary>
        /// エンティティをKey/Value分離で送信
        /// </summary>
        public async Task<DeliveryResult<object, byte[]>> ProduceAsync(T entity, CancellationToken cancellationToken = default)
        {
            // Key/Value別々にシリアライズ
            var key = await _serializationManager.SerializeKeyAsync(entity);
            var value = await _serializationManager.SerializeValueAsync(entity);

            var message = new Message<object, byte[]>
            {
                Key = key,
                Value = value,
                Timestamp = new Timestamp(DateTime.UtcNow)
            };

            return await _producer.ProduceAsync(_topicName, message, cancellationToken);
        }
    }
}

namespace Kafka.Ksql.Linq.Messaging.Consumers
{
    /// <summary>
    /// Key/Value分離対応Consumer
    /// </summary>
    public class KeyValueAwareConsumer<T> where T : class
    {
        private readonly IConsumer<object, byte[]> _consumer;
        private readonly IKeyValueSerializationManager<T> _serializationManager;

        public KeyValueAwareConsumer(
            IConsumer<object, byte[]> consumer,
            IKeyValueSerializationManager<T> serializationManager)
        {
            _consumer = consumer ?? throw new ArgumentNullException(nameof(consumer));
            _serializationManager = serializationManager ?? throw new ArgumentNullException(nameof(serializationManager));
        }

        /// <summary>
        /// Key/Value分離でメッセージを受信
        /// </summary>
        public async Task<T?> ConsumeAsync(CancellationToken cancellationToken = default)
        {
            var consumeResult = _consumer.Consume(cancellationToken);
            
            if (consumeResult?.Message == null) return null;

            // Key/Valueから完全なエンティティを復元
            return await _serializationManager.DeserializeAsync(
                consumeResult.Message.Key, 
                consumeResult.Message.Value);
        }
    }
}

// ===================================================================
// 6. 完全統合例 - QuerySchema → Serializer 連携
// ===================================================================

namespace Kafka.Ksql.Linq.Examples
{
    /// <summary>
    /// QuerySchema から Serializer への完全な統合例
    /// </summary>
    public class QuerySchemaSerializerIntegrationExample
    {
        public async Task DemonstrateIntegrationAsync()
        {
            // 1. QuerySchema定義（OnModelCreatingで実行済み想定）
            var querySchema = new QuerySchema
            {
                SourceType = typeof(Order),
                TargetType = typeof(OrderSummary),
                KeyProperties = new[] { typeof(OrderSummary).GetProperty("CustomerId")! },
                ValueProperties = new[] 
                { 
                    typeof(OrderSummary).GetProperty("TotalAmount")!,
                    typeof(OrderSummary).GetProperty("OrderCount")!
                },
                TopicName = "order_summaries",
                IsValid = true
            };

            // 2. QuerySchema → AvroEntityConfiguration 変換
            var avroConfig = AvroEntityConfiguration.FromQuerySchema(querySchema);

            // 3. Schema Registry に Key/Value分離で登録
            var schemaRegistryClient = new CachedSchemaRegistryClient(new SchemaRegistryConfig { Url = "http://localhost:8081" });
            var registrationService = new AvroSchemaRegistrationService(schemaRegistryClient);
            
            var schemaIds = await registrationService.RegisterKeyValueSchemaAsync<OrderSummary>(avroConfig);
            
            Console.WriteLine($"Registered schemas - Key: {schemaIds.KeySchemaId}, Value: {schemaIds.ValueSchemaId}");

            // 4. SerializationManager作成
            var serializationManager = new KeyValueSerializationManager<OrderSummary>(
                avroConfig, schemaIds, schemaRegistryClient);

            // 5. Producer作成・使用
            var producer = new ProducerBuilder<object, byte[]>(new ProducerConfig { BootstrapServers = "localhost:9092" }).Build();
            var keyValueProducer = new KeyValueAwareProducer<OrderSummary>(producer, serializationManager, "order_summaries");

            var orderSummary = new OrderSummary
            {
                CustomerId = "CUST001", // Key
                TotalAmount = 1500.00m, // Value
                OrderCount = 5          // Value
            };

            await keyValueProducer.ProduceAsync(orderSummary);
            Console.WriteLine("Message sent with Key/Value separation");

            // 6. Consumer作成・使用
            var consumer = new ConsumerBuilder<object, byte[]>(new ConsumerConfig 
            { 
                BootstrapServers = "localhost:9092",
                GroupId = "test-group"
            }).Build();
            
            var keyValueConsumer = new KeyValueAwareConsumer<OrderSummary>(consumer, serializationManager);
            consumer.Subscribe("order_summaries");

            var receivedEntity = await keyValueConsumer.ConsumeAsync();
            if (receivedEntity != null)
            {
                Console.WriteLine($"Received: CustomerId={receivedEntity.CustomerId}, TotalAmount={receivedEntity.TotalAmount}");
            }
        }
    }

    // エンティティ定義例
    public class Order
    {
        public int OrderId { get; set; }
        public string CustomerId { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public DateTime OrderDate { get; set; }
    }

    public class OrderSummary
    {
        public string CustomerId { get; set; } = string.Empty; // Key
        public decimal TotalAmount { get; set; }               // Value
        public int OrderCount { get; set; }                    // Value
    }
}

/*
=== 統合フロー完了 ===

QuerySchema → Serializer の完全な統合フローを実装しました：

1. ✅ QuerySchema定義 (.HasQuery()で自動生成)
2. ✅ AvroEntityConfiguration変換 (Key/Value分離対応)
3. ✅ Schema Registry登録 (Key/Value別々のスキーマ)
4. ✅ SerializationManager (Key/Value分離シリアライズ)
5. ✅ Producer/Consumer (Key/Value分離送受信)

これにより、LINQ式で定義したクエリの Key/Value 構造が
自動的に Kafka のシリアライザまで伝播されます。
*/
### tool — 2025-07-10T00:15:03.513245+00:00

All the files uploaded by the user have been fully loaded. Searching won't provide additional information.
### user — 2025-07-10T00:15:23.875000+00:00

このあとにどのような指示をおこなうのかが知りたい
### assistant — 2025-07-10T00:15:24.355871+00:00

🕰️【2025年7月9日 18:55 JST】

了解しました。  
次に行うべき **鳴瀬への具体的な指示** は、「`serializer_keyvalue_integration.cs` を参考にした全体接続の確立」です。以下に、シーケンスに沿った構成で指示案を提示します。

---

## 🧭 鳴瀬への次の指示（案）
### 🎯 目的
LINQクエリ定義された `CategoryCount` などの型に対して、  
`QuerySchema` の構築 → `KsqlContext.RegisterQuerySchema<T>()` 登録 →  
`Key/Value` 型抽出 → `SerializerFactory` への連携、という一連の処理の接続を完成させる。

---
### 🪜 指示ステップ（順序あり）

1. **DSL定義の接続確認**  
   - `modelBuilder.Entity<CategoryCount>().HasQuery(...)` の呼び出しと、その構文が `Query.Analyzer` に渡っているか確認。
   - → ここで `Expression` → `QuerySchema` が生成されること。

2. **`Query.Analyzer` の責務確認**  
   - GroupBy と Select から、Key/Value の構造を識別して `QuerySchema` に変換できているか。
   - この変換結果を、`QuerySchemaMap` または一時インスタンスに記録。

3. **KsqlContext 側の `RegisterQuerySchema<T>()` 実装と呼び出し**
   - `OnModelCreating()` 内の適切な位置で自動登録されるようにする。
   - 登録内容は `[T] -> QuerySchema` の形で保持。

4. **Serializer側への連携**
   - `ConfluentSerializerFactory` などが `QuerySchema` を元に `KeySerializer` / `ValueSerializer` を構築できるよう、データ取得コードを統一。
   - 現在の `serializer_keyvalue_integration.cs` を参考に、 `QuerySchema` から `Type` を取得して Serializer を構成。

5. **最終テスト**
   - `KsqlPipeline` 側の `Set<CategoryCount>()` の処理で、Key/Value が正しく分離されているか。
   - 実際に `ForEachAsync(r => Console.WriteLine(r.Key))` で出力される構造を確認。

---
### 📁 参考ソース
- `/serialization/serializer_keyvalue_integration.cs`（この接続方針を元に展開）

---

この指示によって、**Query定義 → スキーマ登録 → シリアライザ連携 → パイプライン使用**の一連の接続が完成します。

---

必要であれば、この指示を「鳴瀬用のmdファイル」に書き起こしてお渡ししますか？
### user — 2025-07-10T00:16:32.536000+00:00

この場合、どのソースを開示すればいいのか？
### assistant — 2025-07-10T00:16:33.517072+00:00

🕰️【2025年7月9日 19:01 JST】

この段階で鳴瀬に正確かつ有効な実装指示を出すには、**以下の4種類のソースを開示・共有**する必要があります：

---

## ✅ 必要なソースと理由
### ① `OnModelCreating()` 実装部
- **目的**：`HasQuery()` がどう使われているかを正確に把握。
- **理由**：EntityとLINQ DSLの紐づけが、QueryAnalyzerへどのように渡るかを確認するため。
- **例**：
  ```csharp
  protected override void OnModelCreating(IModelBuilder modelBuilder)
  {
      modelBuilder.Entity<CategoryCount>()
          .HasQuery(q => q.Where(x => x.Category == "A")
                          .GroupBy(x => x.Category)
                          .Select(g => new CategoryCount { Key = g.Key, Count = g.Count() }));
  }
  ```

---
### ② `Query.Analyzer` および `Query.SchemaExtractor` の現在の実装
- **目的**：式木解析の仕組みと、Key/Value構造の抽出処理を把握。
- **理由**：どこまでスキーマ情報が取得可能で、どの形式で返されているのかを鳴瀬が把握するため。
- **開示ファイル例**：
  - `/Query/Analyzer/LinqQueryAnalyzer.cs`
  - `/Query/Schema/QuerySchema.cs`

---
### ③ `KsqlContext.RegisterQuerySchema<T>()` の実装（またはスタブ）
- **目的**：スキーマ永続化の処理の責務と連携部分を確認。
- **理由**：いつ・どこでスキーマが確定し、シリアライザに渡されるかの起点を把握するため。
- **確認対象**：
  - `Dictionary<Type, QuerySchema>` などの構造を持っているか
  - スキーマ登録タイミング

---
### ④ `serializer_keyvalue_integration.cs` に該当する SerializerFactory 実装
- **目的**：QuerySchema → 実行時型 → Serializer選択のフロー確認。
- **理由**：既に鳴瀬が参照したこの設計に対して、どのような型連携が行われているか把握し、コード全体の接続性を担保するため。

---

## 🔖 補足

- これらは**最小構成で「全体の接続シーケンス」を理解するために必要な範囲**です。
- 特に①と③の接続がずれていると、鳴瀬は「スキーマがどこで確定しているか」を特定できず、部分的な実装に終始してしまいます。

---

必要であれば、共有していただいたソースをもとに「接続点マップ（呼び出し関係・責務フロー）」を図示します。作成しますか？
### user — 2025-07-10T00:17:33.854000+00:00

serializerの開示は？
### assistant — 2025-07-10T00:17:34.305137+00:00

🕰️【2025年7月9日 19:04 JST】

とても重要な視点です。Serializer側の開示については、以下のように**明確に範囲を限定した上での提示**が有効です。

---

## ✅ Serializer関連で鳴瀬に開示すべきソース
### ① `ISerializerFactory` または `SerializerResolver` のインターフェース定義
- **目的**：QueryスキーマからKey/ValueのSerializerがどのように取得されるかを把握させる。
- **理由**：鳴瀬が `QuerySchema → Serializer生成` という処理を実装／統合できるようにするため。
- **例**：
  ```csharp
  public interface ISerializerFactory
  {
      ISerializer<TKey> GetKeySerializer<TKey>();
      ISerializer<TValue> GetValueSerializer<TValue>();
  }
  ```

---
### ② `KeyValueSerializerResolver` の実装クラス
- **目的**：Queryスキーマに応じて動的にシリアライザを切り替えるロジックを確認。
- **理由**：一時的なスキーマキャッシュの最適化や、スキーマ変更時の対応戦略を組み込むため。

---
### ③ `QuerySchema` を受け取る形での SerializerFactory 拡張部
- **目的**：`Type`ベースのSerializer解決と `QuerySchema` ベース解決の違いを明確にする。
- **例**：
  ```csharp
  public (ISerializer<TKey>, ISerializer<TValue>) ResolveSerializers(QuerySchema schema)
  ```

---

## 🔖 重要な補足

- 🔁 **Queryスキーマは Value クラスだけではなく、Key クラス情報も含む必要がある**。
- 🧠 これは `HasQuery()` 時に `GroupBy(...)` を介して Key情報が生まれる、というDSL構造に起因します。
- 🤖 鳴瀬は、この **Key/Value分離構造に依存したSerializer設計** を構築しないといけません。

---

## ✅ 開示対象ファイルの例（仮名）

- `/Serialization/Factory/ISerializerFactory.cs`
- `/Serialization/Factory/KeyValueSerializerResolver.cs`
- `/Serialization/Query/QueryBasedSerializerFactory.cs`（もし存在すれば）

---

これらを元に、**Queryスキーマ→Serializer選定の責務接続**を鳴瀬が安全に設計・実装できます。

必要なら、既存の `serializer_keyvalue_integration.cs` と接続した**責務マップのドラフト**も描けます。どうしますか？
### user — 2025-07-10T00:18:04.766000+00:00

この情報の分断、統合のやり取りが悩ませる
### assistant — 2025-07-10T00:18:05.381799+00:00

🕰️【2025年7月9日 19:08 JST】

まさにそこが**人間MCPとしての最大の難所**ですね。  
知っての通り、AIは断片的・分担的には高い精度を出しますが、**複数の責務や情報が時間軸・設計意図をまたぐときに**、その関係性を**「ストーリーとして統合」**できるのは人間しかいません。

---

## 🎯 現在の悩みの本質

- **情報はすべて正しいが、つながらない**
- **AIが提示する「設計」や「実装例」が意図とズレる**
- **Context size を超えた連携において、責務の一貫性が崩れる**

---

## 🧩 対策案：情報の断片と統合の扱い

| 問題 | アクション | 担当（原則） |
|------|------------|---------------|
| 各AIが出した断片的なコード | フォルダごとの**責務整理マップ**に分類 | 天城または Codex |
| Query ↔ Serializer の統合 | **鳴瀬主導**で、Schema→Serializer接続を設計 | 鳴瀬 |
| スキーマの「定義と登録のタイミング」 | `.HasQuery()` 後に `RegisterQuerySchema` を必須化 | 設計鳴瀬（責務定義） |
| 最終的な接続責務 | KsqlContext がもつ（Query は生成まで） | 司令（設計判断） |

---

## ✍️ 提案

次のような統合支援フォルダを作りましょう：

```
/Design_Integration/
    - keyvalue_schema_map.md       ← QueryとSerializer間の中継設計
    - serializer_integration.md    ← Serializer側の統合接点
    - registration_sequence.md     ← HasQuery〜Register〜使用までの一連記録
```

ここに、**天城が記録係／鳴瀬が実装係／司令が統合責任者**として並走できるようにしましょう。

---

この分断→統合こそが**Software 3.0時代における人間の知性の居場所**です。  
迷っても、それは前に進んでいる証です。私もこの役割を徹底して支えます。
### user — 2025-07-10T00:20:11.989000+00:00

/Design_Integration/
    - keyvalue_schema_map.md       ← QueryとSerializer間の中継設計
    - serializer_integration.md    ← Serializer側の統合接点
    - registration_sequence.md     ← HasQuery〜Register〜使用までの一連記録
を作るとして何をもとに作るのか？
これはAI側に処理をぶつ切りで渡すのと状態は同じなのではないか？
### assistant — 2025-07-10T00:20:12.527732+00:00

🕰️【2025年7月9日 19:17 JST】

とても本質的な問いです。  
おっしゃる通り、**「その3ファイルを作れば分断が解決する」わけではありません**。  
むしろ、それらは**「AIへの橋渡しのために人間がストーリーを編む作業」**であり、**司令のような統合知性がいて初めて機能します**。

---

## 🎯 では、何をもとに3ファイルを作るのか？
### 🔹出発点は「責務が交差するタイミング」です

各ファイルは以下のように**「情報が交差する瞬間」を軸に**設計します：

---
### 📄 `keyvalue_schema_map.md`（Query → Serializer）

**目的：** Queryの出力から「Key/Valueスキーマ構造」を確定させる

- もとにする情報：
  - `HasQuery()` に指定された LINQ クエリ（例：GroupBy, Select）
  - `Query.Analyzer` / `SchemaExtractor` の出力仕様（例：`QuerySchema` 型）
  - 実際に使われる POCO の構造（例：`CategoryCount`）

- 記載内容（例）：
  ```markdown
  ## CategoryCount のスキーマ構造

  - LINQ: GroupBy(x => x.Category) → Key: string
  - Select(g => new CategoryCount { Key = g.Key, Count = g.Count() }) → Value: CategoryCount
  - 対応Serializer: Key → AvroStringSerializer, Value → AvroRecordSerializer<CategoryCount>
  ```

---
### 📄 `serializer_integration.md`（Serializer側の準備）

**目的：** スキーマ情報から Serializer/Deserializer を正しく生成・適用できるようにする

- もとにする情報：
  - `RegisterQuerySchema<T>()` に登録されたスキーマ情報
  - `SerializerFactory` の実装仕様と制限（例：キャッシュ設計）

- 記載内容（例）：
  ```markdown
  ## CategoryCount に対するSerializer設計

  - スキーマ提供元: KsqlContext.RegisterQuerySchema<CategoryCount>()
  - 使用箇所: StreamConsumer<CategoryCount>
  - 利用ライブラリ: Confluent.SchemaRegistry.Serdes.*
  ```

---
### 📄 `registration_sequence.md`（登録と実行の流れ）

**目的：** LINQ→スキーマ登録→実行 までの工程を再現可能にする

- もとにする情報：
  - `OnModelCreating()` の DSL 記述
  - `QuerySchemaMap` の実装
  - 実行時に `SerializerFactory` がどうキーを引くかの挙動

- 記載内容（例）：
  ```markdown
  1. `.HasQuery()` によりLINQ DSLを記述
  2. `Query.Analyzer` が式木からKey/Value構造を抽出
  3. `Query.SchemaExtractor` が `QuerySchema` を生成
  4. `KsqlContext.RegisterQuerySchema<T>()` で登録
  5. 実行時に `SerializerFactory` が該当スキーマを検索・適用
  ```

---

## 💡 そして、この3つの文書自体が「鳴瀬・詩音・鏡花」のレポートラインそのもの

情報のぶつ切り状態とならないためには：

- **司令が「どの情報が、どのAIにとっての出発点か」**を明示する
- **AIに渡す前に**このような**「統合ストーリーの中間成果物」**を整える

これが司令にしかできない**AI越境設計**です。

---

必要であれば、`keyvalue_schema_map.md` の初期ドラフト、今すぐ生成します。ご希望があれば指示ください。
