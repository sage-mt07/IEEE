---
conversation_id: "679d99be-c288-8007-8b7b-8a467d3f7e98"
title: "Protobuf 型変換"
create_time: 1738381758.975711
update_time: 1738382346.082328
language_guess: "en"
num_messages: 14
part_index: 1
part_count: 1
---

### system — 2025-02-01T03:49:18.975711+00:00

_(empty)_

### user — 2025-02-01T03:49:18.983523+00:00

protobuf-netのprotobufとgrpcのprotobufの型の違いを吸収するコードをC#で書く

### tool — 2025-02-01T03:50:09.850588+00:00

**Piecing together differences**

I'm noting the user's request for a C# code snippet to abstract variations between protobuf types in protobuf-net and gRPC's protobuf, likely for unified message definitions and conversion.

**Navigating differences**

I'm taking a closer look at how protobuf-net and gRPC's protobuf vary, from attributes like [ProtoContract] in protobuf-net to generated classes in gRPC. Conversion code might bridge these gaps.

**Unafraid of the task**

I’m working through writing a C# code snippet to unify protobuf-net and gRPC's protobuf types, likely leveraging a shared interface, extension methods, or conditional compilation due to type definition differences.

**Thinking through conversions**

I’m exploring a custom type converter or wrapper interface to seamlessly translate between protobuf-net and gRPC protobuf models, considering differences in data formats, repeated fields, and version compatibility.

**Crafting bridging tools**

I’m piecing together bridging code to convert between gRPC-generated code and protobuf-net serialization, addressing differences like DateTimeOffset and Google.Protobuf.Timestamp, ensuring seamless integration.

**Implementing conversion methods**

I’m addressing the challenge of integrating protobuf-net and gRPC-generated classes by creating a unifying interface and adding extension methods or conversion functions for type harmony.

**Navigating type disparities**

I’m working through converting between ByteString and byte[], creating a common interface "IPerson", and adding extension methods to bridge the gap between gRPC and protobuf-net.

**Wrapping ByteString types**

I’m thinking through a type converter that wraps ByteString and byte[], ensuring seamless interoperation between gRPC and protobuf-net, while abstracting field type differences for easy integration.

**Bridging type gaps**

I'm thinking through integrating encodings with a common interface for serialization and deserialization, managing differences in enum representation, "UnknownFieldSet" handling, and default value handling between protobuf-net and gRPC.

**Aligning data types**

I'm detailing the use of a type converter to bridge ByteString and byte[], and focusing on aligning generics across platforms to ensure consistent data handling and serialization.

**Abstracting data handling**

Crafting an interface for consistent data manipulation, I suggest adapters for protobuf-net and gRPC, ensuring seamless integration across communication methods. This approach should enhance application consistency.

**Crafting adapters**

I’m developing adapters for protobuf-net and gRPC to standardize data handling through a unified interface, ensuring consistent serialization and deserialization across various data structures.

**Streamlining type conversions**

I’m thinking through helper methods for converting ByteString to byte[], aligning field type mappings between protobuf-net and gRPC, and leveraging a wrapper interface with adapter classes for consistent data handling.

**Opting for elegant methods**

I'm leaning towards a wrapper interface approach for addressing type differences. It seems more elegant than conditional compiler directives, and I aim to provide a complete sample code.

**Creating adaption protocols**

I’m outlining a unified interface for serialization and deserialization, ensuring seamless integration of protobuf-net and gRPC through distinct adapter classes for each, with careful handling of type-specific details.

**Crafting unified solutions**

I’m pulling together a sample code to cover key scenarios: wrapping protobuf libraries, type conversion methods, and adapting client code to select the productive adapter. Hm, that's interesting.

**Adapting with care**

I'm weighing the adapter interface method over direct type conversion for scalability. This avoids integration pain, even with nested types and repeated fields, enhancing maintainability.

**Integrating adaptation methods**

I’m working through integrating adapter classes for protobuf-net and gRPC, presenting a minimal sample code with a focus on serialization and deserialization examples.

**Balancing abstraction and conversion**

I’m honing a gRPC adapter to navigate serialization differences, while also exploring extension methods for seamless ByteString and byte[] conversions, balancing abstraction with data manipulation.

**Enhancing type conversion**

I’m working on byte conversions and exploring DateTime to Timestamp methods, aligning with gRPC needs and addressing type differences to streamline data manipulation.

**Navigating type mappings**

I'm pulling together mappings from protobuf-net to gRPC, covering raw bytes, timestamps, and repeated fields, while crafting the ProtobufTypeConverter class for seamless transitions.

**Mapping type conversions**

I'm working through the ProtobufTypeConverter class to efficiently handle type mappings between protobuf-net and gRPC, addressing raw bytes, timestamps, and repeated fields with clear comments for each conversion method.

**Pulling together conversion mechanics**

Wrapping up a C# file with adapter interfaces and type conversion methods, using essential protobuf and gRPC tools, and providing examples and comments to ensure clear understanding.

**Piecing together C# code**

I'm preparing a C# snippet to handle protobuf-net and gRPC type differences, featuring ProtobufAdabter and ProtobufTypeConverter classes, with detailed Japanese comments and sample usage.

**Integrating and converting**

Crafting a C# file with essential protobuf-net and gRPC tools, including an adapter interface and type conversion methods, showcases seamless integration and precise data manipulation.

### assistant — 2025-02-01T03:50:09.850717+00:00

以下は、protobuf‐net と gRPC（Google.Protobuf）の型やシリアライズ処理の違いを吸収する一例です。  
たとえば、以下のコードでは、

- **IProtobufAdapter\<T\> インターフェース**  
  → 型 T のメッセージをシリアライズ／デシリアライズする操作を抽象化しています。

- **ProtobufNetAdapter\<T\> / GrpcProtobufAdapter\<T\> クラス**  
  → それぞれ protobuf‐net と gRPC（Google.Protobuf）を用いた実装例です。  
    ※ gRPC側の場合、T は IMessage\<T\> を実装している必要があります。

- **ProtobufTypeConverter クラス**  
  → たとえば、byte[] と ByteString や DateTime と Timestamp など、両ライブラリ間で扱いが異なる型の相互変換ユーティリティを提供しています。

以下にサンプルコードを示します。

---

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using Google.Protobuf;
using Google.Protobuf.Collections;
using Google.Protobuf.WellKnownTypes;
using ProtoBuf;  // protobuf-net の属性・シリアライザー

namespace ProtobufAbstraction
{
    /// <summary>
    /// プロトコルバッファのシリアライズ／デシリアライズ処理を抽象化するためのインターフェース
    /// </summary>
    public interface IProtobufAdapter<T>
    {
        byte[] Serialize(T message);
        T Deserialize(byte[] data);
    }

    /// <summary>
    /// protobuf-net を使ったシリアライズ／デシリアライズの実装
    /// </summary>
    public class ProtobufNetAdapter<T> : IProtobufAdapter<T>
    {
        public byte[] Serialize(T message)
        {
            using (var ms = new MemoryStream())
            {
                Serializer.Serialize(ms, message);
                return ms.ToArray();
            }
        }

        public T Deserialize(byte[] data)
        {
            using (var ms = new MemoryStream(data))
            {
                return Serializer.Deserialize<T>(ms);
            }
        }
    }

    /// <summary>
    /// gRPC（Google.Protobuf）を使ったシリアライズ／デシリアライズの実装
    /// T は Google.Protobuf.IMessage<T> を実装している必要があります。
    /// </summary>
    public class GrpcProtobufAdapter<T> : IProtobufAdapter<T> where T : IMessage<T>, new()
    {
        public byte[] Serialize(T message)
        {
            return message.ToByteArray();
        }

        public T Deserialize(byte[] data)
        {
            T msg = new T();
            msg.MergeFrom(data);
            return msg;
        }
    }

    /// <summary>
    /// protobuf-net と gRPC の protobuf で扱いが異なる型（例：byte[]／ByteString, DateTime／Timestamp, RepeatedField など）の変換ユーティリティ
    /// </summary>
    public static class ProtobufTypeConverter
    {
        /// <summary>
        /// byte[] を Google.Protobuf.ByteString に変換
        /// </summary>
        public static ByteString ToByteString(byte[] data)
        {
            return ByteString.CopyFrom(data);
        }

        /// <summary>
        /// Google.Protobuf.ByteString を byte[] に変換
        /// </summary>
        public static byte[] ToByteArray(ByteString byteString)
        {
            return byteString.ToByteArray();
        }

        /// <summary>
        /// DateTime を Google.Protobuf.WellKnownTypes.Timestamp に変換
        /// (Timestamp.FromDateTime では UTC の DateTime を渡す必要があるので、ToUniversalTime() を呼んでいます)
        /// </summary>
        public static Timestamp ToTimestamp(DateTime dateTime)
        {
            return Timestamp.FromDateTime(dateTime.ToUniversalTime());
        }

        /// <summary>
        /// Google.Protobuf.WellKnownTypes.Timestamp を DateTime に変換
        /// </summary>
        public static DateTime ToDateTime(Timestamp timestamp)
        {
            return timestamp.ToDateTime();
        }

        /// <summary>
        /// IEnumerable<T> を Google.Protobuf.Collections.RepeatedField<T> に変換
        /// </summary>
        public static RepeatedField<T> ToRepeatedField<T>(IEnumerable<T> items)
        {
            var repeatedField = new RepeatedField<T>();
            repeatedField.Add(items);
            return repeatedField;
        }
    }

    // ────────────── 使用例 ──────────────

    // 【protobuf-net のメッセージ定義例】
    [ProtoContract]
    public class PersonNet
    {
        [ProtoMember(1)]
        public string Name { get; set; }
        [ProtoMember(2)]
        public int Age { get; set; }
    }

    // 【gRPC の protobuf のメッセージ定義例】
    // 通常は .proto ファイルから自動生成されますが、ここでは簡略化のため手動実装しています。
    public sealed partial class PersonGrpc : IMessage<PersonGrpc>
    {
        public string Name { get; set; } = "";
        public int Age { get; set; }

        // IMessage<T> の実装（最低限の例）
        public void MergeFrom(CodedInputStream input)
        {
            while (input.ReadTag() is uint tag && tag != 0)
            {
                switch (tag)
                {
                    case 10: // Field 1: string Name
                        Name = input.ReadString();
                        break;
                    case 16: // Field 2: int32 Age
                        Age = input.ReadInt32();
                        break;
                    default:
                        input.SkipLastField();
                        break;
                }
            }
        }

        public void WriteTo(CodedOutputStream output)
        {
            if (!string.IsNullOrEmpty(Name))
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (Age != 0)
            {
                output.WriteRawTag(16);
                output.WriteInt32(Age);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (!string.IsNullOrEmpty(Name))
            {
                size += 1 + CodedOutputStream.ComputeStringSize(Name);
            }
            if (Age != 0)
            {
                size += 1 + CodedOutputStream.ComputeInt32Size(Age);
            }
            return size;
        }

        // 本来は MessageDescriptor などのプロパティも必要ですが、ここでは省略しています。
        public MessageDescriptor Descriptor => null;

        public PersonGrpc Clone()
        {
            return new PersonGrpc { Name = this.Name, Age = this.Age };
        }

        public bool Equals(PersonGrpc other)
        {
            if (other == null) return false;
            return this.Name == other.Name && this.Age == other.Age;
        }

        public override bool Equals(object obj) => Equals(obj as PersonGrpc);
        public override int GetHashCode() => (Name, Age).GetHashCode();

        public void MergeFrom(PersonGrpc message)
        {
            if (message == null) return;
            if (!string.IsNullOrEmpty(message.Name))
                Name = message.Name;
            if (message.Age != 0)
                Age = message.Age;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // ■ protobuf-net のアダプターを使ったシリアライズ／デシリアライズの例
            IProtobufAdapter<PersonNet> netAdapter = new ProtobufNetAdapter<PersonNet>();
            var personNet = new PersonNet { Name = "Alice", Age = 30 };
            byte[] netData = netAdapter.Serialize(personNet);
            var personNetDeserialized = netAdapter.Deserialize(netData);
            Console.WriteLine($"protobuf-net: Name={personNetDeserialized.Name}, Age={personNetDeserialized.Age}");

            // ■ gRPC (Google.Protobuf) のアダプターを使った例
            IProtobufAdapter<PersonGrpc> grpcAdapter = new GrpcProtobufAdapter<PersonGrpc>();
            var personGrpc = new PersonGrpc { Name = "Bob", Age = 25 };
            byte[] grpcData = grpcAdapter.Serialize(personGrpc);
            var personGrpcDeserialized = grpcAdapter.Deserialize(grpcData);
            Console.WriteLine($"gRPC: Name={personGrpcDeserialized.Name}, Age={personGrpcDeserialized.Age}");

            // ■ ProtobufTypeConverter を使った型変換の例

            // byte[] ⇔ ByteString の変換
            byte[] rawBytes = { 1, 2, 3, 4 };
            ByteString byteString = ProtobufTypeConverter.ToByteString(rawBytes);
            byte[] bytesBack = ProtobufTypeConverter.ToByteArray(byteString);
            Console.WriteLine($"ByteString変換: {BitConverter.ToString(bytesBack)}");

            // DateTime ⇔ Timestamp の変換
            DateTime now = DateTime.Now;
            Timestamp timestamp = ProtobufTypeConverter.ToTimestamp(now);
            DateTime dateTimeBack = ProtobufTypeConverter.ToDateTime(timestamp);
            Console.WriteLine($"Timestamp変換: {dateTimeBack}");
        }
    }
}
```

---

### 解説

1. **アダプターインターフェースとその実装**  
   クライアントコードは `IProtobufAdapter<T>` 経由でシリアライズ／デシリアライズを行えば、内部で使うライブラリ（protobuf-net か gRPC の Google.Protobuf か）を意識する必要がなくなります。  
   例えば、gRPC のメッセージの場合は `GrpcProtobufAdapter<T>` を使えば、`IMessage<T>` インターフェースの `ToByteArray()` や `MergeFrom()` を利用して処理できます。

2. **型変換ユーティリティ**  
   プロトコルバッファでは、たとえば生のバイト配列は protobuf-net では単に `byte[]` として扱いますが、Google.Protobuf では `ByteString` 型で扱われます。  
   同様に、日時情報は protobuf-net 側では `DateTime`、gRPC 側では `Timestamp` で扱う場合があるため、その変換処理も用意しています。

このように、共通のインターフェースやユーティリティクラスを用意することで、protobuf-net と gRPC の protobuf 間の型の違いを吸収し、利用側では統一したインターフェースで処理できるようになります。

### user — 2025-02-01T03:50:55.671424+00:00

protobuf-netのdecimalを扱えるのか

### tool — 2025-02-01T03:51:15.978382+00:00

**Navigating protobuf-net's capabilities**

I’m noting that protobuf-net, designed for .NET, primarily encodes decimals as strings or bytes, compensating for Google's protobuf lack of decimal support.

**Confirming decimal support**

Protobuf-net, for .NET, does include decimal support, albeit with unique encoding structures. Native support is achieved through fixed representation type conversion.

**Understanding decimal nuances**

Yes, protobuf-net can handle decimals, but be aware of potential version issues and the use of surrogate types for precise serialization.

**Recognizing protobuf-net's limitations**

I'm noting that while protobuf-net natively supports decimal, it has precision and range limitations. Defaults revert to using strings or longs to encode decimals.

**Noticing serialization quirks**

While protobuf-net handles decimal for serialization and deserialization, issues might arise when generating a .proto file due to its non-native status in proto3. Adjustments are often necessary.

**Balancing serialization**

When integrating decimal with official protobuf libraries, using a surrogate type or a custom mapping ensures smooth data exchange, accommodating cross-platform compatibility.

**Facilitating cross-platform compatibility**

The sample code illustrates serialization with protobuf-net. For better cross-platform data exchange, using a surrogate type or custom mapping for decimal ensures seamless integration.

**Navigating type conversion**

I'm exploring how to convert decimal data between protobuf-net and gRPC. This involves serializing decimals as strings or bytes for seamless interoperation.

**Ensuring seamless compatibility**

I'm detailing how to serialize decimal for gRPC interoperation by converting it to a string or custom message, highlighting protobuf-net's native support and its cross-platform considerations.

**Understanding serialization**

protobuf-net handles decimal serialization by converting them to a fixed-size 128-bit structure, not merely to a string, ensuring efficient and accurate data representation.

**Ensuring seamless integration**

`protobuf-net` can serialize decimal types, but care is needed for interoperation with gRPC, as it lacks native decimal support. Use surrogates like strings or custom messages for interoperability.

### assistant — 2025-02-01T03:51:15.978514+00:00

protobuf-net は、.NET 環境向けのシリアライゼーションライブラリとして、`decimal` 型のシリアライズ／デシリアライズをサポートしています。  
具体的には、特別な設定やサロゲート（代替）型を用意することなく、以下のように `decimal` 型のプロパティを持つクラスをそのまま扱うことができます。

---

```csharp
using System;
using System.IO;
using ProtoBuf;

[ProtoContract]
public class Product
{
    [ProtoMember(1)]
    public int Id { get; set; }
    
    [ProtoMember(2)]
    public string Name { get; set; }
    
    // decimal 型もそのままシリアライズ可能
    [ProtoMember(3)]
    public decimal Price { get; set; }
}

class Program
{
    static void Main()
    {
        var product = new Product { Id = 1, Name = "Widget", Price = 12.34m };
        
        // シリアライズ
        using (var ms = new MemoryStream())
        {
            Serializer.Serialize(ms, product);
            byte[] data = ms.ToArray();
            
            // デシリアライズ
            using (var msRead = new MemoryStream(data))
            {
                var deserialized = Serializer.Deserialize<Product>(msRead);
                Console.WriteLine($"Id: {deserialized.Id}, Name: {deserialized.Name}, Price: {deserialized.Price}");
            }
        }
    }
}
```

---

### 注意点

- **.NET 内部での利用の場合**  
  上記のコードのように、.NET 環境内でのシリアライズ／デシリアライズには問題なく `decimal` を扱えます。protobuf-net は内部で `decimal` 型を適切に変換（エンコード）する仕組みを持っているため、追加の設定は不要です。

- **gRPC や他の言語との相互運用の場合**  
  Google の公式 Protocol Buffers 仕様（.proto ファイル）には `decimal` 型が存在しません。そのため、gRPC（Google.Protobuf）や他のプラットフォームとデータをやり取りする場合、`decimal` 型をそのまま送受信することはできません。  
  このような場合は、以下のような方法で対処します:
  - **サロゲート型を利用する:**  
    `decimal` を例えば `string`（文字列表現）や、固定小数点数を表現するカスタムメッセージ（整数部とスケールなどに分解する）に変換して送信し、受信側で再度 `decimal` に変換する方法があります。
  - **カスタムコンバータの実装:**  
    両ライブラリ間での型変換ユーティリティを用意し、`decimal` ⇔ 別の型（例：string や int64 と int32 の組み合わせなど）への変換処理を実装する方法も考えられます。

### まとめ

- **protobuf-net 単体で使用する場合:**  
  `decimal` 型はそのままシリアライズ／デシリアライズ可能です。

- **クロスプラットフォームや gRPC など他の実装との連携が必要な場合:**  
  `decimal` 型の扱いについては、互換性を考慮してサロゲート型やカスタムコンバータによる変換処理が必要になる場合があります。

以上の点に注意すれば、protobuf-net で `decimal` を扱うことに問題はありません。

### user — 2025-02-01T03:52:36.465478+00:00

protobuf-netのprotobufとgrpcのprotobufの型の違いを吸収するコードをC#で書く
これはdecimal,Datetimeoffsetの型を使えるものとする

### tool — 2025-02-01T03:54:02.093168+00:00

**Converting data types**

I’m gathering insights on how to convert decimal and DateTimeOffset data types in C# across protobuf-net and grpc. This involves creating a wrapper or scaler for seamless cross-library conversion.

**Choosing the best approach**

I’m working through options for converting decimal and DateTimeOffset between protobuf-net and grpc. Storing decimal as a string or double, or using protobuf-net's built-in decimal support, might be the way forward.

**Ensuring precision**

I'm curious about a custom adapter class to manage decimal and DateTimeOffset conversions for grpc protobuf. This approach balances precision and compatibility, aligning with the full precision requirements.

**Converting data**

OK, let's think it through: converting decimal to string and DateTimeOffset to google.protobuf.Timestamp, including the offset separately, to meet the requirements and ensure data integrity.

**Navigating serialization**

I'm setting up a custom adapter in C# to traverse differences between protobuf-net and grpc argmaps, particularly focusing on standardizing decimal and DateTimeOffset handling.

**Crafting the adapter**

I’m assembling an interface for serializing and deserializing decimal and DateTimeOffset, focusing on bridging protobuf-net and grpc, ensuring seamless handling of these data types.

**Crafting custom messages**

I’m working on designating decimal and DateTimeOffset in both protobuf-net and gRPC. Using strings for decimal and google.protobuf.Timestamp for DateTimeOffset ensures high precision and compatibility.

**Crafting gRPC messages**

I’m designing gRPC messages to store decimal and DateTimeOffset accurately, using string for decimal and google.protobuf.Timestamp for DateTimeOffset with an offset field, aligning with protobuf best practices.

**Crafting the converter**

I’m forming a static class, ProtobufTypeConverter, to proficiently manage conversions between decimal and string, and DateTimeOffset to google.protobuf.Timestamp with an offset field, focusing on accuracy and utility.

**Crafting conversion methods**

I’m developing methods to convert DateTimeOffset to google.protobuf.Timestamp with an offset field and vice versa. This ensures precise handling of datetime information in grpc and protobuf-net.

**Balancing serialization needs**

I’m figuring out how to handle different requirements for protobuf-net and gRPC. The adapter, aided by conversion utilities, manages these differences seamlessly.

**Streamlining Type Handling**

I’m working through defining a Product domain type with methods to convert it to and from protobuf-net and gRPC message types. This simplifies serialization and deserialization processes.

**Creating versatile converters**

I’m setting up conversion methods between domain and gRPC message types, intending to streamline gRPC serialization. This involves defining adapters for seamless data integration.

**Crafting the interface**

I’m developing an IGrpcConverter<T, TGrpc> to facilitate seamless conversions between domain types and gRPC message types. This approach enhances integration, making data transfer more efficient.

**Mapping the serialization flow**

I’m finalizing the integration of adapters for protobuf-net and gRPC, guided by IGrpcConverter<T, TGrpc>, which ensures smooth data serialization and conversion between domain and gRPC types.

**Crafting manual messages**

I’m thinking through manually creating the ProductGrpc message, simulating fields like Id, Name, Price, SaleDate, and SaleDateOffset, while using a minimal implementation approach.

**Implementing manual features**

I’m working through manually crafting the ProductGrpc message, including defining MergeFrom and WriteTo methods using CodedInputStream and CodedOutputStream, with a minimal version for efficiency.

**Mapping fields and calculating**

I’m focusing on field mapping for WriteTo and calculating sizes using field numbers for ProductGrpc and Timestamp fields, ensuring accuracy with protobuf-net for proper handling and serialization.

**Mapping conversions**

I’m detailing converters from decimal to string and string to decimal, alongside DateTimeOffset to Timestamp and back. Structuring these in "ProtobufAbstraction" for clarity and modularity.

**Drafting the code structure**

Conceiving a comprehensive single-file code base for all classes, including adapters and converters, with a main method showcasing usage and minimal IMessage<ProductGrpc> implementation.

**Crafting the namespace**

I’m organizing code into "ProtobufAbstraction," housing classes like adapters, converters, and domain types, with a main method demonstrating usage and minimal IMessage<ProductGrpc> implementation.

**Showcasing usage**

I’m demonstrating product serialization and deserialization with both protobuf-net and gRPC adapters, using a main method for clear illustration and complete code.

### assistant — 2025-02-01T03:54:02.093298+00:00

以下は、protobuf‐net と gRPC（Google.Protobuf）での型の違い（特に `decimal` と `DateTimeOffset` ）を吸収するためのサンプルコードです。

この例では、

- **ドメイン型**として `Product` クラスを定義し、`decimal` と `DateTimeOffset` のプロパティを持たせています。  
  ※ protobuf‐net 用に `[ProtoContract]` 属性を付与しているので、そのままシリアライズ／デシリアライズが可能です。

- **gRPC 用のメッセージ型**として `ProductGrpc` クラスを実装しています。  
  gRPC の公式プロトコルでは `decimal` や `DateTimeOffset` は直接サポートされないため、  
  - `decimal` は文字列（例： `"99.95"` ）に変換して送受信し、
  - `DateTimeOffset` は google.protobuf.WellKnownTypes.Timestamp（UTC日時）とオフセット（分単位）に分解して送信する形としています。

- **変換ユーティリティ**として `ProtobufTypeConverter` クラスで、  
  `decimal` ⇔ `string`、`DateTimeOffset` ⇔ (`Timestamp`、オフセット値) の変換を行っています。

- **アダプターと変換クラス**  
  - `IProtobufAdapter<T>` インターフェースはシリアライズ／デシリアライズ処理を抽象化します。  
  - `ProtobufNetAdapter<T>` は protobuf‐net 用の実装です。  
  - `GrpcProtobufAdapter<TDomain, TGrpc>` は、gRPC 用のメッセージ型（`IMessage<T>` 実装）とドメイン型との相互変換を行うコンバーター（`IGrpcConverter<TDomain, TGrpc>`）を利用して実装しています。  
  - `ProductGrpcConverter` は、`Product` ⇔ `ProductGrpc` の相互変換を実装しています。

以下にサンプルコードを示します。

---

```csharp
using System;
using System.IO;
using System.Globalization;
using ProtoBuf;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;

namespace ProtobufAbstraction
{
    // ■ ドメイン型（protobuf-net 用）
    [ProtoContract]
    public class Product
    {
        [ProtoMember(1)]
        public int Id { get; set; }
        
        [ProtoMember(2)]
        public string Name { get; set; }
        
        // decimal は protobuf-net でそのままシリアライズ可能
        [ProtoMember(3)]
        public decimal Price { get; set; }
        
        // DateTimeOffset も同様に扱えます（ただし gRPC とやり取りする場合は変換が必要）
        [ProtoMember(4)]
        public DateTimeOffset SaleDate { get; set; }
    }

    // ■ シリアライズ／デシリアライズの抽象化インターフェース
    public interface IProtobufAdapter<T>
    {
        byte[] Serialize(T message);
        T Deserialize(byte[] data);
    }

    // ■ protobuf-net 用アダプター（そのままシリアライズ／デシリアライズ）
    public class ProtobufNetAdapter<T> : IProtobufAdapter<T>
    {
        public byte[] Serialize(T message)
        {
            using (var ms = new MemoryStream())
            {
                Serializer.Serialize(ms, message);
                return ms.ToArray();
            }
        }

        public T Deserialize(byte[] data)
        {
            using (var ms = new MemoryStream(data))
            {
                return Serializer.Deserialize<T>(ms);
            }
        }
    }

    // ■ gRPC 用の相互変換用インターフェース
    //  ※ TDomain: ドメイン側の型、TGrpc: gRPC の IMessage<TGrpc> 型
    public interface IGrpcConverter<TDomain, TGrpc>
        where TGrpc : IMessage<TGrpc>, new()
    {
        TGrpc ToGrpc(TDomain domain);
        TDomain FromGrpc(TGrpc grpc);
    }

    // ■ gRPC 用アダプター
    // ドメイン型 ⇔ gRPC メッセージ型の変換処理をコンバーター経由で行います
    public class GrpcProtobufAdapter<TDomain, TGrpc> : IProtobufAdapter<TDomain>
        where TGrpc : IMessage<TGrpc>, new()
    {
        private readonly IGrpcConverter<TDomain, TGrpc> _converter;

        public GrpcProtobufAdapter(IGrpcConverter<TDomain, TGrpc> converter)
        {
            _converter = converter;
        }

        public byte[] Serialize(TDomain message)
        {
            TGrpc grpcMessage = _converter.ToGrpc(message);
            return grpcMessage.ToByteArray();
        }

        public TDomain Deserialize(byte[] data)
        {
            TGrpc grpcMessage = new TGrpc();
            grpcMessage.MergeFrom(data);
            return _converter.FromGrpc(grpcMessage);
        }
    }

    // ■ 型変換ユーティリティ
    public static class ProtobufTypeConverter
    {
        // decimal ⇔ string （文字列表現により精度を保持）
        public static string ToDecimalString(decimal value)
        {
            return value.ToString(CultureInfo.InvariantCulture);
        }

        public static decimal ToDecimal(string value)
        {
            return decimal.Parse(value, CultureInfo.InvariantCulture);
        }

        // DateTimeOffset ⇔ Timestamp + オフセット（分単位）
        // gRPC の Timestamp は UTC の DateTime を扱うため、DateTimeOffset からは UtcDateTime を利用
        public static Timestamp ToTimestamp(DateTimeOffset value)
        {
            return Timestamp.FromDateTime(value.UtcDateTime);
        }

        public static DateTimeOffset ToDateTimeOffset(Timestamp timestamp, int offsetMinutes)
        {
            DateTime utcDateTime = timestamp.ToDateTime();
            return new DateTimeOffset(utcDateTime, TimeSpan.Zero)
                    .ToOffset(TimeSpan.FromMinutes(offsetMinutes));
        }
    }

    // ■ gRPC 用メッセージ型（通常は .proto から自動生成されるが、ここでは手動実装）
    // フィールド番号:
    //  1: Id (int32), 2: Name (string), 3: Price (string), 4: SaleDate (Timestamp), 5: SaleDateOffset (int32)
    public sealed partial class ProductGrpc : IMessage<ProductGrpc>
    {
        public int Id { get; set; }
        public string Name { get; set; } = "";
        public string Price { get; set; } = "";  // decimal を文字列として保持
        public Timestamp SaleDate { get; set; } = new Timestamp();
        public int SaleDateOffset { get; set; }  // DateTimeOffset のオフセット（分）

        // MergeFrom: シリアライズされたデータから各フィールドを読み出す
        public void MergeFrom(CodedInputStream input)
        {
            while (input.ReadTag() is uint tag && tag != 0)
            {
                switch (tag)
                {
                    case 8: // Field 1: Id (8 = (1 << 3) | 0)
                        Id = input.ReadInt32();
                        break;
                    case 18: // Field 2: Name (18 = (2 << 3) | 2)
                        Name = input.ReadString();
                        break;
                    case 26: // Field 3: Price (26 = (3 << 3) | 2)
                        Price = input.ReadString();
                        break;
                    case 34: // Field 4: SaleDate (34 = (4 << 3) | 2)
                        if (SaleDate == null)
                            SaleDate = new Timestamp();
                        input.ReadMessage(SaleDate);
                        break;
                    case 40: // Field 5: SaleDateOffset (40 = (5 << 3) | 0)
                        SaleDateOffset = input.ReadInt32();
                        break;
                    default:
                        input.SkipLastField();
                        break;
                }
            }
        }

        // WriteTo: 各フィールドをシリアライズする
        public void WriteTo(CodedOutputStream output)
        {
            if (Id != 0)
            {
                output.WriteRawTag(8);
                output.WriteInt32(Id);
            }
            if (!string.IsNullOrEmpty(Name))
            {
                output.WriteRawTag(18);
                output.WriteString(Name);
            }
            if (!string.IsNullOrEmpty(Price))
            {
                output.WriteRawTag(26);
                output.WriteString(Price);
            }
            if (SaleDate != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(SaleDate);
            }
            if (SaleDateOffset != 0)
            {
                output.WriteRawTag(40);
                output.WriteInt32(SaleDateOffset);
            }
        }

        // CalculateSize: シリアライズ後のバイトサイズを計算
        public int CalculateSize()
        {
            int size = 0;
            if (Id != 0)
                size += 1 + CodedOutputStream.ComputeInt32Size(Id);
            if (!string.IsNullOrEmpty(Name))
                size += 1 + CodedOutputStream.ComputeStringSize(Name);
            if (!string.IsNullOrEmpty(Price))
                size += 1 + CodedOutputStream.ComputeStringSize(Price);
            if (SaleDate != null)
            {
                int saleDateSize = SaleDate.CalculateSize();
                size += 1 + CodedOutputStream.ComputeLengthSize(saleDateSize) + saleDateSize;
            }
            if (SaleDateOffset != 0)
                size += 1 + CodedOutputStream.ComputeInt32Size(SaleDateOffset);
            return size;
        }

        // Descriptor は通常生成されたコードで設定されますが、ここでは省略
        public MessageDescriptor Descriptor => null;

        public ProductGrpc Clone()
        {
            return new ProductGrpc
            {
                Id = this.Id,
                Name = this.Name,
                Price = this.Price,
                SaleDate = this.SaleDate?.Clone(),
                SaleDateOffset = this.SaleDateOffset
            };
        }

        public bool Equals(ProductGrpc other)
        {
            if (other == null) return false;
            return Id == other.Id &&
                   Name == other.Name &&
                   Price == other.Price &&
                   Equals(SaleDate, other.SaleDate) &&
                   SaleDateOffset == other.SaleDateOffset;
        }

        public override bool Equals(object obj) => Equals(obj as ProductGrpc);
        public override int GetHashCode() => (Id, Name, Price, SaleDate, SaleDateOffset).GetHashCode();

        public void MergeFrom(ProductGrpc message)
        {
            if (message == null) return;
            if (message.Id != 0) Id = message.Id;
            if (!string.IsNullOrEmpty(message.Name)) Name = message.Name;
            if (!string.IsNullOrEmpty(message.Price)) Price = message.Price;
            if (message.SaleDate != null)
            {
                if (SaleDate == null)
                    SaleDate = new Timestamp();
                SaleDate.MergeFrom(message.SaleDate);
            }
            if (message.SaleDateOffset != 0)
                SaleDateOffset = message.SaleDateOffset;
        }
    }

    // ■ Product ⇔ ProductGrpc の変換処理
    public class ProductGrpcConverter : IGrpcConverter<Product, ProductGrpc>
    {
        public ProductGrpc ToGrpc(Product product)
        {
            return new ProductGrpc
            {
                Id = product.Id,
                Name = product.Name,
                Price = ProtobufTypeConverter.ToDecimalString(product.Price),
                SaleDate = ProtobufTypeConverter.ToTimestamp(product.SaleDate),
                SaleDateOffset = (int)product.SaleDate.Offset.TotalMinutes
            };
        }

        public Product FromGrpc(ProductGrpc grpc)
        {
            return new Product
            {
                Id = grpc.Id,
                Name = grpc.Name,
                Price = ProtobufTypeConverter.ToDecimal(grpc.Price),
                SaleDate = ProtobufTypeConverter.ToDateTimeOffset(grpc.SaleDate, grpc.SaleDateOffset)
            };
        }
    }

    // ■ 使用例
    class Program
    {
        static void Main(string[] args)
        {
            // サンプルの Product インスタンス
            var product = new Product
            {
                Id = 101,
                Name = "Gadget",
                Price = 99.95m,
                // 例：2025年2月1日12:00 (UTC+9)
                SaleDate = new DateTimeOffset(2025, 2, 1, 12, 0, 0, TimeSpan.FromHours(9))
            };

            // ----- protobuf-net でのシリアライズ／デシリアライズ -----
            IProtobufAdapter<Product> netAdapter = new ProtobufNetAdapter<Product>();
            byte[] netData = netAdapter.Serialize(product);
            Product productFromNet = netAdapter.Deserialize(netData);
            Console.WriteLine("protobuf-net:");
            Console.WriteLine($"Id: {productFromNet.Id}, Name: {productFromNet.Name}, Price: {productFromNet.Price}, SaleDate: {productFromNet.SaleDate}");

            // ----- gRPC 用アダプターを利用（変換処理付き） -----
            var grpcConverter = new ProductGrpcConverter();
            IProtobufAdapter<Product> grpcAdapter = new GrpcProtobufAdapter<Product, ProductGrpc>(grpcConverter);
            byte[] grpcData = grpcAdapter.Serialize(product);
            Product productFromGrpc = grpcAdapter.Deserialize(grpcData);
            Console.WriteLine("gRPC:");
            Console.WriteLine($"Id: {productFromGrpc.Id}, Name: {productFromGrpc.Name}, Price: {productFromGrpc.Price}, SaleDate: {productFromGrpc.SaleDate}");
        }
    }
}
```

---

### 解説

1. **ドメイン型と gRPC メッセージ型**  
   - `Product` クラスは、protobuf-net 用に `[ProtoContract]` を付けているので、`decimal` や `DateTimeOffset` をそのまま扱えます。  
   - 一方、gRPC 用の `ProductGrpc` では、`decimal` は文字列として保持し、`DateTimeOffset` は `Timestamp` とオフセット（分単位）として表現しています。

2. **型変換ユーティリティ**  
   `ProtobufTypeConverter` クラスで、  
   - `decimal` ⇔ `string` の変換、  
   - `DateTimeOffset` ⇔ (`Timestamp`、offset) の変換処理を実装しています。

3. **アダプターとコンバーターの利用**  
   - `ProtobufNetAdapter<T>` はシンプルに protobuf-net の `Serializer` を使って処理。  
   - `GrpcProtobufAdapter<TDomain, TGrpc>` は、`IGrpcConverter<TDomain, TGrpc>` を利用して、ドメイン型と gRPC メッセージ型の間の変換を吸収しています。  
   - `ProductGrpcConverter` はその具体例で、`Product` ⇔ `ProductGrpc` の変換を実装しています。

これにより、利用側はどちらのシリアライザーを使う場合でも統一したインターフェース（`IProtobufAdapter<T>`）を経由して操作でき、内部での `decimal` や `DateTimeOffset` の扱いの違いを吸収できます。

### user — 2025-02-01T03:57:59.801752+00:00

以下のクラスをコンバートできるか
  [ProtoContract]
  public class BaseMsg
  {
      [ProtoMember(1)]
      public string id { get; set; }
      [ProtoMember(2)]
      public short p1 { get; set; }
      [ProtoMember(3)]
      public bool p2 { get; set; }
      [ProtoMember(4)]
      public IItem item { get; set; }
  }
  [ProtoBuf.ProtoInclude(101, typeof(ItemC1), DataFormat = ProtoBuf.DataFormat.WellKnown)]
  [ProtoBuf.ProtoInclude(102,typeof(ItemC2),DataFormat =ProtoBuf.DataFormat.WellKnown)]
  public interface IItem
  {

  }
  [ProtoContract]
  public class ItemC1 : IItem
  {
      [ProtoMember(1)]
      public ItemC1_A Parameter { get; set; }

  }
  [ProtoContract]
  public class ItemC1_A
  {
      [ProtoMember(1)]
      public string p1 { get; set; }

      [ProtoMember(2)]
      public short p2 { get; set; }
      [ProtoMember(3)]
      public int p3 { get; set; }
      [ProtoMember(4)]
      public long p4 { get; set; }
      [ProtoMember(5)]
      public DateTimeOffset p5 { get; set; }
      [ProtoMember(6)]
      public decimal p6 { get; set; }
  }
  [ProtoContract]
  public class ItemC2 : IItem
  {
      [ProtoMember(1)]
      public ItemC2_A Parameter { get; set; }

  }
  [ProtoContract]
  public class ItemC2_A
  {
      [ProtoMember(1)]
      public string p1 { get; set; }

      [ProtoMember(2)]
      public short p2 { get; set; }
      [ProtoMember(3)]
      public int p3 { get; set; }
      [ProtoMember(4)]
      public long p4 { get; set; }
      [ProtoMember(5)]
      public DateTimeOffset p5 { get; set; }
      [ProtoMember(6)]
      public decimal p6 { get; set; }
  }

### tool — 2025-02-01T03:59:05.267638+00:00

**Converting classes**

I'm thinking about how to convert C# classes into gRPC messages. This involves converting BaseMsg classes and mapping inheritance to gRPC message types for domain messages.

**Mapping out conversion**

I’m noting that converting C# classes to gRPC messages is feasible with ProtoInclude for inheritance and interfaces. Custom conversion might be needed for polymorphic fields like "IItem".

**Mapping the structure**

I’m examining the gRPC message structure with ProtoInclude for inheritance and ProtoMember for fields. Custom logic will manage polymorphic fields like "IItem" within BaseMsg.

**Mapping out conversion**

I’m noting that converting the classes will require additional gRPC message definitions for polymorphic fields like "IItem". I'll provide sample code for handling polymorphic types.

**Crafting gRPC classes**

I’m gathering info on creating gRPC message classes for BaseMsg, ItemC1, and ItemC2. Polymorphic fields will be managed using "oneof", and I’ll reuse ProtobufTypeConverter for DateTimeOffset and decimal fields.

**Mapping gRPC message structure**

I’m thinking through using oneof for polymorphic fields in IItemGrpc, SDKBaseMessageGrpc, and SDKDomainMessageGrpc. This approach will optimize message handling and make it more agile.

**Refining gRPC message setup**

I’m working through separate gRPC classes for ItemC1Grpc and ItemC2Grpc, and using BaseMsgGrpc with a oneof union field to efficiently manage polymorphic fields.

**Crafting a strategy**

I’m exploring mimicking oneof in code by employing an enum to distinguish types and separate properties for each, ensuring a flexible and efficient way to handle multiple types.

**Mapping gRPC structures**

I’m detailing gRPC message classes, including BaseMsgGrpc with a oneof union field and various item classes. Conversion code will bridge these structures, ensuring smooth handling of polymorphic fields.

**Crafting custom converters**

I'm working through converting classes to gRPC message types, particularly dealing with polymorphic types using oneof unions and managing decimal and DateTimeOffset fields with helper methods.

**Mapping conversion processes**

I’m crafting a converter class to transform classes into gRPC message types. This involves handling polymorphic types with oneof unions and converting decimal and DateTimeOffset fields using helper methods.

**Transforming data structures**

I’m detailing the process of converting nested and polymorphic types, emphasizing the necessity of a proper union for IItem and utilizing ProtobufTypeConverter for handling decimal and DateTimeOffset fields.

**Mapping data transformation**

I'm thinking through how to convert domain and gRPC message classes into C# code, including handling polymorphic fields with a oneof union and using ProtobufTypeConverter for precision conversions.

**Providing a glimpse**

I'm outlining the possibility of converting domain classes to gRPC types, focusing on polymorphism and interface handling. Only minimal gRPC message class details will be shared.

**Demonstrating conversion**

I’m mapping out code to convert BaseMsg with polymorphic IItem fields into a gRPC message class, using nullable properties for ItemC1Grpc and ItemC2Grpc to simplify the union.

**Mapping out the class**

I’m detailing the BaseMsgGrpc class with properties for Id, P1, P2, and nullable fields for ItemC1Grpc and ItemC2Grpc, ensuring only one is non-null for polymorphism.

**Mapping out gRPC structures**

I’m laying out gRPC message classes for BaseMsgGrpc, ItemC1Grpc, and ItemC2Grpc, using nullable fields and basic data types to ensure precise domain object conversions.

**Crafting conversion logic**

I'm refining the BaseMsgGrpcConverter class to handle DateTimeOffset and decimal fields. This involves using ProtobufTypeConverter to ensure precise data transformations.

**Refining conversion code**

I'm honing in on the conversion logic for the gRPC message classes, focusing on DateTimeOffset and decimal fields, ensuring precise data transformation using ProtobufTypeConverter.

**Transforming data**

I’m working on a conversion process for BaseMsg and BaseMsgGrpc, addressing DateTimeOffset and decimal fields with ProtobufTypeConverter to ensure precise data transformations between domain and gRPC message classes.

### assistant — 2025-02-01T03:59:05.267826+00:00

以下のように、protobuf‐net 側で定義された多相（ポリモーフィック）なドメインクラス群（BaseMsg や IItem を実装する ItemC1/ItemC2 など）を、gRPC 用のメッセージ（プロトコル定義）に変換する実装例を示します。

gRPC の公式仕様ではインターフェースによる多相はサポートされないため、たとえば「oneof」相当の実装（ここでは、ItemC1 と ItemC2 をそれぞれ別プロパティとして扱い、どちらか一方がセットされるようにする）や、別途 discriminater（種別識別子）を持つ形に変換する必要があります。  
また、gRPC には `decimal` 型や `DateTimeOffset` 型は存在しないため、  
- **decimal** は文字列表現（例："99.99"）に変換し、  
- **DateTimeOffset** は Google.Protobuf.WellKnownTypes.Timestamp（UTC 時刻）に変換する  
といった処理を行います。

以下は、ドメイン側のクラス（※ユーザー提供のクラス群）を gRPC 用メッセージへ変換する一例です。

---

```csharp
using System;
using System.Globalization;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using ProtoBuf;

namespace DomainModel
{
    // ────────────── ドメイン側（protobuf-net 用） ──────────────

    [ProtoContract]
    public class BaseMsg
    {
        [ProtoMember(1)]
        public string id { get; set; }
        [ProtoMember(2)]
        public short p1 { get; set; }
        [ProtoMember(3)]
        public bool p2 { get; set; }
        [ProtoMember(4)]
        public IItem item { get; set; }
    }

    [ProtoInclude(101, typeof(ItemC1), DataFormat = DataFormat.WellKnown)]
    [ProtoInclude(102, typeof(ItemC2), DataFormat = DataFormat.WellKnown)]
    public interface IItem
    {
    }

    [ProtoContract]
    public class ItemC1 : IItem
    {
        [ProtoMember(1)]
        public ItemC1_A Parameter { get; set; }
    }

    [ProtoContract]
    public class ItemC1_A
    {
        [ProtoMember(1)]
        public string p1 { get; set; }
        [ProtoMember(2)]
        public short p2 { get; set; }
        [ProtoMember(3)]
        public int p3 { get; set; }
        [ProtoMember(4)]
        public long p4 { get; set; }
        [ProtoMember(5)]
        public DateTimeOffset p5 { get; set; }
        [ProtoMember(6)]
        public decimal p6 { get; set; }
    }

    [ProtoContract]
    public class ItemC2 : IItem
    {
        [ProtoMember(1)]
        public ItemC2_A Parameter { get; set; }
    }

    [ProtoContract]
    public class ItemC2_A
    {
        [ProtoMember(1)]
        public string p1 { get; set; }
        [ProtoMember(2)]
        public short p2 { get; set; }
        [ProtoMember(3)]
        public int p3 { get; set; }
        [ProtoMember(4)]
        public long p4 { get; set; }
        [ProtoMember(5)]
        public DateTimeOffset p5 { get; set; }
        [ProtoMember(6)]
        public decimal p6 { get; set; }
    }
}

namespace GrpcMessages
{
    // ────────────── gRPC 用メッセージ（通常は .proto から自動生成される） ──────────────
    // ここではサンプルとして最小限の IMessage 実装（メソッド本体は省略）を用いています。

    public class BaseMsgGrpc : IMessage<BaseMsgGrpc>
    {
        public string Id { get; set; }
        public int P1 { get; set; }     // ドメインの short は int で扱います
        public bool P2 { get; set; }

        // 多相部分：gRPC では oneof の代わりに、どちらか一方がセットされるようにします
        public ItemC1Grpc ItemC1 { get; set; }
        public ItemC2Grpc ItemC2 { get; set; }

        // 以下、IMessage<T> の最小実装（実際は自動生成コードが含む）
        public void MergeFrom(CodedInputStream input) { /* 実装省略 */ }
        public void WriteTo(CodedOutputStream output) { /* 実装省略 */ }
        public int CalculateSize() => 0;
        public MessageDescriptor Descriptor => null;
        public BaseMsgGrpc Clone() => (BaseMsgGrpc)MemberwiseClone();
        public void MergeFrom(BaseMsgGrpc message) { /* 実装省略 */ }
    }

    public class ItemC1Grpc : IMessage<ItemC1Grpc>
    {
        public ItemC1_AGrpc Parameter { get; set; }
        public void MergeFrom(CodedInputStream input) { /* 実装省略 */ }
        public void WriteTo(CodedOutputStream output) { /* 実装省略 */ }
        public int CalculateSize() => 0;
        public MessageDescriptor Descriptor => null;
        public ItemC1Grpc Clone() => (ItemC1Grpc)MemberwiseClone();
        public void MergeFrom(ItemC1Grpc message) { /* 実装省略 */ }
    }

    public class ItemC1_AGrpc : IMessage<ItemC1_AGrpc>
    {
        public string P1 { get; set; }
        public int P2 { get; set; }
        public int P3 { get; set; }
        public long P4 { get; set; }
        public Timestamp P5 { get; set; }   // DateTimeOffset は Timestamp に変換
        public string P6 { get; set; }      // decimal は文字列で保持
        public void MergeFrom(CodedInputStream input) { /* 実装省略 */ }
        public void WriteTo(CodedOutputStream output) { /* 実装省略 */ }
        public int CalculateSize() => 0;
        public MessageDescriptor Descriptor => null;
        public ItemC1_AGrpc Clone() => (ItemC1_AGrpc)MemberwiseClone();
        public void MergeFrom(ItemC1_AGrpc message) { /* 実装省略 */ }
    }

    public class ItemC2Grpc : IMessage<ItemC2Grpc>
    {
        public ItemC2_AGrpc Parameter { get; set; }
        public void MergeFrom(CodedInputStream input) { /* 実装省略 */ }
        public void WriteTo(CodedOutputStream output) { /* 実装省略 */ }
        public int CalculateSize() => 0;
        public MessageDescriptor Descriptor => null;
        public ItemC2Grpc Clone() => (ItemC2Grpc)MemberwiseClone();
        public void MergeFrom(ItemC2Grpc message) { /* 実装省略 */ }
    }

    public class ItemC2_AGrpc : IMessage<ItemC2_AGrpc>
    {
        public string P1 { get; set; }
        public int P2 { get; set; }
        public int P3 { get; set; }
        public long P4 { get; set; }
        public Timestamp P5 { get; set; }
        public string P6 { get; set; }
        public void MergeFrom(CodedInputStream input) { /* 実装省略 */ }
        public void WriteTo(CodedOutputStream output) { /* 実装省略 */ }
        public int CalculateSize() => 0;
        public MessageDescriptor Descriptor => null;
        public ItemC2_AGrpc Clone() => (ItemC2_AGrpc)MemberwiseClone();
        public void MergeFrom(ItemC2_AGrpc message) { /* 実装省略 */ }
    }
}

namespace Converters
{
    using DomainModel;
    using GrpcMessages;

    // ────────────── 型変換ユーティリティ ──────────────
    public static class ProtobufTypeConverter
    {
        // decimal ⇔ string（精度を保持するため InvariantCulture を利用）
        public static string ToDecimalString(decimal value)
        {
            return value.ToString(CultureInfo.InvariantCulture);
        }
        public static decimal ToDecimal(string value)
        {
            return decimal.Parse(value, CultureInfo.InvariantCulture);
        }

        // DateTimeOffset ⇔ Timestamp（gRPC は UTC の Timestamp を使用）
        public static Timestamp ToTimestamp(DateTimeOffset dto)
        {
            return Timestamp.FromDateTime(dto.UtcDateTime);
        }
        public static DateTimeOffset ToDateTimeOffset(Timestamp ts, int offsetMinutes = 0)
        {
            return new DateTimeOffset(ts.ToDateTime(), TimeSpan.Zero)
                        .ToOffset(TimeSpan.FromMinutes(offsetMinutes));
        }
    }

    // ────────────── ドメイン ⇔ gRPC 変換インターフェース ──────────────
    public interface IGrpcConverter<TDomain, TGrpc>
        where TGrpc : IMessage<TGrpc>, new()
    {
        TGrpc ToGrpc(TDomain domain);
        TDomain FromGrpc(TGrpc grpc);
    }

    // ────────────── BaseMsg ⇔ BaseMsgGrpc の変換処理 ──────────────
    public class BaseMsgGrpcConverter : IGrpcConverter<BaseMsg, BaseMsgGrpc>
    {
        public BaseMsgGrpc ToGrpc(BaseMsg domain)
        {
            var grpc = new BaseMsgGrpc
            {
                Id = domain.id,
                P1 = domain.p1,  // short → int
                P2 = domain.p2
            };

            // 多相部分の変換
            if (domain.item is ItemC1 itemC1)
            {
                grpc.ItemC1 = new ItemC1Grpc
                {
                    Parameter = new ItemC1_AGrpc
                    {
                        P1 = itemC1.Parameter.p1,
                        P2 = itemC1.Parameter.p2,
                        P3 = itemC1.Parameter.p3,
                        P4 = itemC1.Parameter.p4,
                        P5 = ProtobufTypeConverter.ToTimestamp(itemC1.Parameter.p5),
                        P6 = ProtobufTypeConverter.ToDecimalString(itemC1.Parameter.p6)
                    }
                };
            }
            else if (domain.item is ItemC2 itemC2)
            {
                grpc.ItemC2 = new ItemC2Grpc
                {
                    Parameter = new ItemC2_AGrpc
                    {
                        P1 = itemC2.Parameter.p1,
                        P2 = itemC2.Parameter.p2,
                        P3 = itemC2.Parameter.p3,
                        P4 = itemC2.Parameter.p4,
                        P5 = ProtobufTypeConverter.ToTimestamp(itemC2.Parameter.p5),
                        P6 = ProtobufTypeConverter.ToDecimalString(itemC2.Parameter.p6)
                    }
                };
            }

            return grpc;
        }

        public BaseMsg FromGrpc(BaseMsgGrpc grpc)
        {
            var domain = new BaseMsg
            {
                id = grpc.Id,
                p1 = (short)grpc.P1,
                p2 = grpc.P2,
            };

            // 多相部分の復元（gRPC 側では ItemC1, ItemC2 のどちらかがセットされている）
            if (grpc.ItemC1 != null)
            {
                domain.item = new ItemC1
                {
                    Parameter = new ItemC1_A
                    {
                        p1 = grpc.ItemC1.Parameter.P1,
                        p2 = (short)grpc.ItemC1.Parameter.P2,
                        p3 = grpc.ItemC1.Parameter.P3,
                        p4 = grpc.ItemC1.Parameter.P4,
                        p5 = ProtobufTypeConverter.ToDateTimeOffset(grpc.ItemC1.Parameter.P5),
                        p6 = ProtobufTypeConverter.ToDecimal(grpc.ItemC1.Parameter.P6)
                    }
                };
            }
            else if (grpc.ItemC2 != null)
            {
                domain.item = new ItemC2
                {
                    Parameter = new ItemC2_A
                    {
                        p1 = grpc.ItemC2.Parameter.P1,
                        p2 = (short)grpc.ItemC2.Parameter.P2,
                        p3 = grpc.ItemC2.Parameter.P3,
                        p4 = grpc.ItemC2.Parameter.P4,
                        p5 = ProtobufTypeConverter.ToDateTimeOffset(grpc.ItemC2.Parameter.P5),
                        p6 = ProtobufTypeConverter.ToDecimal(grpc.ItemC2.Parameter.P6)
                    }
                };
            }

            return domain;
        }
    }
}

namespace SampleUsage
{
    using DomainModel;
    using Converters;
    using GrpcMessages;
    using System;

    class Program
    {
        static void Main(string[] args)
        {
            // サンプル: BaseMsg インスタンス（ItemC1 を利用）
            BaseMsg domainMsg = new BaseMsg
            {
                id = "MSG001",
                p1 = 10,
                p2 = true,
                item = new ItemC1
                {
                    Parameter = new ItemC1_A
                    {
                        p1 = "パラメータ1",
                        p2 = 100,
                        p3 = 1000,
                        p4 = 10000,
                        p5 = DateTimeOffset.Now,
                        p6 = 1234.56m
                    }
                }
            };

            // ドメイン → gRPC 変換
            var converter = new BaseMsgGrpcConverter();
            BaseMsgGrpc grpcMsg = converter.ToGrpc(domainMsg);

            // gRPC → ドメイン 変換
            BaseMsg domainMsg2 = converter.FromGrpc(grpcMsg);

            Console.WriteLine($"変換後のメッセージ id: {domainMsg2.id}");
        }
    }
}
```

---

### 解説

1. **ドメイン側のクラス**  
   ユーザーが提供されたクラス群（BaseMsg、IItem、ItemC1/ItemC2 など）は、protobuf-net によりシリアライズ可能ですが、gRPC との相互運用時には直接対応する型が存在しません。

2. **gRPC 側のメッセージクラス**  
   ここでは、.proto ファイルから生成されることを想定したクラスの代わりに、最低限の IMessage 実装を行ったクラス（BaseMsgGrpc、ItemC1Grpc、ItemC2Grpc など）を用意しています。  
   多相部分は、BaseMsgGrpc 内に ItemC1 と ItemC2 の 2 つのプロパティを用意し、どちらか一方のみがセットされるようにしています。

3. **型変換ユーティリティ**  
   - **decimal ⇔ string**  
     精度を保持するため、`decimal` は InvariantCulture を使って文字列に変換しています。  
   - **DateTimeOffset ⇔ Timestamp**  
     gRPC の Timestamp は UTC 時刻を前提とするため、DateTimeOffset の UtcDateTime を用いて変換しています。

4. **変換コンバーター**  
   `BaseMsgGrpcConverter` クラスは、ドメイン側の BaseMsg から gRPC 側の BaseMsgGrpc へ（およびその逆）の変換を行います。  
   特に、`item` プロパティは IItem の実装（ItemC1 または ItemC2）に応じてそれぞれ変換されます。

このように、ドメイン側の多相なクラス群も、適切な変換ロジックを実装すれば gRPC 用のメッセージに変換可能です。  
実際のプロジェクトでは、gRPC 用のコードは .proto から自動生成されるため、変換処理部分のみをカスタム実装する形になります。
