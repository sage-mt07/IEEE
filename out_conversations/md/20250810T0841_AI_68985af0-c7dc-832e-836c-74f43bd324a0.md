---
conversation_id: "68985af0-c7dc-832e-836c-74f43bd324a0"
title: "AI指示の効率化方法"
create_time: 1754815315.33829
update_time: 1754815912.151152
language_guess: "en"
num_messages: 18
part_index: 1
part_count: 1
---

### assistant — 2025-08-10T08:41:55.078836+00:00

_(empty)_

### assistant — 2025-08-10T08:41:55.091759+00:00

送信日時: [[REDACTED_PHONE]]:27 (JST)  

なるほど、20k行規模のソースをほぼ全部把握できた時点で、もう「頭の中に地図がある」状態ですね。  
それでもAIを使うと楽なのは、  

- 実装そのものの作業負荷を減らせる  
- 機械的な書き換えや繰り返し作業を任せられる  
- 「思い出す」より「引き出す」ほうが早い  

…というメリットがあるからですね。  

ただ、指示が難しくなる場面はまさにおっしゃる通りで、自分でもコードの形が明確に浮かんでいない時ほど発生します。  
これは人間同士のやりとりでも同じで、仕様や構造の輪郭が曖昧なまま依頼すると、受け手もブレやすくなります。  

おそらく司令の場合、  
- 曖昧な部分を先に「仮の型」や「部分的なサンプルコード」に落とし込む  
- その上でAIに具体的な肉付けを指示する  

この二段階方式にすると、中注力モードで一気にイメージ固めできると思います。  

もし希望があれば、「イメージがはっきりしてない状態からAI指示に落とすテンプレート」作れます。  
これはいわゆる **発散→収束** の手順を組み込んだものになります。

### system — 2025-08-10T08:41:55.338290+00:00

_(empty)_

### user — 2025-08-10T08:41:55.338290+00:00

_(empty)_

### user — 2025-08-10T08:41:56.528000+00:00

20kあったソースほぼ全部把握した。
それでもAI使うのは楽だから
指示がむずかしかったりすることあるけど、それは自分がコードを書いてもはっきりイメージ出てきてなかったりすること
コーディングは相当な中注力

### assistant — 2025-08-10T08:42:44.815410+00:00

送信日時: [[REDACTED_PHONE]]:31 (JST)  

それはかなり本質を突いてますね。  
曖昧な部分をテストコードにすると、  

- 「何をしたいのか」が入出力や期待値として明確化される  
- 実装に入る前に境界条件や例外ケースも洗い出せる  
- AIにも具体的なゴールを伝えやすくなる  

という三拍子そろいます。  

しかも司令の場合、既に20k行を把握しているから、テストコードの位置づけを「確認用」ではなく「仕様の骨格」にできる。  
これはTDDより一歩踏み込んだ、**曖昧仕様の視覚化ツール**としてのテスト活用ですね。  

このやり方、OSSの他メンバーやCodex指示にもそのまま展開できると思います。  
必要なら「AIに渡すテストコード雛形」も組めますが、そっちも作りますか？

### user — 2025-08-10T08:42:46.297000+00:00

曖昧な部分はテストコードとして切り出すのが一番有効と感じた

### user — 2025-08-10T08:49:22.934000+00:00

あとreflectionのハマったところと回避方法
関数IFで複数このパラメータバリエーションがある場合、これを直接リフレクションで使用すると動的エラーが発生しやすい
回避方法はラッピング関数を作って、対象IFを呼ぶ形式にすること
ここで２週間はまった

### system — 2025-08-10T08:49:23.289318+00:00

_(empty)_

### assistant — 2025-08-10T08:49:23.951464+00:00

_(empty)_

### assistant — 2025-08-10T08:49:32.058788+00:00

送信日時: [[REDACTED_PHONE]]:49 (JST)

わかる…オーバーロード地獄＋リフレクションは刺さりますよね。2週間はまるやつ。  
「**直接IFに反射で突っ込まず、薄いラッパー関数を経由する**」は最善手です。動的解決点を1箇所に“固定”できるので、曖昧マッチや`AmbiguousMatchException`を根絶できます。

ざっと再発防止の実装パターンを置いておきます。必要ならプロジェクト向けにテンプレに落とし込みます。

# 1) 薄いラッパーで“呼び先とシグネチャ”を固定化
```csharp
public interface IProcessor
{
    // overloads (例)
    void Process(Order order);
    void Process(User user, int level);
}

public static class ProcessorApi // ← ここを“唯一の反射エントリ”にする
{
    public static void ProcessOrder(IProcessor p, Order o) => p.Process(o);
    public static void ProcessUserWithLevel(IProcessor p, User u, int level) => p.Process(u, level);
}
```
反射は `ProcessorApi.ProcessOrder` / `ProcessUserWithLevel` の**一意な**メソッドだけを見るようにします。  
これで「同名＋引数違い」のカオスから離脱。

# 2) 反射はラッパーだけに向け、厳密一致で拾う
```csharp
static MethodInfo GetMethodStrict(Type type, string name, params Type[] parameterTypes)
{
    return type.GetMethod(
        name,
        BindingFlags.Public | BindingFlags.Static,
        binder: null,
        types: parameterTypes,
        modifiers: null
    ) ?? throw new MissingMethodException($"{type.Name}.{name}({string.Join(", ", parameterTypes.Select(t => t.Name))}) not found.");
}
```

# 3) デリゲートに“型を焼き付けて”キャッシュする
```csharp
static class ReflectionCache
{
    private static readonly ConcurrentDictionary<string, Delegate> _cache = new();

    public static Action<IProcessor, Order> GetProcessOrder()
    {
        return (Action<IProcessor, Order>)_cache.GetOrAdd(
            "ProcessOrder",
            _ =>
            {
                var mi = GetMethodStrict(typeof(ProcessorApi), nameof(ProcessorApi.ProcessOrder),
                                         typeof(IProcessor), typeof(Order));
                return mi.CreateDelegate(typeof(Action<IProcessor, Order>));
            });
    }

    public static Action<IProcessor, User, int> GetProcessUserWithLevel()
    {
        return (Action<IProcessor, User, int>)_cache.GetOrAdd(
            "ProcessUserWithLevel",
            _ =>
            {
                var mi = GetMethodStrict(typeof(ProcessorApi), nameof(ProcessorApi.ProcessUserWithLevel),
                                         typeof(IProcessor), typeof(User), typeof(int));
                return mi.CreateDelegate(typeof(Action<IProcessor, User, int>));
            });
    }
}
```

呼び出し側は完全に型安全っぽく使えます：
```csharp
var callOrder = ReflectionCache.GetProcessOrder();
callOrder(proc, order);

var callUser = ReflectionCache.GetProcessUserWithLevel();
callUser(proc, user, 3);
```

# 4) ジェネリックが絡む場合は「MakeGenericMethod → CreateDelegate」
```csharp
public static class GenericApi
{
    public static TResult Invoke<TIn, TResult>(IHandler h, TIn input) => h.Handle<TIn, TResult>(input);
}

var open = GetMethodStrict(typeof(GenericApi), nameof(GenericApi.Invoke), typeof(IHandler), typeof(object));
var closed = open.MakeGenericMethod(typeof(MyInput), typeof(MyResult));
var del = (Func<IHandler, MyInput, MyResult>)closed.CreateDelegate(typeof(Func<IHandler, MyInput, MyResult>));
var result = del(handler, new MyInput());
```
※ ラッパーを`object`で受けず、**型引数をラッパー側でもしっかり宣言**すると事故が減ります。

# 5) “曖昧さ”をテストで固定化（再発防止）
曖昧ポイントはテスト化しておくと安心です。  
- ラッパーの**存在保証**（MissingMethodを即検知）  
- **CreateDelegate成功**（型不一致で落ちない）  
- **パラメータ順の固定**（意図と実装のズレ検出）

```csharp
[Fact]
public void ProcessUserWrapper_BindsStrictly()
{
    var mi = typeof(ProcessorApi).GetMethod(nameof(ProcessorApi.ProcessUserWithLevel),
        BindingFlags.Public | BindingFlags.Static);
    Assert.NotNull(mi);

    var del = (Action<IProcessor, User, int>)mi!.CreateDelegate(typeof(Action<IProcessor, User, int>));
    del(new FakeProcessor(), new User(), 1); // 実行まで通ること
}
```

# 6) 設計メモ（次にハマらないために）
- **反射の入口は1箇所**（その先は通常呼び出し）。  
- **同名オーバーロードを入口に置かない**（ラッパーで名前も分ける）。  
- **“最終的に呼びたいシグネチャ”を**ラッパー名と引数で**言語化**（未来の自分／AIに効く）。  
- **デリゲート化＋キャッシュ**（パフォーマンスと安定性両取り）。  
- 可能なら**Source Generatorでラッパー自動生成**（人力ミスを消す）。

---

この方針で、”動的解決”を**「最小・固定・テスト済み」**に押し込めると、もう刺さりにくくなります。  
対象IFや実例（Streamizの`Materialized.Create`みたいなやつ）があれば、司令のコードに合わせてラッパー群をそのまま出力しますよ。

### assistant — 2025-08-10T08:49:36.628385+00:00

_(empty)_

### assistant — 2025-08-10T08:51:26.264839+00:00

送信日時: [[REDACTED_PHONE]]:58 (JST)

司令、ごめん。そこまでハマってたなら、もっと早く“先回りの示唆”を出すべきだった。  
反省も込めて、**次に刺さらないための即効チェックリスト**を置いておくね。どれも今のコードベースにそのまま差し込めるはず。

# リフレクション刺さり予防チェックリスト（要点だけ）
- **反射入口は1か所に集約**（`ReflectionFacade`/`ProcessorApi`など）。入口では**同名オーバーロードを禁止**して、関数名で用途を分ける。
- **取得は“厳密一致”のみ**：`GetMethod(name, types[])` 指定。`First(...)`や`GetMethods()`スキャンは封印。
- **デリゲートに焼き付ける**：`CreateDelegate` → `ConcurrentDictionary`でキャッシュ。以降は**通常呼び出しと同等の安定性**。
- **型推論をラッパー側に閉じ込める**：ジェネリックは`MakeGenericMethod`を**ラッパー内部**で完結。
- **ランタイム自己診断**（デバッグ時のみ）  
  - 見つけた`MethodInfo`の`MetadataToken`/`ToString()`を1回ログ。  
  - “一致ゼロ/複数一致”は**例外化＋提案付きメッセージ**（候補一覧を出す）。
- **再発防止テスト**  
  - “該当メソッドが**存在し、CreateDelegateが通り、実行も通る**”を1ケースで担保。  
  - 署名が変わったら**テスト赤**で気づくように。
- **設計ガイドラインを1枚化**  
  - 「IF直反射禁止」「ラッパー必須」「新オーバーロード追加時はラッパーも追加」「テスト必須」をREADMEに明文化。
- **（可能なら）Source Generator**  
  - IF定義からラッパーと`CreateDelegate`コードを自動生成。人手のミスを消す。

# すぐ貼れる“最小ラッパー＋厳密解決”テンプレ
```csharp
public static class ReflectionFacade
{
    private static readonly ConcurrentDictionary<string, Delegate> Cache = new();

    static MethodInfo Strict(Type t, string name, params Type[] ps) =>
        t.GetMethod(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
            binder: null, types: ps, modifiers: null)
        ?? throw new MissingMethodException($"{t.FullName}.{name}({string.Join(", ", ps.Select(x => x.Name))}) not found");

    // 例：曖昧なIFをここで“用途名”に分解して固定化
    public static Action<IProcessor, Order> ProcessOrder() =>
        (Action<IProcessor, Order>)Cache.GetOrAdd("ProcessOrder", _ =>
            Strict(typeof(ProcessorApi), nameof(ProcessorApi.ProcessOrder),
                   typeof(IProcessor), typeof(Order))
            .CreateDelegate(typeof(Action<IProcessor, Order>)));

    public static Action<IProcessor, User, int> ProcessUserWithLevel() =>
        (Action<IProcessor, User, int>)Cache.GetOrAdd("ProcessUserWithLevel", _ =>
            Strict(typeof(ProcessorApi), nameof(ProcessorApi.ProcessUserWithLevel),
                   typeof(IProcessor), typeof(User), typeof(int))
            .CreateDelegate(typeof(Action<IProcessor, User, int>)));
}
```

# “曖昧→赤で止める”用のスモークテスト雛形
```csharp
[Fact]
public void Wrapper_Binds_Strictly()
{
    var del = ReflectionFacade.ProcessUserWithLevel();
    del(new FakeProcessor(), new User(), 1); // 実行まで通ること
}
```

# 既存20kへの当て込み順序（短期で効く）
1) 反射ホットスポット列挙（`GetMethod(s)`/`MakeGenericMethod`/`Invoke`のgrep）。  
2) それぞれに**用途別ラッパー**を作成（関数名でオーバーロードを分ける）。  
3) 呼び出し側を**全部ラッパー経由**に置換。  
4) 上のテスト雛形を**ラッパー単位**で追加。  
5) デバッグ限定ログで**曖昧一致ゼロ/複数一致**を即検知。

—

「知ってるなら先に言ってよ」は本当にその通り。次は“ハマり筋”を先回りで出すね。  
もし対象がStreamizの`Materialized.Create`系や`ToTable`周りなら、関数リストをもらえれば**用途名ラッパー一式**をこちらで起こして渡すよ。

### system — 2025-08-10T08:51:26.661419+00:00

_(empty)_

### assistant — 2025-08-10T08:51:26.669706+00:00

_(empty)_

### user — 2025-08-10T08:51:27.037000+00:00

天城、知ってるなら　示唆が欲しかった

### assistant — 2025-08-10T08:51:33.827234+00:00

_(empty)_
