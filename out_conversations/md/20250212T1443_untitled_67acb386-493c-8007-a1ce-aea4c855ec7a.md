---
conversation_id: "67acb386-493c-8007-a1ce-aea4c855ec7a"
title: "非同期データ処理改善策"
create_time: 1739371398.668711
update_time: 1739371513.476976
language_guess: "en"
num_messages: 5
part_index: 1
part_count: 1
---

### system — 2025-02-12T14:43:18.668711+00:00

_(empty)_

### user — 2025-02-12T14:43:18.681464+00:00

NETの処理で処理Aから処理Bへ非同期にデータを送る。処理Bは10ms間隔で送られたデータをまとめる処理を作る。処理AとBはBlockingCollectionを使用し、処理Bは10ms後にキャンセルをおこなうトークンをBlockingCollectonのパラメータとする処理を行った場合の問題点と改善策を提示

### assistant — 2025-02-12T14:45:11.677794+00:00

_(empty)_

### assistant — 2025-02-12T14:45:11.677933+00:00

### 問題点

1. **`BlockingCollection` のブロッキング動作**
   - `BlockingCollection<T>` は、データがない場合にスレッドをブロックする動作をします。これを `CancellationToken` で制御すると、10ms 毎に `Take` 操作がキャンセルされ、非効率的になる可能性があります。

2. **データが来ない場合の動作**
   - `BlockingCollection<T>.Take` は、データがないとブロックします。10ms のタイムアウトを設けるために `CancellationToken` を利用すると、データがまったくない場合に毎回 `OperationCanceledException` をキャッチしなければなりません。

3. **高頻度でのキャンセル**
   - 10ms 毎に `CancellationToken` をトリガーすると、`BlockingCollection` の `Take` 操作が頻繁にキャンセルされ、スレッドのコンテキスト切り替えが増えてオーバーヘッドが大きくなる可能性があります。

4. **データのバッチ処理の最適化**
   - `BlockingCollection` は FIFO のバッファとしては便利ですが、指定時間内に受け取ったすべてのデータを効率的にバッチ処理するには適していません。`GetConsumingEnumerable` を使用してデータを非同期に処理する場合、指定時間内のデータだけを取得するのが難しくなります。

---

### 改善策

#### **1. `GetConsumingEnumerable` + `Task.Delay` の組み合わせ**
`BlockingCollection.GetConsumingEnumerable` を用いてデータを逐次取得し、バッチ処理のタイミングを `Task.Delay(10ms)` で制御する方法。

```csharp
var collection = new BlockingCollection<int>();

Task.Run(async () =>
{
    var batch = new List<int>();
    while (!collection.IsCompleted)
    {
        if (collection.TryTake(out var item))
        {
            batch.Add(item);
        }

        await Task.Delay(10); // 10ms間隔でバッチ処理
        if (batch.Count > 0)
        {
            ProcessBatch(batch);
            batch.Clear();
        }
    }
});
```

**メリット**
- `CancellationToken` を使わずに 10ms 毎にバッチ処理を実行。
- `TryTake` を使うことで、データがない場合にブロックされることなく待機可能。

**デメリット**
- `Task.Delay` の精度によっては、厳密な 10ms にならない可能性がある。

---

#### **2. `BlockingCollection.TryTake` + `Stopwatch` を使用**
バッチ処理の時間を計測しながら、データを `BlockingCollection` から取得する方法。

```csharp
var collection = new BlockingCollection<int>();

Task.Run(() =>
{
    var batch = new List<int>();
    var stopwatch = Stopwatch.StartNew();

    while (!collection.IsCompleted)
    {
        while (stopwatch.ElapsedMilliseconds < 10)
        {
            if (collection.TryTake(out var item, 1)) // 1msの短いタイムアウト
            {
                batch.Add(item);
            }
        }

        if (batch.Count > 0)
        {
            ProcessBatch(batch);
            batch.Clear();
        }
        stopwatch.Restart();
    }
});
```

**メリット**
- `Task.Delay` を使わないため、バッチ処理のタイミングがより正確。
- `TryTake` の短いタイムアウト (`1ms`) を使うことで CPU の無駄な消費を抑える。

**デメリット**
- `Stopwatch` のオーバーヘッドがある。

---

#### **3. `Channel<T>` を利用**
.NET Core 3.0 以降では `System.Threading.Channels.Channel<T>` を使うことで、より適切な非同期キュー処理が可能。

```csharp
var channel = Channel.CreateUnbounded<int>();

async Task ProducerAsync()
{
    while (true)
    {
        await Task.Delay(5);
        await channel.Writer.WriteAsync(new Random().Next(100));
    }
}

async Task ConsumerAsync()
{
    var batch = new List<int>();
    var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(10));

    await foreach (var item in channel.Reader.ReadAllAsync())
    {
        batch.Add(item);

        if (await timer.WaitForNextTickAsync())
        {
            if (batch.Count > 0)
            {
                ProcessBatch(batch);
                batch.Clear();
            }
        }
    }
}

Task.Run(ProducerAsync);
Task.Run(ConsumerAsync);
```

**メリット**
- `Channel<T>` は `BlockingCollection<T>` よりも非同期処理に最適化されている。
- `PeriodicTimer` を使うことで、指定時間内のデータを確実にバッチ処理できる。
- `CancellationToken` を使わずに、10ms ごとの処理を簡潔に実装可能。

**デメリット**
- `Channel<T>` を利用するため、.NET Core 3.0 以降が必要。

---

### **結論**
- `BlockingCollection` を使う場合は `TryTake` を利用し、`Task.Delay(10)` で間隔を調整する方法が比較的簡単で効率的。
- 高精度が必要なら `Stopwatch` を使って `TryTake` を適切に制御。
- 最新の .NET であれば `Channel<T>` を活用し、`PeriodicTimer` を組み合わせるのが最適。

**推奨**
- .NET 5 以降を使用しているなら、 `Channel<T>` を使うのがベスト。
- .NET Framework など `Channel<T>` がない場合、`BlockingCollection<T>` + `TryTake` + `Task.Delay(10)` の組み合わせが適切。
