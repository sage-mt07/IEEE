---
conversation_id: "67166333-9f7c-8007-8536-53ffcd56ba7b"
title: "Net8 Entra ID 認証コード"
create_time: 1729520435.901264
update_time: 1729520792.339601
language_guess: "en"
num_messages: 13
part_index: 1
part_count: 1
---

### system — 2024-10-21T14:20:35.901264+00:00

_(empty)_

### user — 2024-10-21T14:20:35.913208+00:00

net8でentraid認証を利用するコードを示せ

### assistant — 2024-10-21T14:21:14.727894+00:00

_(empty)_

### assistant — 2024-10-21T14:21:14.728031+00:00

Entra ID（旧称：Azure AD）を利用して、.NET 8のアプリケーションで認証を行うコードの例を示します。この例では、Entra IDとASP.NET Core Web APIの統合を行い、APIの認証を実装します。以下のコードでは、`Microsoft.Identity.Web`を使用してEntra ID認証を構成します。

### 1. 必要なパッケージのインストール
まず、`Microsoft.Identity.Web`と`Microsoft.AspNetCore.Authentication.JwtBearer`のパッケージをインストールします。

```bash
dotnet add package Microsoft.Identity.Web
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

### 2. `appsettings.json`の設定
Entra IDの情報を`appsettings.json`に追加します。以下の例では、Entra IDのクライアントID、テナントID、クライアントシークレットなどを設定します。

```json
{
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "Domain": "yourdomain.onmicrosoft.com",
    "TenantId": "your-tenant-id",
    "ClientId": "your-client-id",
    "ClientSecret": "your-client-secret"
  }
}
```

- `Instance`: 認証エンドポイントのベースURL。
- `Domain`: Entra IDのドメイン名。
- `TenantId`: テナントID。
- `ClientId`: アプリケーションのクライアントID。
- `ClientSecret`: クライアントシークレット（クライアント認証で必要）。

### 3. `Program.cs`の設定
認証ミドルウェアと認可ポリシーを追加します。

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Identity.Web;

var builder = WebApplication.CreateBuilder(args);

// Azure AD 認証の設定を追加
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection("AzureAd"));

builder.Services.AddAuthorization(options =>
{
    options.FallbackPolicy = options.DefaultPolicy;
});

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseAuthentication();  // 認証ミドルウェアを追加
app.UseAuthorization();   // 認可ミドルウェアを追加

app.MapControllers();

app.Run();
```

### 4. コントローラの設定
認証されたユーザーのみがアクセスできるエンドポイントを定義します。

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class SampleController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        return Ok("Authenticated request!");
    }
}
```

上記のコントローラは、`[Authorize]`属性を使用して、認証済みのリクエストのみを許可します。

### 5. `appsettings.Development.json`の設定（開発用）
開発環境で実行する場合は、`appsettings.Development.json`を設定して、ローカル環境のシークレットを上書きすることも可能です。

```json
{
  "AzureAd": {
    "ClientId": "your-client-id-for-development",
    "TenantId": "your-tenant-id-for-development",
    "ClientSecret": "your-client-secret-for-development"
  }
}
```

### 6. Azureポータルでのアプリ登録
1. Azureポータルにアクセスして、Entra ID（Azure AD）のアプリ登録を行います。
2. クライアントIDとテナントIDを取得します。
3. 認証用のリダイレクトURIを設定し、APIアクセス権を構成します。

このコードを使用して、.NET 8アプリケーションでEntra IDを使用した認証が構成されます。クライアントからAPIにリクエストを送る際には、JWTトークンを取得してリクエストヘッダーに`Authorization: Bearer <token>`として追加する必要があります。

### user — 2024-10-21T14:21:48.023529+00:00

builder.Services.AddAuthorization(options =>
{
    options.FallbackPolicy = options.DefaultPolicy;
});
でその他のオプションを示せ

### assistant — 2024-10-21T14:22:42.430280+00:00

`builder.Services.AddAuthorization`の`options`には、さまざまなオプションを設定して、認可ポリシーや要件を細かくカスタマイズできます。以下に、いくつかの一般的なオプションを示します。

### 1. `FallbackPolicy`
`FallbackPolicy`は、認可ポリシーが明示的に指定されていない場合に使用されるポリシーを設定します。以下の例では、認証を必須とするデフォルトポリシーを設定しています。

```csharp
builder.Services.AddAuthorization(options =>
{
    options.FallbackPolicy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser()
        .Build();
});
```
- これにより、特定のポリシーが指定されていないすべてのエンドポイントで、認証されたユーザーのみがアクセスできるようになります。

### 2. `DefaultPolicy`
`DefaultPolicy`は、`[Authorize]`属性を明示的に指定したときに適用されるデフォルトの認可ポリシーです。たとえば、デフォルトポリシーに特定のクレームを要求するように設定できます。

```csharp
builder.Services.AddAuthorization(options =>
{
    options.DefaultPolicy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser()
        .RequireClaim("role", "Admin")
        .Build();
});
```
- 上記の例では、`[Authorize]`が付与されたエンドポイントにアクセスするユーザーは、`role`クレームが`Admin`である必要があります。

### 3. カスタムポリシーの定義
カスタムポリシーを定義して、特定の条件を満たすユーザーにのみアクセスを許可することができます。たとえば、特定のスコープを持つユーザーのみを許可するポリシーを定義します。

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("RequireAdminScope", policy =>
        policy.RequireAuthenticatedUser()
              .RequireClaim("scp", "admin_access"));
});
```
- この例では、`RequireAdminScope`という名前のポリシーを定義しています。このポリシーは、`scp`クレームに`admin_access`が含まれている認証済みユーザーのみを許可します。

### 4. ロールベースのポリシー
ロールベースの認可ポリシーを設定することも可能です。たとえば、`Admin`または`Manager`のロールを持つユーザーを許可するポリシーを定義します。

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOrManagerPolicy", policy =>
        policy.RequireRole("Admin", "Manager"));
});
```
- これにより、`[Authorize(Policy = "AdminOrManagerPolicy")]`を使用したエンドポイントには、`Admin`または`Manager`のロールを持つユーザーのみがアクセスできます。

### 5. カスタム要件とハンドラの設定
より高度なシナリオでは、独自の認可要件（`IAuthorizationRequirement`）を定義し、カスタムハンドラ（`AuthorizationHandler`）を使用して複雑なロジックを実装できます。

```csharp
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int MinimumAge { get; }
    public MinimumAgeRequirement(int minimumAge)
    {
        MinimumAge = minimumAge;
    }
}

public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, MinimumAgeRequirement requirement)
    {
        if (context.User.HasClaim(c => c.Type == "DateOfBirth"))
        {
            var dateOfBirth = DateTime.Parse(context.User.FindFirst(c => c.Type == "DateOfBirth").Value);
            int calculatedAge = DateTime.Today.Year - dateOfBirth.Year;
            if (calculatedAge >= requirement.MinimumAge)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
}
```

このカスタム要件とハンドラを使って認可ポリシーを設定します。

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AtLeast18", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

// ハンドラをDIコンテナに登録
builder.Services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();
```

- この例では、ユーザーが`DateOfBirth`クレームを持ち、18歳以上である場合にのみアクセスを許可する`AtLeast18`というポリシーを定義しています。

### 6. ポリシーを複数設定する例
複数のカスタムポリシーを一度に設定することも可能です。

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("RequireAdmin", policy =>
        policy.RequireRole("Admin"));
    options.AddPolicy("RequireUser", policy =>
        policy.RequireAuthenticatedUser());
    options.AddPolicy("RequireAdminOrUser", policy =>
        policy.RequireRole("Admin").RequireRole("User"));
});
```

- `RequireAdmin`: `Admin`ロールを持つユーザーのみを許可。
- `RequireUser`: 認証済みのユーザーを許可。
- `RequireAdminOrUser`: `Admin`または`User`ロールを持つユーザーを許可。

### まとめ
`AddAuthorization`メソッドを使用することで、認可ポリシーの柔軟なカスタマイズが可能です。`FallbackPolicy`や`DefaultPolicy`を使うことで、デフォルトの動作を設定したり、特定の要件に応じたポリシーを追加したりできます。これにより、アプリケーションのセキュリティ要件に合わせて認可の仕組みを最適化できます。

### user — 2024-10-21T14:23:00.521276+00:00

ID発行者を確認するコードはあるのか

### assistant — 2024-10-21T14:23:42.125790+00:00

はい、JWT（JSON Web Token）を解析してIDトークンの発行者を確認するコードを作成できます。ASP.NET Coreで`Microsoft.Identity.Web`を使用している場合、JWTトークンの検証や解析のためにいくつかの方法が提供されています。

以下に、IDトークンの発行者を確認する方法を示します。この例では、`User.Claims`を使用して、トークン内の`iss`クレーム（発行者のクレーム）を取得します。

### 1. クレームから発行者を確認する方法
`HttpContext.User`を使用して、現在のユーザーのクレームを取得し、`iss`クレームを確認する方法です。

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Linq;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class IdentityController : ControllerBase
{
    [HttpGet("issuer")]
    public IActionResult GetIssuer()
    {
        var issuer = User.Claims.FirstOrDefault(c => c.Type == "iss")?.Value;

        if (issuer != null)
        {
            return Ok($"Issuer: {issuer}");
        }
        else
        {
            return NotFound("Issuer claim not found.");
        }
    }
}
```

- `User.Claims`から、`iss`クレームを検索しています。
- `iss`クレームは、トークンの発行者を示すクレームです。
- このエンドポイントにアクセスすると、認証されたユーザーのトークンから`iss`クレームを取得し、発行者のURL（通常、Entra IDのテナントIDを含むURL）が返されます。

### 2. トークンの手動解析
トークンを手動で解析して、発行者を確認することもできます。例えば、`System.IdentityModel.Tokens.Jwt`を使ってJWTを解析できます。

```csharp
using System.IdentityModel.Tokens.Jwt;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class IdentityController : ControllerBase
{
    [HttpGet("token-issuer")]
    public IActionResult GetTokenIssuer()
    {
        var authorizationHeader = Request.Headers["Authorization"].ToString();

        if (string.IsNullOrEmpty(authorizationHeader) || !authorizationHeader.StartsWith("Bearer "))
        {
            return BadRequest("Authorization header is missing or invalid.");
        }

        var token = authorizationHeader.Substring("Bearer ".Length).Trim();
        var jwtToken = new JwtSecurityTokenHandler().ReadJwtToken(token);

        var issuer = jwtToken.Issuer;

        return Ok($"Issuer: {issuer}");
    }
}
```

- このコードでは、リクエストヘッダーからJWTトークンを取得し、`JwtSecurityTokenHandler`でトークンを解析しています。
- `jwtToken.Issuer`を使用して、トークンの発行者を取得します。
- クライアントから`Authorization`ヘッダーに`Bearer <トークン>`の形式でJWTトークンを付与してリクエストを行う必要があります。

### 3. `Microsoft.Identity.Web`を使用する場合の自動検証
`Microsoft.Identity.Web`を使用すると、ASP.NET Coreアプリケーションの認証ミドルウェアが自動的にトークンの`iss`（発行者）や`aud`（対象）を検証します。`appsettings.json`に設定した`Instance`と`TenantId`によって、認証ミドルウェアは発行者が正しいかどうかを確認します。

以下の設定で、`IssuerValidator`をカスタマイズして追加の検証を行うこともできます。

```csharp
builder.Services.Configure<JwtBearerOptions>(JwtBearerDefaults.AuthenticationScheme, options =>
{
    options.TokenValidationParameters.IssuerValidator = (issuer, securityToken, validationParameters) =>
    {
        // カスタム検証ロジックを追加する
        if (issuer != "https://login.microsoftonline.com/your-tenant-id/v2.0")
        {
            throw new SecurityTokenInvalidIssuerException("Invalid issuer.");
        }
        return issuer;
    };
});
```

- `TokenValidationParameters.IssuerValidator`を設定することで、発行者のカスタム検証ロジックを追加できます。
- `SecurityTokenInvalidIssuerException`をスローすることで、発行者が期待するものと異なる場合にエラーを返します。

このようにして、.NET 8のアプリケーションでIDトークンの発行者を確認することが可能です。クレームの取得、トークンの解析、あるいはカスタム検証を行うことで、発行者に関する詳細な情報を取得・検証できます。

### user — 2024-10-21T14:23:58.486995+00:00

トークンの改ざん対策は

### assistant — 2024-10-21T14:24:55.606756+00:00

トークンの改ざん対策としては、JWT（JSON Web Token）における署名の検証や、適切なトークン管理とセキュリティ対策が重要です。以下に、具体的な対策方法を示します。

### 1. **JWT署名の検証**
   - JWTは、発行者（認証サーバー）が署名を付与して発行します。トークンの受信側（APIサーバー）は、その署名を検証することで、トークンが改ざんされていないことを確認できます。
   - JWTには以下の3つのパートがあります：
     - ヘッダー（Header）
     - ペイロード（Payload）
     - 署名（Signature）
   - 署名は、ヘッダーとペイロードを秘密鍵または共有鍵でハッシュ化したもので、これにより改ざん検知が可能です。
   
   .NETでは、`Microsoft.Identity.Web`や`JwtBearer`ミドルウェアを使用することで、署名の検証が自動で行われます。

   ```csharp
   builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
       .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection("AzureAd"));
   ```

   - この設定により、`AzureAd`設定に基づいてトークンの署名を自動で検証します。
   - もしトークンが改ざんされている場合、署名の検証に失敗し、`401 Unauthorized`エラーが返されます。

### 2. **トークンの有効期限の設定**
   - トークンが長期間有効であると、漏洩した場合のリスクが高まります。トークンの有効期限を短く設定することで、リスクを低減できます。
   - Entra ID（Azure AD）では、トークンの有効期限を管理ポータルで設定できます。
   - 有効期限が切れたトークンは再利用できないため、短い有効期限とリフレッシュトークンを組み合わせることで、セキュリティを強化できます。

### 3. **`Audience`と`Issuer`の検証**
   - `aud`（対象者）と`iss`（発行者）は、トークンが誰のために発行され、どこから発行されたかを示します。これらを検証することで、トークンが正しい発行元からのものであり、想定されたアプリケーションのために発行されたことを確認できます。

   ```csharp
   builder.Services.Configure<JwtBearerOptions>(JwtBearerDefaults.AuthenticationScheme, options =>
   {
       options.TokenValidationParameters = new TokenValidationParameters
       {
           ValidateIssuer = true,
           ValidIssuer = "https://login.microsoftonline.com/your-tenant-id/v2.0",
           ValidateAudience = true,
           ValidAudience = "your-client-id",
           ValidateLifetime = true,
           ValidateIssuerSigningKey = true
       };
   });
   ```

   - `ValidateIssuer`と`ValidateAudience`を有効にして、指定した発行者と対象者に対する検証を行います。
   - これにより、期待しない発行元や対象者のトークンを弾くことができます。

### 4. **HTTPSの使用**
   - トークンはHTTPヘッダーで送信されるため、通信経路で盗聴されるリスクがあります。通信を暗号化するために、必ずHTTPSを使用して通信を保護します。
   - HTTPSを使用することで、トークンがインターネットを経由して転送される際に改ざんや盗聴を防止できます。

### 5. **トークンの再利用防止（Replay Attack対策）**
   - トークンの再利用を防止するために、トークンの利用記録を管理し、一度使われたトークンを再度受け付けない仕組みを導入することも有効です。
   - 一例として、トークンの発行時にサーバー側でセッションや利用履歴を保存し、リクエストごとに検証する方法があります。ただし、JWTの特性上ステートレスな処理が好まれるため、アプローチによってはトークンの利便性とセキュリティのバランスを考慮する必要があります。

### 6. **署名キーの保護**
   - トークンの署名に使用する秘密鍵や共有鍵は、適切に保護する必要があります。Azure Key Vaultなどのセキュアなストレージに保存し、アクセス制限を設けることで、不正なアクセスや漏洩を防ぎます。
   - APIサーバーで秘密鍵を直接使用する場合は、環境変数やAzure Managed Identityを使用して、コードに直接記載しないようにすることが推奨されます。

### 7. **トークンのブラックリスト化**
   - もし特定のトークンが漏洩した場合、そのトークンをブラックリストに登録して無効化することも可能です。これにより、ブラックリストに登録されたトークンを使用したリクエストを拒否することができます。
   - これを実装するには、サーバー側でトークンのリストを管理し、各リクエストでブラックリストに登録されていないかをチェックします。ただし、ステートレスなJWTの特性に反するため、実装には注意が必要です。

### まとめ
トークンの改ざん対策としては、以下のポイントを押さえることが重要です：
- JWT署名の検証を適切に行う
- トークンの有効期限を短く設定し、リフレッシュトークンと組み合わせる
- `aud`と`iss`の検証で不正なトークンを弾く
- HTTPSで通信を暗号化する
- 署名に使用するキーをセキュアに管理する

これらの対策を組み合わせることで、トークンの改ざんリスクを効果的に軽減できます。特に、JWTの特性を理解し、それに合ったセキュリティ対策を実装することが重要です。

### user — 2024-10-21T14:25:55.145555+00:00

JWT署名の検証はEntra IDにリクエストをおこなうのか

### assistant — 2024-10-21T14:26:30.633216+00:00

いいえ、JWTの署名の検証は、通常、Entra IDにリクエストを行うことなく、サーバー側で行います。

### JWT署名の検証の仕組み
JWTトークンは、Entra ID（または他の認証プロバイダー）によって署名されて発行されます。この署名を検証するために、認証プロバイダー（Entra ID）が公開している公開鍵（公開鍵証明書）を利用します。

具体的な流れは以下のとおりです：

1. **トークンの受け取り**：
   - クライアントが取得したJWTトークンをAPIサーバーに送信します。このトークンは`Authorization`ヘッダーに含められ、`Bearer <token>`という形式になります。

2. **公開鍵証明書の取得**：
   - Entra IDは公開鍵証明書をJWK（JSON Web Key）形式で提供しています。これはAzureポータルで公開されており、一般にURLを通じて取得できます。
   - URLの形式は次のようになります（`your-tenant-id`は実際のテナントIDに置き換えます）：
     ```
     https://login.microsoftonline.com/{your-tenant-id}/discovery/v2.0/keys
     ```

3. **公開鍵のキャッシュ**：
   - `Microsoft.Identity.Web`や`JwtBearer`ミドルウェアを使用する場合、この公開鍵を自動的に取得してキャッシュします。証明書の取得は一度だけ行い、以降はキャッシュされた情報を使って署名の検証を行います。
   - 通常、これによってサーバーの起動時または証明書の有効期限が切れたときに新たに取得されますが、リクエストごとにEntra IDにアクセスすることはありません。

4. **署名の検証**：
   - トークンがサーバーに送信されると、`JwtBearer`ミドルウェアが公開鍵を使用して、JWTの署名が正しいかどうかを検証します。
   - この検証により、トークンのヘッダーとペイロードが改ざんされていないことを確認できます。
   - 署名が有効でない場合や、公開鍵が一致しない場合、署名検証に失敗し、リクエストは`401 Unauthorized`エラーとなります。

### サンプルコード
ASP.NET Coreで`JwtBearer`を使用した場合のコード例です。

```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://login.microsoftonline.com/{your-tenant-id}/v2.0";
        options.Audience = "your-client-id"; // APIのクライアントIDを指定
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true
        };
    });
```

- **`Authority`**:
  - `Authority`に`https://login.microsoftonline.com/{your-tenant-id}/v2.0`を指定することで、Entra IDから公開鍵情報を自動的に取得します。
- **`Audience`**:
  - `Audience`はトークンが発行された対象（APIのクライアントID）を指定します。
- **`TokenValidationParameters`**:
  - `ValidateIssuerSigningKey`を`true`にすることで、署名の検証が行われます。
  - この設定により、トークンの署名が検証され、改ざんがないかをチェックします。

### まとめ
- JWTの署名の検証は、サーバー側で公開鍵を使用して行います。
- 公開鍵の取得は通常、Entra IDから自動的に取得してキャッシュされますが、リクエストごとにEntra IDに問い合わせるわけではありません。
- これにより、ネットワークオーバーヘッドを減らし、パフォーマンスが向上します。

このプロセスにより、JWTトークンが改ざんされていないことを、サーバー側で効率的に検証できます。
