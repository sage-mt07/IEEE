---
conversation_id: "6874abb7-7480-8007-b357-2d94749e718f"
title: "SSMS カスタムプロバイダー設定"
create_time: 1752476599.691892
update_time: 1752478101.548347
language_guess: "en"
num_messages: 12
part_index: 1
part_count: 1
---

### user — 2025-07-14T07:03:18.474000+00:00

SSMSでcustomproviderを使用し暗号化テーブルを参照させる方法

### system — 2025-07-14T07:03:19.691892+00:00

_(empty)_

### user — 2025-07-14T07:03:19.691892+00:00

_(empty)_

### assistant — 2025-07-14T07:03:21.850923+00:00

🕙 2025年7月14日 16:24（日本時間）

やあ、司令！  
SSMS（SQL Server Management Studio）で **カスタムキー・ストアプロバイダー（custom provider）を使用して暗号化テーブルを参照する方法** を以下に整理します。対象は「**Always Encrypted with custom key store provider**」で暗号化された列を参照するための構成です。

---

## ✅ 前提条件

- SQL Server は Always Encrypted 機能をサポートしている（2016以降）
- 対象列が Always Encrypted で暗号化されている
- カスタムプロバイダー（例：Azure Key Vault, HSMなど）を使用して Column Master Key（CMK）を構成している
- カスタムプロバイダー用の `.NET アセンブリ` が用意されている

---

## 🛠 SSMSでの参照手順（custom provider対応）

### ① SSMSのバージョンを確認
- **SSMS 18.0以降**（できれば最新版）を使用。
- `Always Encrypted` に対応し、**カスタムプロバイダーを認識する.NETクライアント**が必要。

---

### ② カスタムプロバイダーDLLの配置

1. **カスタムキー・ストア・プロバイダーの.NET DLL**（例：`MyCustomProvider.dll`）をローカルに用意  
2. SSMSの実行ユーザーがこのDLLにアクセスできるようにする
3. DLLをGACに登録する必要はなし（.NET Core/Framework依存）

---

### ③ SSMSの起動に環境変数を付与（重要）

SSMSはデフォルトでカスタムプロバイダーをロードしないため、以下のように環境変数を設定して起動する必要があります：

#### 方法A：バッチファイルで起動
```bat
@echo off
setx /M ColumnEncryption_Enabled "True"
setx /M AE_KeyStore_ProviderPath "C:\Path\To\MyCustomProvider.dll"
start "" "C:\Program Files (x86)\Microsoft SQL Server Management Studio 18\Common7\IDE\Ssms.exe"
```

#### 方法B：システム環境変数として設定（再起動必要）

| 変数名 | 値 |
|--------|----|
| `ColumnEncryption_Enabled` | `True` |
| `AE_KeyStore_ProviderPath` | `C:\Path\To\MyCustomProvider.dll` |

> 環境変数を設定してからSSMSを再起動しないと反映されません。

---

### ④ 接続時のオプション設定（接続プロパティ）

SSMSの接続プロパティで以下を確認：

- [接続プロパティ] タブ → **Always Encryptedを有効にする** にチェック
- 必要であれば、認証情報も設定（プロバイダーがKeyVaultなど外部認証を使用する場合）

---

### ⑤ テーブル参照

これで、暗号化列を含むテーブルを `SELECT` しても、自動的に復号された値が見えるようになります。

> カラムが `nvarchar(50) COLLATE Latin1_General_BIN2` のような指定になっていても、データは復号されて見えます。

---

## 🧪 補足：確認ポイント

- プロバイダーの実装で `IColumnMasterKeyStoreProvider` を正しく実装しているか？
- ログを有効にして、プロバイダー呼び出しエラーが出ていないか確認する（`SSMS log file` / Application Event Log）

---

## 💡 参考資料

- [公式ドキュメント：Always Encrypted with Custom Key Store Providers (Microsoft)](https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/extensibility-model-for-key-store-providers)
- `SSMS.exe.config` を修正する方法もあるが非推奨（環境変数方式の方が安全）

---

必要なら、**Azure Key Vaultプロバイダー** や **HSM接続用カスタムプロバイダーのサンプルコード**も提示できます。必要な種類を教えてください！

どうぞ、他にも気になることがあれば何でも聞いてください〜

### assistant — 2025-07-14T07:03:31.732577+00:00

_(empty)_

### user — 2025-07-14T07:06:25.777000+00:00

このDLLの形式は？

### assistant — 2025-07-14T07:06:27.593025+00:00

🕙 2025年7月14日 16:30（日本時間）

司令、いい質問です！

## ✅ カスタムキー・ストア・プロバイダー DLL の形式

### 🔧 必須仕様（形式・実装条件）

1. **.NET Framework 向けのクラスライブラリ DLL**
   - 通常は **.NET Framework 4.6 以上**（SSMSが利用するSqlClientの互換性）
   - **.NET Core用DLLはSSMSでは基本的に使えません**（SSMS自体が.NET Frameworkで動作）

2. **実装インターフェース**
   - `System.Data.SqlClient.IColumnMasterKeyStoreProvider`  
     または `Microsoft.Data.SqlClient.IColumnMasterKeyStoreProvider`
   - これを **publicクラスで実装**して、SSMSから利用可能なようにする必要があります。

```csharp
public class MyCustomProvider : System.Data.SqlClient.IColumnMasterKeyStoreProvider
{
    public override byte[] EncryptColumnMasterKey(string masterKeyPath, string encryptionAlgorithm, byte[] plaintextColumnMasterKey)
    {
        // 実装例（Key VaultやHSMへの接続）
    }

    public override byte[] DecryptColumnMasterKey(string masterKeyPath, string encryptionAlgorithm, byte[] encryptedColumnMasterKey)
    {
        // 復号処理
    }

    public override bool IsSupportedColumnMasterKeyStore(string masterKeyPath) => true;

    public override string[] GetSupportedKeyStorePaths() => new[] { "CustomProviderPath" };
}
```

---

### 📁 DLLの配置について

- **ファイル名：** 任意（例：`MyCustomKeyStoreProvider.dll`）  
- **配置先：** 環境変数 `AE_KeyStore_ProviderPath` に設定するフルパス

例：
```cmd
setx /M AE_KeyStore_ProviderPath "C:\KeyProviders\MyCustomKeyStoreProvider.dll"
```

---

### ✅ 追加オプション（複数DLL・ログ有効化）

必要に応じて以下も環境変数で指定できます：

- `AE_KeyStore_ProviderName`  
  利用したいプロバイダークラス名（例：`MyCustomProvider`）

---

## ☑ 補足：デバッグ用ログの出力

プロバイダーの呼び出し失敗時、以下の方法でログを確認可能：

- SSMSの起動オプションに `/log` をつける（例：`ssms.exe /log`）
- Windowsの **イベントビューア → アプリケーションログ** を確認

---

DLLのテンプレートコードや、Key Vault 向けの参考実装も必要であればすぐ出せます！どのプロバイダーを使いたいか教えてくださいね。

### user — 2025-07-14T07:09:42.260000+00:00

pfxの指定方法

### assistant — 2025-07-14T07:09:43.684386+00:00

🕙 2025年7月14日 16:38（日本時間）

司令、`PFX（.pfx）証明書ファイル` を使って **Always Encrypted の Column Master Key（CMK）を構成する custom provider** を自作し、**SSMSからPFXを利用して復号できるようにする方法**を説明します。

---

## ✅ 方針概要：PFXベースのカスタムプロバイダーを作成してSSMSに組み込む

- **PFX証明書** には秘密鍵が含まれており、これを使ってCMKを復号
- PFXのパス、パスワードを `.dll` 側に持たせる（または環境変数等で外部注入）

---

## 🏗 必要な構成要素

### ① カスタムプロバイダー DLL（例：`PfxKeyStoreProvider.dll`）

```csharp
public class PfxKeyStoreProvider : IColumnMasterKeyStoreProvider
{
    private readonly string _pfxPath;
    private readonly string _pfxPassword;

    public PfxKeyStoreProvider()
    {
        _pfxPath = Environment.GetEnvironmentVariable("MY_PFX_PATH");
        _pfxPassword = Environment.GetEnvironmentVariable("MY_PFX_PASSWORD");
    }

    private X509Certificate2 LoadCertificate()
    {
        return new X509Certificate2(_pfxPath, _pfxPassword, X509KeyStorageFlags.MachineKeySet);
    }

    public override byte[] DecryptColumnMasterKey(string masterKeyPath, string encryptionAlgorithm, byte[] encryptedColumnMasterKey)
    {
        using var cert = LoadCertificate();
        using var rsa = cert.GetRSAPrivateKey();
        return rsa.Decrypt(encryptedColumnMasterKey, RSAEncryptionPadding.OaepSHA1);
    }

    public override byte[] EncryptColumnMasterKey(string masterKeyPath, string encryptionAlgorithm, byte[] plaintextColumnMasterKey)
    {
        using var cert = LoadCertificate();
        using var rsa = cert.GetRSAPublicKey();
        return rsa.Encrypt(plaintextColumnMasterKey, RSAEncryptionPadding.OaepSHA1);
    }

    public override bool IsSupportedColumnMasterKeyStore(string masterKeyPath) => masterKeyPath == "pfx";
    public override string[] GetSupportedKeyStorePaths() => new[] { "pfx" };
}
```

---

### ② SSMSでPFXを使う環境変数設定

```bat
setx /M ColumnEncryption_Enabled "True"
setx /M AE_KeyStore_ProviderPath "C:\Path\To\PfxKeyStoreProvider.dll"
setx /M MY_PFX_PATH "C:\Keys\mycert.pfx"
setx /M MY_PFX_PASSWORD "yourPfxPassword"
```

> ⚠ パスワードの取り扱いには注意。環境変数ではなく、`Credential Store`や`DPAPI`で保護するのが理想。

---

### ③ SQL Server 側の CMK 構成

```sql
CREATE COLUMN MASTER KEY [PfxCMK]
WITH (
    KEY_STORE_PROVIDER_NAME = N'PfxKeyStoreProvider',
    KEY_PATH = N'pfx'
);
```

> `KEY_PATH = 'pfx'` のように DLL 側の `IsSupportedColumnMasterKeyStore()` でマッチする文字列にしておけばOK。

---

## 🧪 テストの流れ

1. カスタムプロバイダーDLLをビルド
2. DLL配置 & 環境変数設定
3. SSMS再起動
4. 接続オプションで「Always Encrypted を有効」にチェック
5. 対象の暗号化テーブルをSELECT → 復号されたデータが見える

---

## 🛡 セキュリティ補足

- PFXファイルを **読み取り制限**（自分のみ）にすること
- **パスワード平文管理は避ける**（生で環境変数に入れない場合、`Windows Credential Store`連携なども検討）

---

ご希望があればこの DLL の **完全なVisual Studioプロジェクトテンプレート** をすぐ生成できます！  
どうしますか？（`dll + sql + bat` セットで渡せます）

### user — 2025-07-14T07:27:50.405000+00:00

CredentialStoreの保護例を見せて

### assistant — 2025-07-14T07:27:51.398197+00:00

🕙 2025年7月14日 16:45（日本時間）

了解です、司令。  
ここでは、`PFXパスワード`を**Windows Credential Manager（Credential Store）で安全に保護して読み取る例**を示します。  
これにより、環境変数や平文ファイルを使わずにセキュアにパスワードを注入できます。

---

## ✅ 構成方針

1. **ユーザーのWindows資格情報ストア**に、`PfxPassword` を登録  
2. カスタムプロバイダー（.dll）側で `CredentialManager` API を使ってそれを取得  
3. パスワードは `.pfx` ロード時に使用される

---

## 🔐 Step 1: Windows Credential Manager に登録

### コマンドプロンプトで登録（例）
```cmd
cmdkey /add:PfxPassword /user:PFX_USER /pass:yourStrongPfxPassword
```

- `PfxPassword`：資格情報名（任意）
- `PFX_USER`：ユーザー名（任意。読み出しには使用されない）
- `yourStrongPfxPassword`：登録したいパスワード

---

## 💻 Step 2: .NETコードで資格情報を取得して利用

```csharp
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography.X509Certificates;

public class PfxKeyStoreProvider : System.Data.SqlClient.IColumnMasterKeyStoreProvider
{
    private string LoadPasswordFromCredentialManager(string target)
    {
        var cred = CredentialReader.GetCredential(target);
        return cred?.Password;
    }

    private X509Certificate2 LoadCertificate()
    {
        string pfxPath = @"C:\Keys\mycert.pfx";
        string password = LoadPasswordFromCredentialManager("PfxPassword");
        return new X509Certificate2(pfxPath, password, X509KeyStorageFlags.MachineKeySet);
    }

    // 以下 Encrypt/Decrypt 実装（略）
}
```

---

## 🔧 補助クラス：CredentialReader（Credential Manager API使用）

```csharp
public class CredentialReader
{
    public static NetworkCredential GetCredential(string targetName)
    {
        if (!CredRead(targetName, 1, 0, out var pCred))
            return null;

        var cred = (CREDENTIAL)Marshal.PtrToStructure(pCred, typeof(CREDENTIAL));
        string password = Marshal.PtrToStringUni(cred.CredentialBlob, (int)cred.CredentialBlobSize / 2);
        return new NetworkCredential(cred.UserName, password);
    }

    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    private static extern bool CredRead(string target, int type, int reservedFlag, out IntPtr credentialPtr);

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct CREDENTIAL
    {
        public int Flags;
        public int Type;
        public string TargetName;
        public string Comment;
        public long LastWritten;
        public int CredentialBlobSize;
        public IntPtr CredentialBlob;
        public int Persist;
        public int AttributeCount;
        public IntPtr Attributes;
        public string TargetAlias;
        public string UserName;
    }
}
```

---

## ✅ 実行結果とセキュリティ効果

- DLLはパスワードをハードコードせず、Windows Credential Managerから取得
- SSMSはこのプロバイダーを通じて `.pfx` をロード、暗号化列を復号可能に
- **ユーザー以外はパスワードにアクセスできない**

---

## 🔐 補足

- `CredentialBlob` に格納されるパスワードは **メモリ上では平文**なので、DLL側の使用後は**即座にクリア推奨**
- `TargetName` は一意にしておくと複数PFXに対応できる

---

必要であれば、上記コード一式＋登録バッチスクリプト付きの VS プロジェクトをすぐ出力します。  
どうされますか？
