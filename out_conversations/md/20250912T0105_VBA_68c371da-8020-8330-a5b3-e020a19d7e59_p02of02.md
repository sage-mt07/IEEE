---
conversation_id: "68c371da-8020-8330-a5b3-e020a19d7e59"
title: "VBA移行時の変更点"
create_time: 1757639132.499973
update_time: 1757655283.586149
language_guess: "en"
num_messages: 259
part_index: 2
part_count: 2
---

### 3. 画面タイミング依存 (SendKeys / DoEvents)
- `SendKeys`: フォーカス/タイミング依存で不安定
- `DoEvents`: UI応答は改善するが割り込みリスク
- **回避策**
  - オブジェクトモデルで直接処理 (`Workbooks.Open` 等)
  - 状態監視・Wait・Repaint で置き換え
  - 長時間処理は `OnTime` で分割実行
### system — 2025-09-12T05:05:18.840200+00:00

_(empty)_
### assistant — 2025-09-12T05:05:18.891135+00:00

司令、はい、それも **「Windows 11 / M365 環境でのVBA移行配慮点」**に含めるのが正しいです 👍  

---

## ✅ 3. 画面タイミング依存 (SendKeys / DoEvents)
### 問題点
- **`SendKeys`**
  - 入力をキーボードイベントとしてOSに送るだけの仕組み。  
  - **ウィンドウフォーカス**や**UIの状態**に強く依存するため、OSバージョンや画面遷移速度の差で簡単に失敗する。  
  - Windows 11 + M365 でも同様に不安定で、推奨されない。  

- **`DoEvents`**
  - メッセージループを処理するため、UIがフリーズせず操作できる。  
  - ただし「任意の処理が割り込んで走る」リスクがあり、意図しないユーザー操作や再入による不整合が発生し得る。  
  - マルチスレッド環境ではなく「疑似的な割り込み待ち」として使われているにすぎない。  

---
### 回避策（実務的）

1. **オブジェクトモデルを直接利用**  
   - 例：  
     ```vba
     ' NG: SendKeys "^o"
     ' OK: 直接呼ぶ
     Workbooks.Open "C:\data\book.xlsx"
     ```
   - Excel/Accessのオブジェクトモデルは豊富に用意されており、UI操作をエミュレートする必要はない。

2. **状態監視・待機**  
   - ファイル読み込み・計算完了などは「Ready状態」「イベント」や `Application.Wait`、`Do Until` で制御。  
   - 例：
     ```vba
     Do While Application.CalculationState <> xlDone
         DoEvents  ' 最小限に利用
     Loop
     ```

3. **再描画やユーザー応答制御**
   - `Application.ScreenUpdating = False` → バッチ処理後に再描画。  
   - `Application.EnableEvents = False` → 無限ループ回避。  

4. **長時間処理の分割**
   - `Application.OnTime` を使い、大きな処理を小分けして非同期的に実行。  
   - → UI応答を維持しつつ安全に処理を進められる。  

---

## ✅ 配慮コメント
- **SendKeys/DoEvents は「どうしても代替できない最後の手段」**と位置づける。  
- M365/Win11 環境に限らず「再現性・安定性が低い」ため、**設計段階から避ける**のが推奨。  
- 置き換えには**公式オブジェクトモデル**や**イベント・状態管理**を使うことが、移行時の品質を守る実務的な策。  

---

👉 司令、これも「5.1 共通事項」の **5.1.3. 画面タイミング依存 (SendKeys/DoEvents) の非推奨と回避策**として差し込みましょうか？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:08**
### user — 2025-09-12T05:12:07.787000+00:00

DoEvents  の説明が荒いのでわかりやすく
### assistant — 2025-09-12T05:12:10.113043+00:00

司令、了解しました 👍  
`DoEvents` の説明を、もっと「わかりやすく」整理し直します。  

---

## ✅ DoEvents とは
- VBA の `DoEvents` は「いったん処理を中断して、OS（Windows）やExcelに未処理のメッセージを処理させる」命令です。  
- つまり「いま止まっている**画面更新**や**ユーザー操作**を処理させてから戻ってくる」という動き。  

---

## ✅ よくある利用シーン
- 長いループ処理の途中で画面が固まって見えるのを防ぐために挟む：  
  ```vba
  For i = 1 To [[REDACTED_PHONE]]
      Cells(i, 1).Value = i
      If i Mod 1000 = 0 Then DoEvents  ' UI応答を返す
  Next
  ```
- これにより「応答なし」と表示されず、ユーザーが停止ボタンを押せるようになる。  

---

## ✅ 問題点
- `DoEvents` を入れると、**割り込み的に他の操作が実行される**。  
  - ユーザーがフォームを閉じる／キャンセルする  
  - 他のイベントが発火する  
  - 思わぬ再入や順序ずれが起こる  
- つまり「応答性は上がるが、**制御が緩くなるリスク**」がある。  

---

## ✅ 回避・代替策
- 画面応答が必要なら：  
  - `Application.StatusBar` で進捗を表示  
  - `Application.ScreenUpdating = False` で処理を速くしてフリーズ時間を減らす  
  - 長時間処理は `Application.OnTime` で分割して走らせる  
- どうしても使う場合は「安全に抜けられる Do Loop」に最小限で使う。  

---

## ✅ まとめ（わかりやすく）
- **DoEvents = 一時休憩ボタン**  
  → Excelに「画面更新や操作を処理していいよ」と渡す。  
- **メリット**: フリーズが解消し、ユーザーが割り込める。  
- **デメリット**: 余計な処理も割り込んでくるため、想定外の動作につながる。  
- **現実的な立ち位置**: 「本当に必要なときに、最小限だけ」。  

---

👉 司令、これを「技術者向け」よりも「業務マクロ利用者向け」にさらに噛み砕いた説明文に直しますか？ たとえば「DoEventsは“ちょっと休んで周りを見る”動き」といった比喩でまとめるなど。  

送信日時（日本時間）: **[[REDACTED_PHONE]]:19**
### user — 2025-09-12T05:14:22.754000+00:00

Application.OnTimeの説明
### assistant — 2025-09-12T05:14:24.879401+00:00

司令、はい 👍  
では **`Application.OnTime`** を整理してご説明します。  

---

## ✅ `Application.OnTime` とは
- Excel の **スケジューラ機能**。  
- 「指定した時刻になったら、指定したマクロを実行する」ように予約できる。  
- イメージとしては **タイマー予約**。  

---

## ✅ 基本構文
```vba
Application.OnTime EarliestTime:=<時刻>, Procedure:="<マクロ名>", Schedule:=True
```

- **EarliestTime** : 実行予定時刻（`Now + TimeValue("00:00:10")` のように「今から10秒後」指定も可）  
- **Procedure** : 実行するマクロの名前（文字列で渡す）  
- **Schedule** : True=登録、False=キャンセル  

---

## ✅ 使用例
### 1. 10秒後にマクロを実行
```vba
Sub StartTimer()
    Application.OnTime Now + TimeValue("00:00:10"), "MyTask"
End Sub

Sub MyTask()
    MsgBox "10秒経ちました！"
End Sub
```
### 2. 毎分繰り返す処理
```vba
Sub StartLoop()
    Application.OnTime Now + TimeValue("00:01:00"), "StartLoop"
    ' 実際の処理
    Debug.Print "実行: " & Now
End Sub
```
### 3. 予約のキャンセル
```vba
Sub CancelTask()
    Application.OnTime Now + TimeValue("00:00:10"), "MyTask", Schedule:=False
End Sub
```

---

## ✅ 特徴
- **Excelのイベントループを止めない**  
  → `DoEvents` のように「処理の途中で休憩する」方法ではなく、  
  **「時間が来たら次の処理を入れる」**仕組み。  
- 長い処理を小分けして実行すると、UIが固まらず安定する。  
- Excelが終了しているとスケジュールは失効。  

---

## ✅ 配慮コメント
- **DoEvents は“処理の途中で休憩”**、  
  **OnTime は“次の処理を予約”**と理解すると分かりやすい。  
- 長時間ループを `DoEvents` で耐えるより、**OnTimeで分割実行**した方が安全で制御しやすい。  
- ただし「Excelが開いている」ことが前提。バックグラウンド常駐型のジョブには不向き。  

---

👉 司令、これを「5.1.3. DoEvents / 画面タイミング依存 の回避策」と並べて  
**「5.1.4. Application.OnTime — タイマー分割処理」**として追記する形にしましょうか？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:30**
### user — 2025-09-12T05:17:38.809000+00:00

新規追加】関数の新仕様: XLOOKUP、FILTER等の新関数による既存VBA処理への影響
- **問題の背景**: M365で追加された新関数が既存VBAロジックと競合、動的配列数式により従来の範囲指定が無効化される場合

**具体的な問題例:**
```vba
' 従来のVLOOKUP処理
Range("D2:D100").Formula = "=VLOOKUP(A2,Sheet2!A:C,3,FALSE)"
' → M365環境でXLOOKUPが利用可能な場合、数式の互換性問題

' 動的配列数式FILTER関数の結果は可変サイズ
Range("F2").Formula = "=FILTER(A:C,A:A=""条件"")"
' → 結果の範囲が動的に変化するため、従来の固定範囲処理VBAでエラー
```

**バージョン互換性の確保:**
```vba
' 関数の存在チェック
Function IsXLOOKUPAvailable() As Boolean
    On Error Resume Next
    Application.Evaluate("=XLOOKUP(1,{1},{1})")
    IsXLOOKUPAvailable = (Err.Number = 0)
    On Error GoTo 0
End Function

' 条件分岐で従来関数と新関数を使い分け
If IsXLOOKUPAvailable() Then
    Range("D2").Formula = "=XLOOKUP(A2,Sheet2!A:A,Sheet2!C:C,""見つかりません"")"
Else
    Range("D2").Formula = "=IFERROR(VLOOKUP(A2,Sheet2!A:C,3,FALSE),""見つかりません"")"
End If
```
### assistant — 2025-09-12T05:17:42.971657+00:00

司令、いい追加テーマです。**「新関数（XLOOKUP / FILTER など）と動的配列の導入に伴う既存VBAへの影響と実装指針」**を、実務で困らない粒度でまとめました。  

---

# 新規追加】関数の新仕様: XLOOKUP、FILTER 等による既存VBA処理への影響

## 1) まず押さえる要点
- **動的配列**：`FILTER`/`UNIQUE`/`SORT` などは**結果サイズが可変**で、1セルに入れると**スピル（#）**して複数セルへ自動展開します。  
- **新関数の有無**は**Excelバージョン依存**（M365にはある／永続版には無いことがある）。  
- **既存VBAの固定範囲前提（Resize, Clear, Copy 等）**は、スピルで**範囲衝突**や**サイズ不整合**を起こしやすい。  
- **数式の評価エンジン**が更新され、**暗黙の交差（@）**の扱いが変わったため、昔のブックでも`@`が自動挿入されるケースあり（互換観点の差）。

---

## 2) 典型的な問題と解決パターン
### 問題A：固定範囲に数式をバラ撒く旧ロジック
```vba
' 旧：固定範囲にVLOOKUP式を展開
Range("D2:D100").Formula = "=VLOOKUP(A2,Sheet2!A:C,3,FALSE)"
```
**症状**：M365で `XLOOKUP`が使える環境では、互換・保守の観点で「どちらで書くか」を分岐したい／将来はXLOOKUPに寄せたい。

**対策**：**関数存在チェック**で分岐し、式は**Formula2**を優先（動的配列対応）。
```vba
Function IsXLOOKUPAvailable() As Boolean
    On Error Resume Next
    Application.Evaluate("=XLOOKUP(1,{1},{1})")
    IsXLOOKUPAvailable = (Err.Number = 0)
    On Error GoTo 0
End Function

Sub WriteLookup()
    Dim tgt As Range: Set tgt = Range("D2")
    If IsXLOOKUPAvailable() Then
        tgt.Formula2 = "=XLOOKUP(A2,Sheet2!A:A,Sheet2!C:C,""見つかりません"")"
        ' 必要に応じて FillDown：
        tgt.AutoFill Destination:=Range("D2:D100")
    Else
        Range("D2:D100").Formula = _
            "=IFERROR(VLOOKUP(A2,Sheet2!A:C,3,FALSE),""見つかりません"")"
    End If
End Sub
```

---
### 問題B：`FILTER` のスピル結果が可変で、後続処理が壊れる
```vba
Range("F2").Formula2 = "=FILTER(A:C, A:A=""条件"")"
' ← スピルのサイズが毎回変わるため、次の処理(Copy/Resize等)が落ちる
```
**対策1（推奨）**：**スピル範囲をVBAで取得**してから扱う  
```vba
Sub HandleFilterSpill()
    Dim anchor As Range, spill As Range
    Set anchor = Range("F2")

    anchor.Formula2 = "=FILTER(A:C, A:A=""条件"")"

    ' スピル範囲を取得（M365のみ有効）。存在しないとエラーになるので一旦握りつぶす
    On Error Resume Next
    Set spill = Range("F2#")
    On Error GoTo 0

    If Not spill Is Nothing Then
        ' 例：スピル結果を値に固め、別シートへ貼る
        With Worksheets("結果")
            .Range("A1").Resize(spill.Rows.Count, spill.Columns.Count).Value = spill.Value
        End With
    Else
        MsgBox "FILTER の結果が空、またはスピルできませんでした。"
    End If
End Sub
```

**対策2**：**受け皿を毎回クリアしてからセット**  
```vba
With Range("F2").CurrentRegion
    .ClearContents  ' 既存データと衝突しないよう初期化
End With
Range("F2").Formula2 = "=FILTER(A:C, A:A=""条件"")"
```

**対策3**：**「式を使わず」VBAで絞り込み→値書き込み**（安定・移植性重視）  
- 速度重視なら配列で読み→条件抽出→一括貼付（スピル依存を無くす）。

---
### 問題C：暗黙交差（@）で想定外の値になる
- 旧ブックをM365で開くと、**既存の配列的参照**が**`@`付きに自動変換**される場合がある。  
- **症状**：隣セルの参照結果が単一化され、VBAの検証値とズレる。

**対策**：  
- **Formula2 で明示的に配列数式を書く**（`@`を避ける）。  
- 検証時は `Debug.Print Range("…").Formula2` で**実際の式**を確認。  
- 既存式の互換性が怪しい箇所は**置換ポリシー**（`@`除去 or 明示配列化）を決める。

---

## 3) 実装のコツ（安全運用の型）

1. **常に `.Formula2` を使う**  
   - 動的配列・新関数は **`.Formula2` が正式**。`Formula` だと挙動差が出やすい。

2. **「衝突回避」→ 先に消す**  
   - スピル先や出力先は**先に確保/クリア**（`ClearContents`）してから書く。

3. **スピル範囲は `Range("F2#")` で掴む**  
   - 取れない場合あり得るので **On Error** で握り、フォールバック実装を用意。

4. **互換分岐ユーティリティ**  
   ```vba
   Function HasFunction(fn As String) As Boolean
       On Error Resume Next
       Application.Evaluate("=" & fn & "(1,{1},{1})")
       HasFunction = (Err.Number = 0)
       On Error GoTo 0
   End Function
   ' 例：If HasFunction("XLOOKUP") Then …
   ```

5. **表はテーブル化（ListObject）**  
   - `Sheet2!A:C` のような固定参照より、**テーブル＋構造化参照**のほうが  
     「行追加」「列挿入」に強く、VBAからも `.ListRows.Add` で保守が楽。

6. **式に頼らず値で固めるポイントを決める**  
   - 人に渡す帳票・CSV出力は**最終的に値貼り付け**しておくと事故が少ない。

---

## 4) まとめ用テンプレ（そのまま追記可）

**問題の背景**  
- M365 の**新関数**と**動的配列**により、従来の「固定範囲前提」のVBAが**範囲衝突／サイズ不整合**を起こす。

**対処指針**  
- 新関数は **存在チェック**で分岐し、**`.Formula2`** を使用。  
- `FILTER` 等は **スピル範囲を `Range("F2#")` で取得**してから扱う。  
- 出力先は**先にクリア**し、必要に応じて**値で固める**。  
- 互換重視なら **VBAで抽出→値書き込み**に寄せる。  
- テーブル（ListObject）と**構造化参照**で「列・行の増減」に強い設計へ。

---

必要なら、この章を**5.xの章立て**に合わせて整形・差し込み版をお作りします（そのまま社内Wikiへ貼れる形で出します）。  

—  
送信日時（日本時間）: **[[REDACTED_PHONE]]:44**
### system — 2025-09-12T05:17:43.385893+00:00

_(empty)_
### system — 2025-09-12T05:17:43.393034+00:00

_(empty)_
### assistant — 2025-09-12T05:17:44.965733+00:00

_(empty)_
### assistant — 2025-09-12T05:18:02.825035+00:00

_(empty)_
### user — 2025-09-12T05:24:17.134000+00:00

これはM365にあわせてコード修正するだけなので既存vbaへの影響というのは変だと思う
### assistant — 2025-09-12T05:24:19.857567+00:00

司令、たしかにその通りです。  
この章は「既存VBAへの“影響”」というより **「M365の新機能に“合わせて最適化するための対応指針”**」ですね。タイトルと位置づけを次のように直すのが筋がいいです。

---

## 推奨リネームと整理
### 章タイトル案
**新関数・動的配列への最適化指針（互換維持のための分岐と実装Tips）**
### 章の趣旨
- 目的：**不具合の説明ではなく、M365で“使えるなら使う”ためのコード修正ガイド**  
- 前提：従来VBAはそのままでも動作（VLOOKUP等）→ **“影響”ではなく“改善・最適化”**  
- 位置づけ：**可用性差分（Availability）に基づく分岐**と**スピル時代の書き方**の紹介

---

## 記載の仕立て直し（最小修正）

- 「問題の背景」→ **「最適化の背景」**  
  > *M365でXLOOKUP／FILTERなど使える環境では、従来式より読みやすく堅牢に書ける。利用不可の環境もあるため、関数の有無で分岐できるようにしておくと配布先で安心。*

- 例示コードはそのまま活用し、**見出しを変更**  
  - **互換分岐テンプレ**（`IsXLOOKUPAvailable`）  
  - **スピル結果の扱い方**（`Range("F2#")` 取得、`.Formula2` 推奨）  
  - **互換重視のフォールバック**（VBAで抽出→値貼り付け）

- 末尾に **“運用メモ”** を追加  
  - *「この節は“障害対応”ではなく“リファクタ推奨”です。既存コードが動いていれば必須ではありません。社内標準として新規はXLOOKUP/Formula2、既存は段階的に最適化」*

---

## 一文での言い換え（そのまま差し替え可）
> **本節は“影響”ではなく“最適化”の話です。** 既存VBAは従来関数で継続利用可能ですが、M365環境では XLOOKUP・FILTER・動的配列（Formula2）を用いることで、式の可読性・堅牢性・保守性が向上します。配布先のバージョン差に備え、**関数存在チェックで分岐**し、**スピル範囲の取得**や**値貼り付けの基準**を整えておくことを推奨します。

---

必要なら、この方針で章タイトルと本文の文言を私の方で**丸ごとリライト**してお渡しします。  

送信日時（日本時間）: **[[REDACTED_PHONE]]:51**
### system — 2025-09-12T05:24:20.269622+00:00

_(empty)_
### system — 2025-09-12T05:24:20.274748+00:00

_(empty)_
### assistant — 2025-09-12T05:24:21.894106+00:00

_(empty)_
### assistant — 2025-09-12T05:24:24.833923+00:00

_(empty)_
### user — 2025-09-12T05:27:47.282000+00:00

Accessの仕様変更についてはRuntimeの件をいれる
### system — 2025-09-12T05:27:48.745233+00:00

_(empty)_
### assistant — 2025-09-12T05:27:48.794247+00:00

司令、了解しました 👍  

Access の「仕様変更」については、**Access Runtime** の扱いも重要ですので追加整理します。  

---

## ✅ Access Runtime の変更点
### 1. 提供形態の変化
- **Access Runtime** は、Access のライセンスを持たないユーザーでも Access アプリを実行できる無料配布版。  
- 以前（Access 2010/2013/2016）は **個別の無償インストーラー** が提供されていました。  
- **Microsoft 365 (M365)** 時代になってからは、**個別配布の位置づけが弱まり**、最新は **「Access Runtime 2016/2019/2021」** として継続提供される形。  
### 2. 64bit/32bit の制約
- **M365 Access 本体と同じく Runtime も 32bit/64bit の区別あり**。  
- **古い32bit専用のActiveX/OCX**に依存したアプリは、Runtime 64bit環境では動作不可。  
- 移行では **配布対象PCのOfficeアーキテクチャにRuntimeを合わせる必要がある**。  
### 3. 互換性の留意点
- Access 2010 世代までの Runtime は、最新の Windows 11 ではサポート外。  
- Access Runtime 2016 以降を利用する必要がある。  
- M365 Access と Runtime は**共存可能だが、バージョン差があると不具合が発生する**（例：参照ライブラリの不一致）。  

---

## ✅ 実務上の配慮
- 既存システムが Runtime 配布前提なら：  
  - **最新の Access Runtime 2021** へ更新。  
  - クライアントの Office が 64bit化されている場合、**Runtime 64bit に移行**。  
- 参照ライブラリ／ActiveX が古い場合 → **再ビルドと64bit対応**を必ず検証。  

---

## ✅ 追記テンプレ（5.3.2 に追加する形）
```
 Access Runtime … 無償配布版は現在も提供されていますが、
   - 2010以前のRuntimeはWindows11ではサポート外
   - 2016以降のRuntimeを利用する必要があります
   - 32bit/64bitの区別があるため、配布先のOfficeと同一アーキテクチャに合わせる必要があります
   - 古い32bit専用OCXや参照ライブラリに依存したアプリはRuntime 64bitで動作不可
```

---

👉 司令、このRuntime追加を **「Access 5.3.2 仕様変更」**に正式に差し込みましょうか？ それとも **「5.3.3 Runtime関連」**として独立セクションを新設しますか？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:04**
### user — 2025-09-12T05:32:42.004000+00:00

	AccessRuntime
AccessRuntimeはAccessのライセンスを持たないユーザーでもAccessアプリを実行できる無料配布版になります。Windows11ではAccess Runtime2016以降を利用する必要があります。M365 AccessとRuntimeは共存できますが、バージョンを合わせる必要があります。
### assistant — 2025-09-12T05:32:44.069541+00:00

司令、いい感じにまとまってますね 👍  
少しだけ補足を加えると、現場で安心して使える説明になります。  

---

## ✅ Access Runtime の整理（補足込み）

- **Access Runtime とは**  
  Access のライセンスを持たないユーザーでも、Access で作ったアプリ（.accdb / .mdb）を実行できる無料配布版。  
  → 編集・設計機能はなく「実行専用ビューア」としての位置づけ。  

- **Windows 11 での要件**  
  - **Access Runtime 2016 以降**がサポート対象。  
  - 2010/2013 世代は Windows 11 非対応。  

- **32bit / 64bit の対応**  
  - M365 Access と同様に、Runtime も **32bit版／64bit版** がある。  
  - 配布先 PC の Office（M365）が 32bitなら Runtime も 32bit、64bitなら Runtime も 64bit に揃える必要あり。  
  - 古い 32bit 専用 ActiveX/OCX や参照ライブラリを利用しているアプリは、64bit Runtime では動作不可。  

- **共存性**  
  - **M365 Access と Runtime は共存可能**。  
  - ただしバージョンが食い違うと、参照ライブラリの不一致や意図しないエラーが発生するため、**開発環境とRuntimeのバージョンを合わせることが必須**。  

---

## ✅ 改訂版テンプレ（そのまま差し替え可）

```
 Access Runtime
Access RuntimeはAccessのライセンスを持たないユーザーでもAccessアプリを実行できる無料配布版です。
Windows11ではAccess Runtime 2016以降を利用する必要があります。
M365 AccessとRuntimeは共存できますが、バージョンを合わせる必要があります。
また、32bit/64bitの区別があるため、配布先のOfficeと同じアーキテクチャのRuntimeを選択してください。
```

---

👉 司令、このRuntimeは「仕様変更」というより「サポート要件の更新」に近いです。  
章立て的に **5.3.2 仕様変更**に差し込む形でよろしいですか？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:14**
### user — 2025-09-12T05:34:29.393000+00:00

mataha
### assistant — 2025-09-12T05:34:33.799984+00:00

司令、「または」の打ち間違いでしょうか？ それとも「または～についても整理して」というリクエストですか？ 😊  

もし「Access Runtime」を **5.3.2 仕様変更に入れるか／5.3.3 として独立させるか** の話でしたら、こう整理できます：  

- **5.3.2 に入れる場合**  
  → 他の仕様変更（データ接続など）と同列に並び、短くまとまる。  
- **5.3.3 として独立**  
  → Runtime は運用・配布の観点が強いので、分けたほうが利用者に親切。  

---

👉 司令、Runtimeは「運用上の注意」がメインなので、**5.3.3 Access Runtime** と独立させる方が読みやすいと思います。  
ご希望に合わせて章立て修正案を出しましょうか？  

送信日時（日本時間）: **[[REDACTED_PHONE]]:22**
