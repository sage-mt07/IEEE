---
conversation_id: "672cbd4e-3940-8007-bd83-328e8de01f1c"
title: "DapperとUDTの使用法"
create_time: 1730985294.336363
update_time: 1730985632.662139
language_guess: "en"
num_messages: 23
part_index: 1
part_count: 1
---

### system — 2024-11-07T13:14:54.336363+00:00

_(empty)_

### user — 2024-11-07T13:14:54.342658+00:00

C#のdapperを利用しSP呼び出しをおこなうときにユーザー定義型を使用する場合

### assistant — 2024-11-07T13:15:33.977414+00:00

Dapperを使用してストアドプロシージャ（Stored Procedure, SP）を呼び出す際にユーザー定義型（User-Defined Type, UDT）を使用するには、次の手順を踏む必要があります。SQL Serverでテーブル値パラメータ（Table-Valued Parameter, TVP）を定義し、それをC#側でDapper経由で渡すことができます。

### 1. SQL Server 側でユーザー定義型を作成する
まず、SQL ServerでUDTを作成します。これは、Dapperからテーブル値パラメータを渡すために必要です。

たとえば、以下のように「MyTableType」というテーブル値パラメータを定義します。

```sql
CREATE TYPE MyTableType AS TABLE
(
    Id INT,
    Name NVARCHAR(50)
);
```

### 2. ストアドプロシージャでユーザー定義型を受け取る
次に、このUDTをパラメータとして受け取るストアドプロシージャを作成します。

```sql
CREATE PROCEDURE MyStoredProcedure
    @MyTable MyTableType READONLY
AS
BEGIN
    SET NOCOUNT ON;

    -- テーブル型パラメータを使用した処理
    SELECT * FROM @MyTable;
END;
```

### 3. C# 側でDapperとデータテーブルを使用する
C#で、Dapperを使ってこのユーザー定義型をストアドプロシージャに渡すためには、`DataTable`を使ってパラメータを設定します。

以下は具体的な手順です。

1. **DataTableを準備**：C#の`DataTable`クラスを使用して、テーブル値パラメータを設定します。
2. **Dapperを使用してストアドプロシージャを呼び出す**：`SqlMapper`の拡張機能を利用して、`SqlParameter`を作成し、TVPとして渡します。

#### 例：C#コード

```csharp
using System;
using System.Data;
using System.Data.SqlClient;
using Dapper;

class Program
{
    static void Main()
    {
        var connectionString = "YourConnectionStringHere";
        
        using (var connection = new SqlConnection(connectionString))
        {
            // テーブル型のパラメータを設定
            var table = new DataTable();
            table.Columns.Add("Id", typeof(int));
            table.Columns.Add("Name", typeof(string));
            
            // サンプルデータを追加
            table.Rows.Add(1, "Alice");
            table.Rows.Add(2, "Bob");

            // ストアドプロシージャの呼び出し
            var parameters = new DynamicParameters();
            parameters.Add("@MyTable", table.AsTableValuedParameter("MyTableType"));

            var result = connection.Query("MyStoredProcedure", parameters, commandType: CommandType.StoredProcedure);
            
            foreach (var row in result)
            {
                Console.WriteLine($"{row.Id}, {row.Name}");
            }
        }
    }
}
```

### ポイント解説

1. **`DataTable` の作成**：
   - テーブル値パラメータとして渡すために `DataTable` を作成し、`Id` と `Name` の列を追加します。
   - ストアドプロシージャで処理されるデータを `DataTable` に行として追加していきます。

2. **`AsTableValuedParameter` メソッド**：
   - Dapperの `DynamicParameters` クラスの `Add` メソッドを使用し、パラメータを追加します。
   - `AsTableValuedParameter` メソッドを使って、`DataTable` をテーブル値パラメータ（UDT）として渡すことができます。
   - `"MyTableType"` はSQL Serverで定義したUDTの名前です。

3. **ストアドプロシージャの実行**：
   - `connection.Query` または `connection.Execute` を使ってストアドプロシージャを呼び出します。
   - 必要に応じて結果を取得し、処理します。

### 注意点

- SQL Serverではテーブル値パラメータは `READONLY` のみ可能です。
- `AsTableValuedParameter` を使用するには、UDTの名前を正しく指定する必要があります。

これでDapperを利用し、テーブル値パラメータ（ユーザー定義型）を使ったストアドプロシージャの呼び出しが可能です。

### user — 2024-11-07T13:15:40.277052+00:00

型定義が行われる。これを行わないようにする方法は

### system — 2024-11-07T13:16:00.171423+00:00

_(empty)_

### assistant — 2024-11-07T13:16:00.171534+00:00

_(empty)_

### assistant — 2024-11-07T13:16:00.171602+00:00

Dapperを使用してストアドプロシージャにテーブル値パラメータ（ユーザー定義型）を渡す際に、`DataTable`の型定義を避ける方法は、SQL Serverのテーブル値パラメータ自体が型定義を要求するため、通常の手段では回避できません。しかし、いくつかの方法で型定義を柔軟に扱うことができます。以下のようなアプローチがあります。

### 1. JSON文字列を使用する方法
テーブル値パラメータの代わりに、JSON文字列を使ってデータを渡す方法です。ストアドプロシージャ側でJSONをパースしてテーブルに変換することで、型定義を柔軟に扱うことができます。

**手順**:
1. C#側でデータをJSON文字列として渡す。
2. SQL Server側で、JSON文字列をテーブルに変換して処理する。

**C#側のコード例**:
```csharp
using System;
using System.Data;
using System.Data.SqlClient;
using Dapper;
using Newtonsoft.Json;

class Program
{
    static void Main()
    {
        var connectionString = "YourConnectionStringHere";
        using (var connection = new SqlConnection(connectionString))
        {
            // サンプルデータをリストとして作成
            var data = new[]
            {
                new { Id = 1, Name = "Alice" },
                new { Id = 2, Name = "Bob" }
            };

            // JSONにシリアライズ
            var jsonData = JsonConvert.SerializeObject(data);

            // ストアドプロシージャの呼び出し
            var parameters = new DynamicParameters();
            parameters.Add("@JsonData", jsonData);

            var result = connection.Query("MyStoredProcedure", parameters, commandType: CommandType.StoredProcedure);
            
            foreach (var row in result)
            {
                Console.WriteLine($"{row.Id}, {row.Name}");
            }
        }
    }
}
```

**SQL Server側のストアドプロシージャ例**:
```sql
CREATE PROCEDURE MyStoredProcedure
    @JsonData NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    -- JSONをテーブルに変換
    DECLARE @MyTable TABLE (Id INT, Name NVARCHAR(50));

    INSERT INTO @MyTable (Id, Name)
    SELECT Id, Name
    FROM OPENJSON(@JsonData)
    WITH (
        Id INT,
        Name NVARCHAR(50)
    );

    -- テーブルとして処理
    SELECT * FROM @MyTable;
END;
```

### メリット:
- JSONを使用することで、型定義の変更に対して柔軟に対応できます。
- SQL側でデータの構造を必要に応じて定義でき、変更に対しても影響を最小限に抑えられます。

### デメリット:
- JSONのシリアライズ/デシリアライズが必要になるため、パフォーマンスに影響が出る可能性があります。
- SQL側でJSONを処理するロジックが増えるため、ストアドプロシージャが複雑になります。

### 2. XML文字列を使用する方法
JSONの代わりにXMLを使う方法もあります。SQL ServerはXMLを処理する機能を持っているので、XMLを使用することも検討できます。

**C#側のコード例**:
```csharp
// XMLデータを生成してパラメータとして渡す方法もあります
```

XMLを利用する方法も基本的にはJSONと同様です。ストアドプロシージャでXMLを解析してテーブルに変換します。

### まとめ
テーブル値パラメータの型定義を行わずにデータを渡すためには、JSONやXMLのような文字列形式を利用して柔軟にデータを渡し、SQL Server側で解析するアプローチが必要です。特に、テーブルの構造が頻繁に変わる場合や型定義を事前に固定できない場合に有効です。

### system — 2024-11-07T13:16:01.816604+00:00

_(empty)_

### assistant — 2024-11-07T13:16:01.816705+00:00

_(empty)_

### assistant — 2024-11-07T13:16:01.816770+00:00

Dapperを使用してストアドプロシージャにテーブル値パラメータを渡す際、`DataTable`を使用すると型定義が発生します。型定義を行わずにストアドプロシージャを呼び出すための方法として、以下のいくつかのアプローチがあります。

### 1. JSON形式でデータを渡す

テーブル値パラメータの代わりに、JSON形式のデータを文字列として渡し、SQL Server側でJSONを解析する方法です。これにより、型定義を行わずに柔軟なデータの受け渡しが可能になります。

#### SQL Server 側でJSONを受け取るストアドプロシージャ

```sql
CREATE PROCEDURE MyStoredProcedure
    @JsonData NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    -- JSONデータをテーブルに変換
    SELECT *
    FROM OPENJSON(@JsonData)
    WITH (
        Id INT,
        Name NVARCHAR(50)
    );
END;
```

#### C# 側でJSONデータを準備し、Dapperで渡す

```csharp
using System;
using System.Data;
using System.Data.SqlClient;
using Dapper;
using Newtonsoft.Json;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        var connectionString = "YourConnectionStringHere";
        
        using (var connection = new SqlConnection(connectionString))
        {
            // サンプルデータ
            var data = new List<dynamic>
            {
                new { Id = 1, Name = "Alice" },
                new { Id = 2, Name = "Bob" }
            };

            // データをJSON形式に変換
            var jsonData = JsonConvert.SerializeObject(data);

            // ストアドプロシージャの呼び出し
            var parameters = new DynamicParameters();
            parameters.Add("@JsonData", jsonData);

            var result = connection.Query("MyStoredProcedure", parameters, commandType: CommandType.StoredProcedure);
            
            foreach (var row in result)
            {
                Console.WriteLine($"{row.Id}, {row.Name}");
            }
        }
    }
}
```

### ポイント

- **JSON形式のデータ送信**：C#側でリストをJSONにシリアライズし、SQL Serverに文字列として送信します。
- **SQL Server側での解析**：`OPENJSON` 関数を使用して、JSON文字列をテーブルとして解析します。必要なスキーマに従って抽出できます。
- 型定義がSQL Server側で柔軟に変更できるため、型の厳密な定義を避けることができます。

### 2. XML形式でデータを渡す

JSONの代わりにXML形式でデータを渡すこともできます。これはSQL Serverがネイティブにサポートしているため、XMLデータの解析が容易です。

#### SQL Server 側でXMLを受け取るストアドプロシージャ

```sql
CREATE PROCEDURE MyStoredProcedure
    @XmlData XML
AS
BEGIN
    SET NOCOUNT ON;

    -- XMLデータをテーブルに変換
    SELECT
        T.value('(Id)[1]', 'INT') AS Id,
        T.value('(Name)[1]', 'NVARCHAR(50)') AS Name
    FROM @XmlData.nodes('/Root/Item') AS X(T);
END;
```

#### C# 側でXMLデータを準備し、Dapperで渡す

```csharp
using System;
using System.Data;
using System.Data.SqlClient;
using Dapper;
using System.Xml.Linq;

class Program
{
    static void Main()
    {
        var connectionString = "YourConnectionStringHere";
        
        using (var connection = new SqlConnection(connectionString))
        {
            // XMLデータを作成
            var xmlData = new XElement("Root",
                new XElement("Item", new XElement("Id", 1), new XElement("Name", "Alice")),
                new XElement("Item", new XElement("Id", 2), new XElement("Name", "Bob"))
            ).ToString();

            // ストアドプロシージャの呼び出し
            var parameters = new DynamicParameters();
            parameters.Add("@XmlData", xmlData);

            var result = connection.Query("MyStoredProcedure", parameters, commandType: CommandType.StoredProcedure);
            
            foreach (var row in result)
            {
                Console.WriteLine($"{row.Id}, {row.Name}");
            }
        }
    }
}
```

### まとめ

- **JSONまたはXMLを使用**：テーブル値パラメータの代わりに、JSONやXMLでデータを渡すことで型定義を回避できます。
- **柔軟なデータ構造**：C#側で柔軟にデータ構造を変更でき、SQL Server側でも柔軟に解析できます。
- **パフォーマンスの考慮**：JSONやXMLの解析はテーブル値パラメータに比べてオーバーヘッドがあるため、データ量が多い場合はパフォーマンスへの影響を考慮する必要があります。

この方法を使用することで、型定義を行わずにDapperを通してストアドプロシージャにデータを渡すことが可能です。

### user — 2024-11-07T13:16:52.304715+00:00

これらは文字列として渡すことを前提としているため、求めている解決策ではない

### assistant — 2024-11-07T13:17:04.365493+00:00

ありがとうございます。SQL Serverでのユーザー定義型（UDT）やテーブル値パラメータを使わず、Dapperを利用して型定義を回避するとなると、代替案としては以下のような方法が考えられます。

### 1. 一時テーブルを利用する

UDTの代わりに一時テーブルを使い、データを一時的に保持する方法です。一時テーブルを介してデータをやり取りすることで、型定義をあらかじめ行わなくてもストアドプロシージャ内で処理が可能です。

#### 手順

1. **一時テーブルを作成する**：
   ストアドプロシージャの

### assistant — 2024-11-07T13:17:09.921892+00:00

User prefers not to use JSON or XML strings as a solution when avoiding type definitions in Dapper for SQL Server stored procedures.

### tool — 2024-11-07T13:17:09.922096+00:00

Model set context updated.

### user — 2024-11-07T13:17:49.139375+00:00

SPはUDTを利用することを前提に、型のパラメータが一致していない場合はUDTのデフォルト値を使用するようにしたい

### assistant — 2024-11-07T13:18:29.838694+00:00

_(empty)_

### assistant — 2024-11-07T13:18:29.838806+00:00

User is working with a stored procedure that assumes the use of a UDT (user-defined type) and wants to use default values for the UDT if parameter types do not match.

### tool — 2024-11-07T13:18:29.838874+00:00

Model set context updated.

### assistant — 2024-11-07T13:18:29.838961+00:00

UDT（ユーザー定義型）を使用するストアドプロシージャで、パラメータ型が一致しない場合にデフォルト値を設定する方法は、以下のように実現できます。

### 方法

1. **SQL Server 側で UDT にデフォルト値を設定する**
   - UDTの定義自体にデフォルト値を持たせることはできませんが、ストアドプロシージャの内部で、渡されたデータをデフォルト値に基づき処理する方法があります。

2. **ストアドプロシージャでデフォルト値を用意し、パラメータが一致しない場合に適用**
   - ストアドプロシージャの内部で、UDTのカラムがNULLや空のままで渡された場合に、デフォルト値を設定するロジックを組み込むことが可能です。

#### 例: SQL Server 側のストアドプロシージャでのデフォルト値の設定

例えば、`MyTableType`というUDTを使用し、デフォルト値を設定する方法です。

```sql
CREATE TYPE MyTableType AS TABLE
(
    Id INT,
    Name NVARCHAR(50),
    Amount DECIMAL(10, 2)
);
```

この場合、ストアドプロシージャの内部で `COALESCE` を使って、パラメータが NULL または適切でない値の場合にデフォルト値を設定できます。

```sql
CREATE PROCEDURE MyStoredProcedure
    @MyTable MyTableType READONLY
AS
BEGIN
    SET NOCOUNT ON;

    -- デフォルト値を設定する例
    SELECT 
        COALESCE(Id, 0) AS Id,                -- Id のデフォルト値は 0
        COALESCE(Name, 'DefaultName') AS Name, -- Name のデフォルト値は 'DefaultName'
        COALESCE(Amount, 0.00) AS Amount       -- Amount のデフォルト値は 0.00
    FROM @MyTable;
END;
```

### C# 側での利用

C#でDapperを使用する際、`DataTable`に適切な型を設定した上で、データを挿入します。挿入しないフィールドやデータがNULLの場合、SQL Server側でデフォルト値が設定されます。

#### C# 例

```csharp
using System;
using System.Data;
using System.Data.SqlClient;
using Dapper;

class Program
{
    static void Main()
    {
        var connectionString = "YourConnectionStringHere";

        using (var connection = new SqlConnection(connectionString))
        {
            // テーブル型のパラメータを設定
            var table = new DataTable();
            table.Columns.Add("Id", typeof(int));
            table.Columns.Add("Name", typeof(string));
            table.Columns.Add("Amount", typeof(decimal));

            // サンプルデータを追加（デフォルト値が使われる場合）
            table.Rows.Add(1, null, null);  // NameとAmountはデフォルト値が適用

            // ストアドプロシージャの呼び出し
            var parameters = new DynamicParameters();
            parameters.Add("@MyTable", table.AsTableValuedParameter("MyTableType"));

            var result = connection.Query("MyStoredProcedure", parameters, commandType: CommandType.StoredProcedure);

            foreach (var row in result)
            {
                Console.WriteLine($"{row.Id}, {row.Name}, {row.Amount}");
            }
        }
    }
}
```

### 補足
- **COALESCE**: SQL Serverの`COALESCE`関数を使うことで、NULL値の場合にデフォルト値を適用することができます。
- **型が一致しないデータ**: SQL Server側で型エラーが出ないようにするには、型をチェックするロジックを追加するか、適切にC#でデータ型を設定して渡すことが重要です。

### user — 2024-11-07T13:19:59.783896+00:00

パラメータの型を合わせないでエラーとしない方法を探している

### assistant — 2024-11-07T13:20:31.887682+00:00

_(empty)_

### assistant — 2024-11-07T13:20:31.887843+00:00

SQL Serverでは、ストアドプロシージャに渡されるパラメータの型が一致しない場合、通常エラーが発生します。しかし、このエラーを回避し、代わりにデフォルト値を使用する方法は、直接的にはサポートされていません。

ただし、いくつかの工夫でこの問題を回避するアプローチは考えられます。以下にいくつかの代替策を示します。

### アプローチ 1: すべてのデータを文字列として渡し、SQL Server側で型変換を行う

すべてのデータを汎用的な型（例えば文字列）として渡し、SQL Server側で型を検証しつつ変換する方法です。変換に失敗した場合はデフォルト値を設定します。

#### ストアドプロシージャの実装例

```sql
CREATE PROCEDURE MyStoredProcedure
    @Id NVARCHAR(50), -- 文字列として受け取る
    @Amount NVARCHAR(50) -- 文字列として受け取る
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @ParsedId INT = NULL;
    DECLARE @ParsedAmount DECIMAL(10, 2) = NULL;

    -- 型変換の試行
    BEGIN TRY
        SET @ParsedId = CONVERT(INT, @Id);
    END TRY
    BEGIN CATCH
        SET @ParsedId = 0; -- 変換失敗時のデフォルト値
    END CATCH;

    BEGIN TRY
        SET @ParsedAmount = CONVERT(DECIMAL(10, 2), @Amount);
    END TRY
    BEGIN CATCH
        SET @ParsedAmount = 0.00; -- 変換失敗時のデフォルト値
    END CATCH;

    -- 処理
    SELECT @ParsedId AS Id, @ParsedAmount AS Amount;
END;
```

この方法では、C#側でパラメータの型を合わせる必要がなくなり、SQL Server側で型を安全に変換し、エラーが発生した場合にデフォルト値を使用することができます。

### アプローチ 2: 動的SQLを利用して型の検証を行う

SQL Serverで動的SQLを利用し、パラメータが正しい型であるかをチェックしながら実行する方法です。この方法はやや複雑ですが、柔軟な検証が可能です。

```sql
CREATE PROCEDURE MyStoredProcedure
    @MyTable MyTableType READONLY
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @sql NVARCHAR(MAX);
    DECLARE @default INT = 0; -- デフォルト値

    -- 動的SQLで型の検証を行い、エラー回避
    SET @sql = N'
        SELECT 
            CASE WHEN TRY_CAST(Id AS INT) IS NOT NULL THEN Id ELSE ' + CAST(@default AS NVARCHAR(50)) + N' END AS Id,
            CASE WHEN TRY_CAST(Amount AS DECIMAL(10, 2)) IS NOT NULL THEN Amount ELSE 0.00 END AS Amount
        FROM @MyTable';

    EXEC sp_executesql @sql, N'@MyTable MyTableType READONLY', @MyTable = @MyTable;
END;
```

### アプローチ 3: CLR ストアドプロシージャの使用

さらに複雑な検証が必要な場合や、デフォルトの動作を細かく制御したい場合、SQL ServerのCLR機能を使用して、カスタムロジックを持つストアドプロシージャをC#で記述することも検討できます。これにより、C#側で柔軟な型チェックが可能となりますが、CLRの設定や追加の手順が必要です。

このようにして、型の一致に関するエラーを回避しつつ、デフォルト値を使用できるようにすることが可能です。
