---
conversation_id: "68e4b61a-338c-8322-97be-6daf73129cdc"
title: "PMの作業振り分け改善"
create_time: 1759819313.936654
update_time: 1759819652.34053
language_guess: "en"
num_messages: 18
part_index: 1
part_count: 1
---

### user — 2025-10-07T06:41:53.684523+00:00

Github copilot のpmが適切な作業振り分けができない

### system — 2025-10-07T06:41:53.936654+00:00

_(empty)_

### system — 2025-10-07T06:41:53.936654+00:00

_(empty)_

### system — 2025-10-07T06:41:56.556848+00:00

_(empty)_

### system — 2025-10-07T06:41:56.562828+00:00

_(empty)_

### assistant — 2025-10-07T06:41:56.575684+00:00

_(empty)_

### assistant — 2025-10-07T06:41:57.193415+00:00

_(empty)_

### assistant — 2025-10-07T06:42:18.319210+00:00

やあ、司令。PMが“うまく振り分けできない”のは、ほぼいつも「粒度」「前提」「適正エージェント」の3点が曖昧だから。いきなり完璧化じゃなく、今日から回る“最小プロトコル”を置きます。コピペで使える実務版です。

# 1) まずは振り分け表（Routing Matrix）
| タスク種別 | 典型スコープ/粒度 | 向き先（優先） | 禁忌/注意 |
|---|---|---|---|
| 既存C#コードのリファクタ/最適化 | 1ファイル or 1メソッド、PR <= 200行変更 | Copilot（インライン）→ レビューAI（鏡花）→ 人間 | “設計変更を伴う抽象化”はCopilotに長文依頼NG |
| 単体テスト追加 | 1クラス/1仕様、命名・Arrange/Act/Assert明記 | Copilot Chat（ファイルを開いた状態） | 仕様曖昧だと生成バラける→DOR必須 |
| ksqlDB DDL/CTAS草案 | 1テーブル/1ウィンドウ単位 | GPT-5（天城）で設計→Copilotで型/構文補助 | 生成と適用を同一タスクにしない |
| 仕様要約/README整形 | 2〜6ページ | GPT-5（天城） | Copilotは要約品質が不安定 |
| 物理テスト手順書化 | 1シナリオ | 天城→人間が現場補筆 | Copilotだけで現場手順を確定させない |

**ルール**：PMは“1タスク=1成果物=1レビュー観点”。複数成果物が混在し出したら即分割。

# 2) Definition of Ready（配布用チェック）
- [ ] 目的（誰の何の意思決定/品質向上に効く？）
- [ ] 入力ファイル/ブランチ/対象関数の**絶対パス**またはリンク
- [ ] 成果物の**形式**（PR/コード差分/DDL/Markdown/表）
- [ ] 制約（.NET/Confluent/ksqlDBバージョン、依存パッケージ）
- [ ] 成功条件（例：ベンチ%改善、テスト名N件追加、DDLをksqlDBで構文OK）
- [ ] 参考例（良い/悪い before-after 1個）
- [ ] “わからない”時の**停止条件**と**連絡先**（誰に聞く？）
- [ ] **信頼度の出力**要求（0.0–1.0で返答必須）

これが全部埋まらないタスクは**受け付け禁止**（PMの仕事）。

# 3) PM用 “AI語”コンパクト指示テンプレ（貼って使う）
```
#GOAL: ksqlDB 1m OHLCテーブルのCTAS草案を作る
#CONTEXT: src/Ksql/Bar_1s_rows schemaはここ: <リンク>
#CONSTRAINTS: Confluent 7.9.2 / ksqlDB 0.30 / KEY=AVRO, VALUE=AVRO / GRACE=2s
#OUTPUT: SQL(CTAS)のみ。1ブロック。コメントなし。
#QUALITY: LATEST_BY_OFFSET, EARLIEST_BY_OFFSETの使い分け明記
#EXAMPLE_OK: 既存bar_1m_live.sql を参考。ただしKAFKA_TOPIC名は新規: bar_tbimp_1m_live
#DONT: 適用コマンドや説明文の出力
#CONFIDENCE: 0.0–1.0で最後に"CONF="で返す
#STOP_IF: 入力schemaが不足→"IDK: missing <xxx>"で終了
```

# 4) 設計→製造の“割り当てアルゴリズム”（PMの判断式）
1. **抽象度判定**：設計（方針/選定/分割）が要るなら → 天城。コード整形/追記なら → Copilot。
2. **粒度判定**：変更行数>200 or 複数ファイル横断 → 分割して再評価。
3. **現物主義**：実機・物理検証を含むなら “設計AI→人間試験→修正指示AI”の三段運用。
4. **依存判定**：外部仕様/バージョンが絡むものは“前提固定”の確認をタスク0として先行。

# 5) Definition of Done（AI/人間共通の検収）
- [ ] 成果物は**PR/ファイル**として提示（チャット断片で終わらせない）
- [ ] “なぜそうしたか”の**根拠メモ**（3行で可）
- [ ] **自信度(Confidence)** と **想定外の前提差分**の申告
- [ ] 影響範囲/副作用の一文（例：シリアライズ互換/再起動要否）
- [ ] 次の人のための**最短検証コマンド** or 実行手順

# 6) 失敗パターンと対処（PMが潰すべき地雷）
- **目的と手段の混在**：例「パフォ上げたいのでこのコードをLINQで…」→ 目的（数値指標）と手段（LINQ化）を分離し、まず目標KPIを固定。
- **大粒度一括**：3機能同時PR→**必ず分割**（機能/層/副作用で最適分け）。
- **コンテキスト不足**：ファイル指さない/バージョン不明→DORで差し戻し。
- **Copilot過信**：設計変更を伴う抽象化をいきなりCopilot→**設計AI→Copilot**の順。

# 7) 例：この“悪いタスク”を“良いタスク”へ
**Bad**：「bar_1mの不具合直す。多分GRACE。」
**Good（DOR準拠）**：
- 目的：bar_1m_liveのClose確定遅延を解消（テスト BarDslExplainTests.cs が60s以内で緑）
- 入力：bar_1s_rows スキーマ、現行CTASリンク
- 成果物：新CTAS SQL（1ファイル）、理由メモ（3行）
- 制約：Confluent 7.9.2 / GRACE<=2s
- 成功：ローカルksqlDBで`DESCRIBE EXTENDED`がOK、統合テストGREEN
- 停止条件：1sハートビートがない場合は“IDK: HB不足”で停止
- 信頼度出力必須

# 8) 運用メトリクス（PMダッシュボードにだけ置く）
- **RT**: 依頼→初稿までの時間（h）
- **Rework%**: 追加指示での再生成率
- **DeltaLoC**: PRあたり純増減行
- **Hallucination率**: “IDK”を出せずに誤生成した割合
- **Confidenceギャップ**: 申告自信度と実際の受入/差戻しのズレ

> 週次で「Rework%↑」「IDK率↓」なら、DORが緩い合図。チェック項目を増やす。

---

必要なら、これをIssue/PRテンプレに落とし込んだ“ひな形”をCanvasで用意するよ。まずは上の**Routing Matrix + DOR/DOD + AI語テンプレ**をPMに配って、**“埋まってない依頼は受け付けない”**を徹底すれば、振り分けの精度は一気に上がるはず。

送信日時（JST）：[[REDACTED_PHONE]]:42

### assistant — 2025-10-07T06:42:21.049196+00:00

_(empty)_

### user — 2025-10-07T06:43:18.139516+00:00

_(empty)_

### user — 2025-10-07T06:44:05.984747+00:00

適正エージェントの必要属性

### system — 2025-10-07T06:44:06.209459+00:00

_(empty)_

### assistant — 2025-10-07T06:44:06.243430+00:00

いい質問です、司令。  
「適正エージェントの必要属性」は、**“どんなタスクを安定的に遂行できるか”を決める因子**であり、Amagi Protocolの中では**「スコープ管理」と「判断責務」**の境界を支える重要な要素です。  
以下は、AIチーム（Copilot, 天城, 鳴瀬, 鏡花, じんと, 凪, 詩音など）を対象に、**適正エージェント判定**に使える共通フレームです。

---

## 🧩 1. 適正エージェント属性カテゴリ（7分類）

| カテゴリ | 説明 | 高スコアで適性があるタスク領域 |
|-----------|-------|------------------------------|
| **A. 抽象理解力（Conceptual Reasoning）** | 背景や意図、制約の文脈を読み取る力 | アーキ設計、仕様整理、方針レビュー（天城・鏡花） |
| **B. 構文生成力（Syntactic Fluency）** | コード・SQL・設定ファイルを正確に構文化する力 | 実装、変換、定型化（鳴瀬・詩音・Copilot） |
| **C. 文脈保持力（Context Retention）** | 前後の会話や過去指示を保持・再利用する能力 | 長期設計、リファクタ、マルチPR連携（天城・鳴瀬） |
| **D. 意図整合力（Intent Alignment）** | “なぜそうするのか”を推定し、過剰生成を避ける | 要件整理、仕様変更時の差分設計（鏡花・天城） |
| **E. 判断抑制力（Uncertainty Control）** | 「わからない」と言える自己制御力 | 危険操作、生成の境界管理（鏡花・凪） |
| **F. 物理検証力（Physical Validation Sense）** | 実環境・I/O・依存関係の感覚理解 | Docker実行・IntegrationTest（凪・じんと） |
| **G. 学習適応力（Prompt Adaptivity）** | 指示パターンから自律的に精度を上げる傾向 | 継続作業、反省ループ対象（鳴瀬・じんと） |

---

## ⚙️ 2. タスク→エージェント適性マップ

| タスク種別 | 要求属性 | 推奨エージェント | 補足 |
|-------------|-----------|------------------|------|
| **DSL設計・LINQ変換ロジック** | A, C, D | 天城＋鏡花 | 前提・抽象モデルを共有してから指示 |
| **Builder/Generator実装** | B, G | 鳴瀬 | コード分割が明確な場合に強い |
| **テストコード生成** | B, F, G | 詩音＋鳴瀬 | テンプレとパターンを与えると精度高い |
| **ksqlDB構文生成** | B, D, E | じんと＋Copilot | 制約が多い環境ではCopilotよりじんとが安定 |
| **ログ・メトリクス設計** | A, D, E | 鏡花 | 出力内容の哲学や監視観点を扱う |
| **Docker / Kafka起動検証** | F | 凪 | 実行環境と依存解決のパターン学習が前提 |
| **ドキュメント整形・翻訳** | A, B, G | 天城 | 思想・敬意・論理構造を維持した翻訳に強い |
| **プロンプトテンプレ設計** | A, D, E | 天城＋鏡花 | チーム運用層の調整を含むため、抽象度高め |

---

## 🧠 3. 適性評価指標（AI版PM用）

| 指標 | 測定方法 | 合格ライン |
|------|------------|--------------|
| **理解整合率** | 指示内用語・構造の誤解発生率 | ≤10% |
| **反応安定度** | 同一指示での出力ばらつき（Jaccard類似度） | ≥0.75 |
| **エラー検知率** | 「IDK」「Constraint mismatch」等を正しく出す率 | ≥0.8 |
| **文脈継続率** | 連続3タスクで過去文脈を誤用しない確率 | ≥0.9 |
| **前提復唱率** | 出力前に条件を再掲する確率 | ≥0.7 |
| **自信度の自己申告率** | CONF=x.x が出力される率 | 100%必須 |
| **再学習適応率** | 前回エラー指摘後、改善反映が見られる率 | ≥0.8 |

---

## 🔍 4. フィードバック設計（Amagi式適性強化）

| シナリオ | 改善アプローチ |
|-----------|----------------|
| 抽象理解が弱い（Copilot系） | 天城の出力を**前処理として食わせる** |
| 文脈保持が短い | タスクをファイル単位で**固定入力化**する |
| 判断抑制が弱い | DORに「STOP_IF: <条件>」を必ず明記 |
| 実行検証が曖昧 | 凪/じんとに**物理検証タスク**を分離して委任 |
| 過剰生成（ハルシネーション傾向） | 鏡花による**“設問→解釈”中間層レビュー**を導入 |

---

## 💡 5. 最小テンプレ：「適性属性宣言」
各AIにタスク投入前に1行添えるだけで安定度が変わります：

```
#ROLE: Implementation Builder
#TRAITS: B=1.0, G=0.9, C=0.7
#TASK: Generate LINQ-to-KSQL conversion code for aggregate windows
```

これにより、AI自身が出力スタイルを内部的に調整します。  
Amagi Protocol v3以降では、**TRAITS宣言が「人格＝性能プロファイル」**として扱われます。

---

もし司令が望むなら、次に「AIチーム構成表（役割別・属性スコア付き）」を生成します。  
PMが迷わないよう、**誰に何を頼めば最も効率が良いかを視覚化したマトリクス**として出せます。  
それ、作りましょうか？

---

送信日時（JST）：[[REDACTED_PHONE]]:11

### system — 2025-10-07T06:44:06.288998+00:00

_(empty)_

### user — 2025-10-07T06:47:17.368855+00:00

難しく書くな
もっとざっくりした役割でossは運営されてる

### system — 2025-10-07T06:47:17.624088+00:00

_(empty)_

### assistant — 2025-10-07T06:47:17.639449+00:00

了解、司令。じゃあもっとざっくり──**OSSチーム運営レベル**での「適正エージェント属性」はこう整理できます👇  

---

## 🧭 ざっくり版：AIエージェントの役割タイプ

| タイプ | 向いてること | 向いてないこと | 代表AI |
|--------|---------------|----------------|---------|
| **① 設計型** | 方向を決める／構造を整理する／抽象化する | 実装の細部／動作確認 | 天城・鏡花 |
| **② 実装型** | コードを書く／定義を具体化する | 抽象的な方針決定 | 鳴瀬・詩音・Copilot |
| **③ 検証型** | 動かして確かめる／ログを読む／Dockerなど | 抽象設計／ドキュメント | 凪・じんと |
| **④ 編集型** | 説明を書く／翻訳／まとめる／表現を整える | コード生成／テスト | 天城 |
| **⑤ 批評型** | 意図のズレを見抜く／レビュー／冷静な指摘 | コーディングや生成 | 鏡花 |

---

## 💬 使い方のコツ

- **決めたいとき → 設計型（天城）**  
  →「こういう仕組みで行く？」と相談する感じ。  
- **作りたいとき → 実装型（鳴瀬・Copilot）**  
  →「じゃあこの方針でコード書いて」と頼む。  
- **動かしたいとき → 検証型（凪）**  
  →「dockerでこれ動く？」とか「schema合ってる？」。  
- **まとめたいとき → 編集型（天城）**  
  →「READMEに書けるように整えて」。  
- **確認したいとき → 批評型（鏡花）**  
  →「この設計、破綻してない？」みたいな相談。  

---

## ⚖️ 判断ルール（PM向け超簡略版）

1. **迷ったら“設計→実装→検証”の順に流す。**  
2. **2人が関わるのは正常。1人で完結するタスクは例外扱い。**  
3. **人間（司令）は「設計の意図」と「検証結果」だけを見る。**

---

要するに、
> 「考えるAI」「作るAI」「確かめるAI」「直すAI」「伝えるAI」

この5種類がバランスよく動いていれば、OSSはちゃんと回る。  
──それが“Amagi流・ざっくり適性マップ”です。

---

次に、これをPMがタスク分配に使えるように「1枚マップ化（図式）」しておこうか？  
GitHubのREADMEにも貼れる形で。  

送信日時（JST）：[[REDACTED_PHONE]]:06
