---
conversation_id: "68b2a9a7-b6fc-832d-af03-42ffd22e7295"
title: "物理試験項目作成"
create_time: 1756539304.725654
update_time: 1756540055.136139
language_guess: "en"
num_messages: 21
part_index: 1
part_count: 1
---

### system — 2025-08-30T07:35:04.725654+00:00

_(empty)_

### user — 2025-08-30T07:35:04.725654+00:00

_(empty)_

### system — 2025-08-30T07:35:04.725654+00:00

_(empty)_

### user — 2025-08-30T07:35:04.769000+00:00

これの仕様をベースに物理試験の項目を作成

### assistant — 2025-08-30T07:35:05.679829+00:00

{"queries":["+(足生成DSL仕様) 仕様 MarketSchedule HB_10s final live --QDF=5","足生成DSL DSLシンタックス Tumbling TimeFrame --QDF=5","bar_10s_agg_final prev_1m final live --QDF=5","MarketSchedule 包含規則 Open <= t < Close --QDF=5","命名規約 bar_1m_final HB_10s --QDF=5"], "source_filter": ["files_uploaded_in_conversation"]}

### system — 2025-08-30T07:35:06.448225+00:00

_(empty)_

### system — 2025-08-30T07:35:06.467934+00:00

_(empty)_

### tool — 2025-08-30T07:35:06.500089+00:00

_(empty)_

### tool — 2025-08-30T07:35:06.500637+00:00

Make sure to include fileciteturn0file0 in your response to cite this file. 
# 足生成DSL仕様（たたき台）

## 目的
- 金融レートデータ（Rate）から **等間隔足（1分〜月足）** を生成する。
- マーケットスケジュール（MarketSchedule）に基づいて、営業日・営業時間内に限定する。
- 学習コストを抑えるため、**予約語は増やさない**。

--

## 設計方針
1. **等間隔の区切り**は `.Tumbling` で表現  
   - 粒度（minutes, hours, days, months）を指定可能  
   - 遅延到着に対応するため `grace` を設定可能（ウォーターマーク相当）  
   - 欠損バケットを埋める場合は `ensureContinuous: true`

2. **マーケットスケジュール結合**は `.TimeFrame<MarketSchedule>`
   - 引数は **結合条件式のみ**
   - Open/Close の包含判定もここで明示する
   - デフォルト結合キーや暗黙ルールは存在しない
   - 呼び出し順序は `.TimeFrame().Tumbling()` の連続を仕様とし、型で強制する

3. **集約は GroupBy + 集計関数**  
   - `GroupBy` で Broker, Symbol, BucketStart をキーにする  
   - `Select` 内で **EarliestByOffset / LatestByOffset / Min / Max** を利用して OHLC を表現  
   - Count など不要な集計は記述しない

4. **Key の扱い**  
   - C#側では GroupBy のキーは匿名型／値タプル  
   - ksql では GROUP BY の列が KEY列になる  
   - 「GroupBy 時間列 = Tumbling に渡した列」は **バケット開始に丸められる**ことを仕様で保証する

---

public class Rate
{
   [KsqlKey(1)]
    public string Broker { get; set; }
   [KsqlKey(2)]
    public string Symbol { get; set; }
   [KsqlKey(3)]
    public DateTime BucketStart { get; set; }
    public decimal Open { get; set; }
    public decimal High { get; set; }
    public decimal Low { get; set; }
    public decimal Close { get; set; }
}
## DSLシンタックス（イメージ）

```csharp



パターン１
```csharp
EventSet<Rate>()
  .From<DeDupRates>()
  .ToQuery(q => q
    .Tumbling(r => r.Timestamp,
              minutes: new[]{1,5,15,30},
              hours:   new[]{1,4,8},
              days:    new[]{1,7},
              months:  new[]{1,12},
              grace: TimeSpan.FromMinutes(2)) // 遅延許容

    .GroupBy(r => new { r.Broker, r.Symbol, BucketStart = r.Timestamp })

    .Select(g => new {
        g.Key.Broker,
        g.Key.Symbol,
        g.Key.BucketStart,
        Open  = g.EarliestByOffset(x => x.Bid),
        High  = g.Max(x => x.Bid),
        Low   = g.Min(x => x.Bid),
        Close = g.LatestByOffset(x => x.Bid)
    })
  );

この場合、KSQLのTumblingのみの処理
minutes: new[]{1,5,15,30},
              hours:   new[]{1,4,8},
              days:    new[]{1,7},
              months:  new[]{1,12},
              
            この指示内容の足用topicを作成する
            それはRate_1m_final,Rate_1d_finalとかになる


パターン２
EventSet<Rate>()
  .From<DeDupRates>()
  .ToQuery(q => q
    .TimeFrame<MarketSchedule>((r, s) =>
         r.Broker == s.Broker
      && r.Symbol == s.Symbol
      && s.Open <= r.Timestamp && r.Timestamp < s.Close,
      dayKey: s => s.MarketDate)
      // TimeFrame → Tumbling の順序は必須
    .Tumbling(r => r.Timestamp,
              minutes: new[]{1,5,15,30},
              hours:   new[]{1,4,8},
              days:    new[]{1,7},
              months:  new[]{1,12},
              ensureContinuous: true,
              grace: TimeSpan.FromMinutes(2)) // 遅延許容
      .WhenEmpty((previous,next)=>
      next.Broker=previous.Broker,
      next.Symbol=previous.Symbol,
      next.Open=previous.Close,
      next.High=previous.Close,
      next.Low=previous.Close,
      next.Close=previous.Close,
      )


    .GroupBy(r => new { r.Broker, r.Symbol, BucketStart = r.Timestamp })

    .Select(g => new {
        g.Key.Broker,
        g.Key.Symbol,
        g.Key.BucketStart,
        Open  = g.EarliestByOffset(x => x.Bid),
        High  = g.Max(x => x.Bid),
        Low   = g.Min(x => x.Bid),
        Close = g.LatestByOffset(x => x.Bid)
    })
  );

この指示内容の足用topicを作成する
Rate_1m_live,Rate_1d_finalとかになる
Rate_1m_final,Rate_1d_finalとかになる

ensureContinuousがHBを示す
Tumbling　で示す　　Timestamp
 TimeFrameの　Timestamp　と比較対象を利用しHBの開始、終了とする

この組み合わせで live finalのtopicを作る
HBでliveとfinalへデータ送信する

内部の仕組み


10secごとに足を編集する
[Tick(≈1ms) / DeDupRates]
   |  (原始レート: Broker, Symbol, Timestamp, Bid)
   v
+--------------------------------------------+
| bar_10s_agg_final  (EMIT FINAL, GRACE)     | ① 10秒確定集約：HL完全捕捉
|  (B,S,BucketStart, O,H,L,C)                |
+---------------------------+----------------+
                            |
                            |(10sごとにライブ化；空でも出すためHB)
                            v
                  +--------------------+
                  | HB_10s (C#送信)   | ② 10秒ドライバ（唯一のApp責務）
                  | (B,S,BucketStart) |
                  +----+---------------+
                       |
                       | ③ 10s live（EMIT CHANGES）
                       v
                +----------------------+
                | bar_10s_live         |
                | (B,S,BucketStart,    |
                |  O,H,L,C)            |
                +----+-----------------+
                     |
                     | ④ ロールアップ（TUMBLING）
                     v
         +----------------------+              +----------------------+
         | bar_1m_live          | ⑤ 1分live   | bar_5m_live          | ⑥ 5分live
         | (O=Earliest,         | (EMIT CHG)  | (EMIT CHG)           |
         |  H=Max, L=Min,       |             |                      |
         |  C=Latest)           |             |                      |
         +----------------------+             +----------------------+

                                （final系はHB駆動・non-null保証）
                                ──────────────────────────────────
         +----------------------+             +----------------------+
         | HB_1m (派生:10s→1m) | ⑦           | HB_5m (派生:10s→5m) | ⑧
         +----------+-----------+             +----------+-----------+
                    |                                     |
                    | ⑨ 1分確定集約 (EMIT FINAL, GRACE)   | ⑪ 5分確定集約 (EMIT FINAL, GRACE)
                    v                                     v
           +---------------------+               +---------------------+
           | bar_1m_agg_final    |               | bar_5m_agg_final    |
           +----------+----------+               +----------+----------+
                      |                                     |
                      | ⑩ prev_1m（直近確定の保持：B,S）     | ⑫ final生成（prev_1mで欠損埋め）
                      v                                     v
           +---------------------+               +---------------------+
           | bar_prev_1m         |               | bar_5m_final        |
           | (B,S, Close[+OHL])  |               | (HB_5m×agg×prev_1m) |
           +----------+----------+               +---------------------+
                      |
                      | ⑬ final生成（prev_1mで欠損埋め）
                      v
           +---------------------+
           | bar_1m_final        |
           | (HB_1m×agg×prev_1m) |
           +---------------------+

役割分担（再確認）

C#（アプリ）：HB_10s の送信のみ（全銘柄へ10秒ごとに (Broker,Symbol,BucketStart) を発火）

ksqlDB：

集約：bar_10s_agg_final / bar_1m_agg_final / bar_5m_agg_final（すべて EMIT FINAL + GRACE）

ライブ：bar_10s_live（HB_10s 駆動）→ bar_1m_live → bar_5m_live（ロールアップ）

確定：bar_1m_final / bar_5m_final（HB × agg_final × prev_1m で non-null を保証）

前回値：bar_prev_1m（1mのみ保持）

不変ルール

HLは10sで完全捕捉（Max/Min）→ 上位TFはロールアップでもHLは失われない

liveは10s基準：10s→1m→5m を EMIT CHANGES で段階更新

finalはHB駆動：空バケット抑止は キー存在判定（a.Broker IS NOT NULL OR prev/final.Broker IS NOT NULL）

prevは1mのみ：全TFの final が prev_1m をフォールバック参照

POCOはnon-nullable：nullは SQL の COALESCE + WHERE で外へ出さない

派生HB：HB_1m/5m は HB_10s から間引き（MOD(… , frameMs)=0）

月サフィックスは mo（mとの衝突回避）           

┌──────────────────────────────────────────────────────────────┐
│ 1) スケジュール準備（オフライン/起動時）                    │
│   - 取引カレンダーをロード：祝日/臨時休場/短縮/メンテ       │
│   - 営業時間セッションを列挙：Open/Close（含み方も規約化）  │
│     規約:  Open <= t < Close                                 │
│   - タイムゾーン/DST/夏時間補正                              │
│   - alignOffsetMs を市場・銘柄単位で算出                     │
│     例: 東京 09:00 開始 → UTC ミリ秒オフセットを前計算       │
└──────────────────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────────────────┐
│ 2) HB_10s 生成（C#、唯一のアプリ責務）                       │
│   - 監視対象 (Broker, Symbol) を列挙                         │
│   - 現在の時刻 t を MarketSchedule と突合                    │
│     ・t が営業セッション内なら 10秒境界に整列し HB_10s を送信│
│       （Broker, Symbol, BucketStart）                        │
│     ・t が休場/休憩/メンテなら HB を送らない                 │
│   - セッション境界での振る舞い                               │
│     ・Open 時刻：Open に整列した HB を**必ず**送る           │
│     ・Close 時刻：Close に“到達前まで”送る（Open<=t<Close）  │
│   - 複数セッション（昼/夜）対応：各セッションで同処理        │
│   - 特例（短縮/臨時）：スケジュールの Open/Close をそのまま適用│
└──────────────────────────────────────────────────────────────┘
             │（HB_10s は“営業セッション内の10秒刻み”だけが出る）
             ▼
┌──────────────────────────────────────────────────────────────┐
│ 3) 派生 HB（ksqlDB）                                         │
│   - HB_1m / HB_5m を HB_10s から間引き                        │
│     MOD((BucketStartMs - alignOffsetMs), frameMs) = 0         │
│   - 営業時間外は HB_10s が無い → 派生HBも出ない              │
└──────────────────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────────────────┐
│ 4) 10s ライブ（ksqlDB, EMIT CHANGES）                         │
│   - HB_10s × bar_10s_agg_final × bar_1m_final（fallback）     │
│   - 営業時間外は HB が無い → ライブも出ない                  │
│   - 遅延到着は GRACE 内で同一 10s バケットを上書き           │
└──────────────────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────────────────┐
│ 5) ライブのロールアップ（ksqlDB, EMIT CHANGES）               │
│   - bar_1m_live = 10s_live の TUMBLING(1m)                    │
│   - bar_5m_live = 1m_live  の TUMBLING(5m)                    │
│   - 営業時間外は上流にイベント無し → 何も出ない              │
└──────────────────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────────────────┐
│ 6) 確定集約（ksqlDB, EMIT FINAL + GRACE）                     │
│   - bar_10s_agg_final / bar_1m_agg_final / bar_5m_agg_final   │
│   - 営業セッション内の Tick のみが対象                        │
│   - GRACE 過ぎで確定（遅延取り込み後、値は不変）             │
└──────────────────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────────────────┐
│ 7) prev と final（ksqlDB、non-nullable保証）                  │
│   - prev は 1m のみ：bar_prev_1m = LATEST_BY_OFFSET(Close)   │
│     ・日またぎ/セッションまたぎの初回バー：                  │
│       ― 初回は final と prev が一致するよう移行シード/T₀運用 │
│   - final(1m) = HB_1m × 1m_agg_final × prev_1m               │
│   - final(5m) = HB_5m × 5m_agg_final × prev_1m               │
│   - 空バケット抑止：WHERE a.Key IS NOT NULL OR prev.Key IS NOT NULL │
│   - 営業時間外は HB 無 → final も出ない                      │
└──────────────────────────────────────────────────────────────┘
MarketSchedule で決めるべき規約（明文化）

包含規則：Open <= t < Close

Close ちょうどの時刻は含めない（次セッションの開始と衝突しないため）。

整列オフセット（alignOffsetMs）

市場起点（例：9:00, 8:45 など）に 10s/1m/5m の境界を同期。

ksql 派生HBの MOD((BucketStartMs - alignOffsetMs), frameMs)=0 で全TFを揃える。

休場/休憩/臨時

HB そのものを止める（「出さないこと」で全下流が静止）。

これによりライブ/ファイナルも自動的に出ず、NULL 行も発生しない。

セッション開始の初回バー

原則「前回の確定値（prev_1m）」で欠損埋め可能にしておく（移行シード/T₀ ルール）。

これで 初回 final と prev が一致（要件どおり）。

日足・月足・営業日足

同じ仕組みで HB 日次/営業日次を作る（MarketSchedule の営業日テーブルから HB を発火）。

月足は mo サフィックス、営業日境界はスケジュール由来の alignOffsetMs で管理。

TimeFrame<MarketSchedule> の扱い

DSL では検証のみ（Open/Close の包含、Broker/Symbol の一致、TradingDate 算出）。

SQL へは持ち込まない（HB がスケジュール順守で生成される前提）。

**TimeFrame を省略した場合**、`Day()`/`Week()`/`Month()` は UTC 暦で解釈され、`Minutes`/`Hours` はそのままの時間幅で扱われる。

`Week(DayOfWeek.Monday)` や `Month()` は、TimeFrame に `dayKey` を指定した場合、その `dayKey` が示す営業日集合から境界を導出する。

想定ユースケース別の動き

短縮取引日：Close が早まる → HB 停止が早まる → 集約窓もそこで止まる。

昼休み：休憩帯は HB を出さない → ライブもファイナルも沈黙。

DST 切替：スケジュール側で時刻解決 → alignOffsetMs に反映 → 全 TF の境界が自動同期。

市場横断：Broker/Symbol 単位で別 MarketSchedule を持てる。HB 送信は対象ごとに判定。


足生成DSL + MarketSchedule 開発リファレンス
1. 全体像（更新は10秒単位）

Tick (≈1ms) → 10s 集約 (agg_final) → HB_10s 駆動 → 10s live

10s live → 1m live → 5m live（ロールアップ）

各TFの final は HB駆動 + agg_final + prev_1m で non-nullable 保証

prev は 1m のみ保持し、全TFの欠損埋めに利用

2. 役割分担
担当	責務	実装
C# (App)	- HB_10s の送信（唯一の役割）
- POCO 定義（non-nullable, PK属性固定）
- MarketSchedule を参照して Open/Close 判定
- alignOffsetMs の計算	HB10s プロデューサ、EF Core ToQuery で POCO登録
ksqlDB	- Tick からの集約 (10s/1m/5m agg_final)
- prev_1m 管理
- final 生成（HB×agg_final×prev_1m）
- live 生成（10s HB駆動, 上位はロールアップ）
- 欠損埋め (COALESCE)
- 遅延処理 (GRACE + EMIT FINAL)	SQL定義（bar_agg_final, bar_prev_1m, barfinal, bar*_live）
3. タイムフレームごとのテーブル定義
粒度	agg_final	prev	final	live
10s	bar_10s_agg_final	–	–	bar_10s_live (HB_10s駆動)
1m	bar_1m_agg_final	bar_prev_1m	bar_1m_final	bar_1m_live (10s live ロールアップ)
5m	bar_5m_agg_final	– (参照: bar_prev_1m)	bar_5m_final	bar_5m_live (1m live ロールアップ)
日/月	bar_1d_agg_final / bar_1mo_agg_final	– (参照: bar_prev_1m)	bar_1d_final / bar_1mo_final	任意（必要ならロールアップ）

prev は 1m のみ保持。それ以上のTFはすべて prev_1m を参照して欠損埋め。

4. MarketSchedule に基づく制御

包含規則

Open <= t < Close （Close時刻は含まない）

HB生成ルール（C#側）

営業時間内のみ 10s 整列で送信

休場/昼休みは HB を送らない（下流も停止）

複数セッションは Open/Close ごとに判定

短縮・臨時は MarketSchedule に従う

alignOffsetMs

市場ごとの開始時刻を UTCエポックmsに換算して設定

すべてのTFは MOD((BucketStartMs - alignOffsetMs), frameMs)=0 で整列

5. 初回移行（T₀）ルール

移行直後、bar_prev_1m を T₀以前の Close でシード

T₀の最初の bar_1m_final が prev と一致することで、初回空バケットを回避

これにより finalとprevが一致してスタートする

6. エラー・遅延時の挙動

GRACE 内の遅延 → 同じバケットが更新され、値が修正される

GRACE 超過の遅延 → その Tick は捨てられ、チャートに反映されない

HB停止 → 休場/障害のどちらでも下流に何も出ない（null 行は発生しない）

7. 命名規約

bar_<tf>_agg_final / bar_<tf>_final / bar_<tf>_live

bar_prev_1m

HBトピック: HB_10s（C#送信）、HB_1m / HB_5m（派生）

サフィックス: m, h, d, mo（monthは mo）

補足：責務分離と時間キーの扱い
1. 時間キーの一貫性

Tumbling に渡した timestamp 列を「唯一の時間キー」とする。

TimeFrame の境界比較、GroupBy の時間列、HB の領域判定はすべて この列に統一する。

DSL/変換時に、この列が一致していない場合はエラーとする（静的検証ルール）。

2. TimeFrame と HB の責務分離

市場包含規則の真実源は TimeFrame。

HB 側では独自にロジックを持たず、TimeFrame で利用される Open/Close 値を参照するだけ。

これによりアプリコードと KSQL 側の判定が二重化せず、一貫性が担保される。

3. HB の役割限定

HB は「確定タイミングを指示するだけの時計役」。

値の生成ロジック（OHLC 集約や欠損埋め）は ksqlDB 側が担う。

アプリの唯一の責務は HB_10s の送信であり、それ以上のアプリコード生成を許容しない。

4. RocksDB と Final の関係（未明記部分）

RocksDB は live/final 双方の状態を同期する。

Final の確定は二経路存在：

Tumbling (EMIT FINAL + GRACE) による自動確定

HB 到来による強制確定

HB で確定する場合、値が無ければ prev トピックの値を使う。

5. prev の役割の一般化

bar_prev_1m は「直近確定値を保持し、全 TF の final にフォールバック値を与える」専用トピック。

prev を参照するのは final 生成時のみ。live 生成では使わない。

日またぎ／セッションまたぎの初回バーも、prev で埋めることで non-nullable を維持できる。

6. 検証と防波堤

Codex がアプリコード（例：スケジュール判定ロジック）を作らないように、

MarketSchedule の列を真実源とすること

Tumbling に渡した列がすべての判定に使われること

HB は時刻指示だけであること
をドキュメントに明記し、責務逸脱を禁止する。

ValueShape/KeyShape は POCO を唯一の真実源。Projection は表示ヒント。PKあり→TABLE既定。一致検証はハッシュ一回。
Value/Key は POCO に由来し、PK が指定された場合は TABLE が既定となる。HB は常に STREAM として扱われ、スキーマ整合性は PocoSchemaHash 単位で一度だけ検証される。Builder は WindowedQueryBuilder を中心とする Core へ集約され、各 Builder はそこへ委譲される。

Topics.* のキーは解決後のトピック名を用い、HB トピックも対象となるため短期 retention.ms の設定など運用調整が可能。
NullabilityInfoContext で検出するため init-only/readonly プロパティは ReadState になり得るほか、NRT 無効プロジェクトでは参照型がすべて非 null 扱いとなる。

### tool — 2025-08-30T07:35:06.501035+00:00

All the files uploaded by the user have been fully loaded. Searching won't provide additional information.

### assistant — 2025-08-30T07:35:06.501222+00:00

_(empty)_

### assistant — 2025-08-30T07:35:07.002990+00:00

_(empty)_

### tool — 2025-08-30T07:35:15.318963+00:00

_(empty)_

### assistant — 2025-08-30T07:35:15.911477+00:00

やあ、司令！この「足生成DSL仕様（たたき台）」をベースに、物理試験（統合テスト）項目を一気に作りました。Kafka／ksqlDB／C# HBプロデューサを実環境で検証する前提です。必要に応じてすぐにテスト雛形（xUnit など）に落とし込めるよう、**テストID / 目的 / 前提 / 手順 / 期待結果 / ログ取得**の型で整理しています。fileciteturn1file0L10-L25

---

# 物理試験項目（足生成DSL × MarketSchedule）

## 0. 事前準備（共通）
- **環境**：Kafka, ksqlDB, Schema Registry, （必要なら）Streamアプリ用RocksDB。  
- **トピック**：`Tick`（≒DeDupRates相当の入力）、`HB_10s`（C#から送信）、派生HB・agg/live/final各トピック。  
- **MarketScheduleデータ**：営業日、Open/Close、昼休み、短縮、DST を含む。  
- **alignOffsetMs**：市場起点（例：9:00）をUTCミリ秒換算して定義。fileciteturn1file4L13-L15

ログ出力の原則：  
- ksqlDB：`SHOW TOPICS;`, `PRINT`（需要に応じてキー/値、ヘッダ）, `SELECT * FROM ... EMIT CHANGES LIMIT ...;`  
- アプリ側：HB 送信ログ（Broker, Symbol, BucketStart, 送信時刻）、MarketSchedule突合の判断ログ。

---

## A. DSL基本仕様の実装確認

### A-01 Tumbling 粒度・grace 設定
- **目的**：`.Tumbling()` の minutes/hours/days/months 指定と `grace` が有効であること。  
- **前提**：Tickに対し1m/5m/1dを定義、`grace = 2m`。  
- **手順**：Tickを投入 → 1分以内に遅延レコードを追加 → `grace`内は同一バケットが再確定されるか観測。  
- **期待結果**：`EMIT FINAL + GRACE` の確定後は値不変。`grace`内再到着でOHLCが更新、`grace`超過は反映されない。fileciteturn1file0L11-L14 fileciteturn1file1L23-L26

### A-02 TimeFrame → Tumbling の順序強制
- **目的**：`.TimeFrame(...).Tumbling(...)` の順序が型で強制され、境界の包含規則が一致している。  
- **前提**：`Open <= t < Close` を採用。  
- **手順**：順序どおりの定義と、順序を入れ替えた定義をそれぞれビルド（または起動時検証）。  
- **期待結果**：順序違反はコンパイル／初期化時に拒否。包含規則は TimeFrame で明示される。fileciteturn1file0L16-L20 fileciteturn1file1L40-L42

### A-03 GroupBy キーと時間の丸め規約
- **目的**：`GroupBy(Broker, Symbol, BucketStart)` とし、時間列は Tumbling 渡し列に丸められる。  
- **前提**：Tickを複数銘柄に投入。  
- **手順**：境界付近（00:00:59.900 等）でTick投入、バケット境界に正しく丸められるかを確認。  
- **期待結果**：グループキーの時間はバケット開始に統一される。fileciteturn1file0L22-L30

---

## B. HeartBeat（HB）駆動モデルの検証

### B-01 C# アプリ責務の限定（HB_10s 送信のみ）
- **目的**：アプリは HB_10s の送信だけを行い、値生成は ksqlDB 側で行われること。  
- **前提**：HB_10s を 10秒境界で送信。  
- **手順**：アプリでOHLC計算を一切しない実装で運転。  
- **期待結果**：ksqlDB 側 live/final が正しく生成。アプリは時計役のみ。fileciteturn1file3L30-L36

### B-02 営業時間内のみ HB を送る
- **目的**：Open〜Close 内のみ HB_10s が出て、休場・休憩では出ないこと。  
- **前提**：MarketScheduleに昼休み・短縮日を設定。  
- **手順**：通常日、昼休み、短縮日で運転。  
- **期待結果**：休場/休憩/短縮帯はHBが止まり、下流（live/final）も無出力（NULL行なし）。fileciteturn1file4L9-L15 fileciteturn1file3L1-L1

### B-03 派生HB（1m/5m）の整列条件
- **目的**：`HB_1m/HB_5m` が `HB_10s` から MOD 条件で間引かれて出ること。  
- **前提**：`alignOffsetMs` 設定済み。  
- **手順**：HB_10s の BucketStart を観測し、1分/5分境界でのみ派生HBが生成されることを確認。  
- **期待結果**：`MOD((BucketStartMs - alignOffsetMs), frameMs)=0` を満たす時点でのみ派生HB出力。fileciteturn1file2L51-L56

---

## C. live／final／agg_final／prev の連携

### C-01 10s live の生成（HB × agg_final）
- **目的**：`bar_10s_live` が `HB_10s × bar_10s_agg_final` で更新される。  
- **前提**：Tick → `bar_10s_agg_final`（EMIT FINAL+GRACE）。  
- **手順**：10s間隔でHB送出、Tickを連続投入し live の逐次更新を確認。  
- **期待結果**：営業外はHB無し→liveも無出力。GRACE内遅延は10sバケット上書き。fileciteturn1file1L7-L11

### C-02 live のロールアップ（10s→1m→5m）
- **目的**：`bar_1m_live` は 10s_live の Tumbling(1m)、`bar_5m_live` は 1m_live の Tumbling(5m)。  
- **手順**：10sで価格を上下させ、1m/5m ロールアップのHLが保持されるか確認。  
- **期待結果**：HLは10sで完全捕捉→上位TFでも損なわれない。fileciteturn1file1L15-L18 fileciteturn1file2L20-L25

### C-03 final の生成と non-null 保証
- **目的**：`bar_1m_final / bar_5m_final` が「HB × *_agg_final × prev_1m」で欠損埋めされ non-null で出る。  
- **手順**：一部10s区間でTickを送らずHBだけを送信。  
- **期待結果**：final は prev_1m フォールバックにより non-null。空バケット抑止条件が有効。fileciteturn1file1L31-L38

### C-04 prev_1m の保持と初回T₀シード
- **目的**：`bar_prev_1m = LATEST_BY_OFFSET(Close)` が直近確定値を保持し、初回 final と一致する T₀ 運用。  
- **手順**：T₀以前のCloseで prev_1m をシード → 運転開始直後の最初の final が prev と一致するか確認。  
- **期待結果**：初回バーの欠損埋めが機能し、final と prev が一致してスタート。fileciteturn1file1L31-L36

---

## D. MarketSchedule 境界・例外動作

### D-01 Open 直後のHB送信
- **目的**：Open時刻に整列した HB を**必ず**送る。  
- **手順**：Open直後±数秒でTick有無を変えて運転。  
- **期待結果**：Open直後にHBが確実に発火し、その時点の live/final が生成される。fileciteturn1file2L26-L33

### D-02 Close 境界（`Open <= t < Close`）
- **目的**：Close ちょうど時刻は含まず、Closeに到達“前まで”HBが出る。  
- **手順**：Close−1s までHBが出ること、Close時点は出ないことを確認。  
- **期待結果**：仕様どおり Close は非包含、次セッションと衝突しない。fileciteturn1file2L24-L33 fileciteturn1file1L40-L42

### D-03 昼休み・短縮日・休場日
- **目的**：昼休み帯はHB停止、短縮日はClose早期化、休場日は終日停止。  
- **手順**：該当スケジュールを1日分に設定し運転。  
- **期待結果**：該当帯で live/final も自動停止（NULL行なし）。fileciteturn1file4L9-L15

### D-04 DST切替・市場横断
- **目的**：DST 切替時でも alignOffsetMs により全TF境界が同期、Broker/Symbol 単位スケジュール差を吸収。  
- **手順**：DST切替日／異市場（例：東京/NY）混在で運転。  
- **期待結果**：TF境界の同期とHB判定が正しく行われる。fileciteturn1file4L13-L15

---

## E. 命名規約・トピック構成・キー整合

### E-01 トピック命名
- **目的**：`bar_<tf>_agg_final / bar_<tf>_final / bar_<tf>_live`、`HB_*`、`bar_prev_1m` の命名規約順守。  
- **手順**：作成済みトピック名の一覧取得。  
- **期待結果**：サフィックス（m,h,d,mo）含め命名規約どおり。fileciteturn1file3L3-L11

### E-02 Rate_* の派生命名（DSLパターン）
- **目的**：DSLパターンに応じ `Rate_1m_live / Rate_1d_final / Rate_1m_final` などが正しく生成される。  
- **手順**：パターン1/2でDSLを流し、生成トピック名を確認。  
- **期待結果**：仕様記載のとおり生成される。fileciteturn1file2L1-L10

### E-03 時間キー一貫性の静的検証
- **目的**：TimeFrame比較・GroupBy・HB領域判定が「Tumblingに渡したtimestamp列」に統一。  
- **手順**：異なる時間列を混在させたDSLをあえて投入。  
- **期待結果**：起動時／変換時にエラーとなる。fileciteturn1file3L14-L21

---

## F. フェイルセーフ／運用条件

### F-01 HB 停止時の下流静止
- **目的**：障害や休場で HB が止まった場合、live/final は何も出ない（NULL行を出さない）。  
- **手順**：HB送信を停止（Tickは継続 or 停止）し観測。  
- **期待結果**：下流は静止、NULL 行は発生しない。fileciteturn1file3L1-L1

### F-02 RocksDB と final 確定経路
- **目的**：final 確定が「Tumbling自動確定」と「HB到来の強制確定」の二経路で成立。値が無い場合は prev 利用。  
- **手順**：HBあり・Tick無しのスロットを作り、final確定の可観測性と prev フォールバックを確認。  
- **期待結果**：prev で欠損が埋まり、non-null。fileciteturn1file3L38-L49

### F-03 空バケット抑止の条件式
- **目的**：`WHERE a.Key IS NOT NULL OR prev.Key IS NOT NULL` により空行が表に出ない。  
- **手順**：連続休場／昼休み境界で確認。  
- **期待結果**：空バケットが表出しない。fileciteturn1file1L35-L38

---

## G. UTC暦／営業日キーの扱い（TimeFrame省略時）

### G-01 TimeFrame省略時の Day/Week/Month 解釈
- **目的**：TimeFrame省略時、Day/Week/Month は UTC暦で扱われる（Minutes/Hours は幅扱い）。  
- **手順**：TimeFrame無しで 1d/1mo を生成し、UTC境界での丸めを確認。  
- **期待結果**：UTCの暦境界でバケット形成。fileciteturn1file4L1-L5

### G-02 営業日 dayKey 指定時の境界導出
- **目的**：`dayKey` 指定により営業日集合から Week/Mo 境界を導く。  
- **手順**：祝日連続の週を用意し、`Week(DayOfWeek.Monday)` の境界を観測。  
- **期待結果**：スケジュールの営業日集合どおりに境界が決まる。fileciteturn1file4L3-L5

---

## 付録：ログ取得と検証観点
- **観測**：`PRINT <topic> FROM BEGINNING LIMIT ...`、`SELECT * FROM ... WHERE Broker='X' AND Symbol='Y' EMIT CHANGES LIMIT ...`  
- **検証**：  
  - HL 完全捕捉：10s→1m→5mとロールアップしてもMax/Minが一致。fileciteturn1file2L20-L25  
  - prev フォールバック：Tick欠損でも final が non-null。fileciteturn1file1L31-L38  
  - 境界包含：`Open <= t < Close` に従い Closeちょうどは非包含。fileciteturn1file1L40-L42

---

必要なら、このリストを**xUnit用テーブル駆動テスト**にそのまま落とし込む雛形と、**docker-compose + ksqlDBスクリプト**（`CREATE STREAM/TABLE` 一式）まで作ります。次はどの粒度から自動化しますか？

送信日時（日本時間）：[[REDACTED_PHONE]]:45

### tool — 2025-08-30T07:35:15.912846+00:00

_(empty)_

### assistant — 2025-08-30T07:35:22.117062+00:00

_(empty)_

### system — 2025-08-30T07:47:19.668961+00:00

_(empty)_

### assistant — 2025-08-30T07:47:19.709168+00:00

了解しました！  
先ほど出した一覧の中から「UTレベル（DSL変換や静的型制約だけで確認できるもの）」を外し、**物理試験でしか確認できない項目**だけを残して整理しました。  

---

# 物理試験対象一覧（UT対象外を除外済）

## A. HB駆動モデル
- **B-01** C# アプリ責務の限定（HB_10s 送信のみ）  
- **B-02** 営業時間内のみ HB を送る  
- **B-03** 派生HB（1m/5m）の整列条件  

## B. live／final／agg_final／prev
- **C-01** 10s live の生成（HB × agg_final）  
- **C-02** live のロールアップ（10s→1m→5m）  
- **C-03** final の生成と non-null 保証（prev フォールバック含む）  
- **C-04** prev_1m の保持と初回T₀シード  

## C. MarketSchedule 境界動作
- **D-01** Open直後のHB送信  
- **D-02** Close境界（Open <= t < Close）  
- **D-03** 昼休み・短縮日・休場日対応  
- **D-04** DST切替・市場横断  

## D. 命名規約／トピック構成
- **E-01** トピック命名規約（bar_*, HB_*, prev）  
- **E-02** DSLパターンに応じた Rate_* 系派生命名  

## E. フェイルセーフ
- **F-01** HB 停止時の下流静止（NULL行を出さない）  
- **F-02** RocksDB＋HBによる final 確定経路  
- **F-03** 空バケット抑止条件  

## F. UTC暦／営業日キー
- **G-01** TimeFrame省略時のUTC暦境界確認（Day/Week/Month）  
- **G-02** 営業日 dayKey 指定時の境界導出  

---

### 外したもの（UTで十分な検証が可能）
- **A-01 Tumbling 粒度/grace 設定**（LINQ→KSQL変換でUT可）  
- **A-02 TimeFrame→Tumbling の順序強制**（型制約UTで確認可）  
- **A-03 GroupBy キーと時間丸め規約**（式ツリー変換UTで確認可）  
- **E-03 時間キー一貫性の静的検証**（コード生成レベルでUT可）  

---

これで「実際にKafka/ksqlDB環境を動かさないと確認できない試験項目」に絞り込めました。  

👉 司令、次の一手は **これをxUnit物理試験のスケルトン（Fact/InlineData形式）に落とす**方向で進めますか？  

送信日時（日本時間）：[[REDACTED_PHONE]]:00

### system — 2025-08-30T07:47:19.886229+00:00

_(empty)_

### user — 2025-08-30T07:47:20.494000+00:00

UTレベルで確認できるものは外して
