---
conversation_id: "3e3e32bb-310a-4bea-9ecb-2b430af5881c"
title: "SQL Perf Improvement Tips"
create_time: 1710636615.522515
update_time: 1710636969.735787
language_guess: "en"
num_messages: 12
part_index: 1
part_count: 1
---

### system — 2024-03-17T00:50:15.522515+00:00

_(empty)_

### user — 2024-03-17T00:50:15.523183+00:00

SQLServerのSPを実行時間においてSSMSと.netプログラムから実行した際に違いが発生する場合の対策

### assistant — 2024-03-17T00:51:19.544420+00:00

SQL Serverのストアドプロシージャ（SP）を実行する際、SQL Server Management Studio（SSMS）と.NETプログラムから実行した場合に実行時間に差が生じる問題は、開発や運用においてよく遭遇するものです。この問題は主に、接続のコンテキスト、実行計画のキャッシュ、およびパラメータスニッフィングに関連しています。以下に、この問題を解決するための一般的な対策をいくつか紹介します。

### 1. SET OPTIONSの確認

SSMSと.NETアプリケーションでは、デフォルトで異なるSET OPTIONSが適用されている場合があります。これらの違いが異なる実行計画を導くことがあります。例えば、`ARITHABORT`オプションが異なると、性能に大きな違いが生じることがあります。.NETアプリケーションから接続する際に、SSMSで使用されるものと同じSET OPTIONSを指定することで、性能の違いを解消できる場合があります。

```sql
SET ARITHABORT ON;
```

### 2. パラメータスニッフィングの問題

SQL Serverはクエリの実行計画を最適化するために、初めてストアドプロシージャが実行される際に提供されたパラメータ値を使用します。しかし、これが原因で特定のパラメータ値に最適化されすぎてしまい、他のパラメータ値では性能が落ちることがあります。この問題に対処する方法としては、ローカル変数を使用するか、`OPTIMIZE FOR`句や`RECOMPILE`オプションを使う方法があります。

### 3. クエリヒントの使用

特定のクエリが.NETアプリケーションから実行される際にのみ遅くなる場合、クエリヒントを使用してSQL Serverに実行計画を指示することが有効な場合があります。ただし、クエリヒントの使用は慎重に行う必要があります。

### 4. 実行計画のキャッシュと再利用

.NETアプリケーションとSSMSからの実行で異なる実行計画がキャッシュされていることが原因である場合、`DBCC FREEPROCCACHE`を使用してプロシージャキャッシュをクリアすることが一時的な解決策になることがあります。ただし、このコマンドはサーバー全体に影響を与えるため、本番環境での使用は注意が必要です。

### 5. 接続プーリングの設定

.NETアプリケーションでは、接続プーリングがデフォルトで有効になっています。接続プーリングの設定や挙動がSSMSと.NETアプリケーション間で異なる実行時間に影響を与えている可能性があります。接続文字列のパラメータを調整して、この問題に対処できる場合があります。

### 6. アプリケーションとデータベースの両方でプロファイリングを実行

SQL Server ProfilerやExtended Eventsを使用して、SSMSと.NETアプリケーションからの実行時にど

### assistant — 2024-03-17T00:51:38.281589+00:00

のようなクエリが発行されているかを確認します。これにより、性能の違いの原因を特定する手がかりを得られる場合があります。

これらの対策は問題の性質に応じて異なる効果があります。問題解決には、これらのアプローチを組み合わせたり、異なる設定を試したりすることが必要になるかもしれません。

### user — 2024-03-17T00:52:17.672969+00:00

その他の項目はないのか

### assistant — 2024-03-17T00:53:17.730132+00:00

SQL ServerのストアドプロシージャをSSMSと.NETアプリケーションから実行した際の実行時間に違いが生じる問題に対して、上記で挙げた対策以外にも検討すべき項目があります。以下、さらなる対策や考慮事項を紹介します。

### 7. 統計情報の更新

SQL Serverは統計情報を使用してクエリの実行計画を最適化します。統計情報が古くなっている場合、非効率な実行計画が選択されることがあります。定期的に統計情報を更新することで、より良い実行計画の選択と性能の向上が期待できます。

```sql
UPDATE STATISTICS tablename;
```
または、データベース全体で統計情報を更新することもできます。

```sql
EXEC sp_updatestats;
```

### 8. インデックスの最適化

クエリの実行速度に大きな影響を与えるのがインデックスです。不足しているインデックスの追加、使用されていないインデックスの削除、フラグメンテーションのあるインデックスの再構築や再編成を行うことで、性能を向上させることができます。

### 9. ネットワーク遅延の検討

.NETアプリケーションがリモートサーバーに接続している場合、ネットワーク遅延が原因で性能差が生じる可能性があります。SSMSがデータベースサーバーに近い場所、または同じサーバー上で実行されている場合、この差が顕著になります。ネットワークのパフォーマンスを検証し、必要に応じて改善策を検討してください。

### 10. リソースの利用状況の監視

サーバーのリソース（CPU、メモリ、ディスクI/Oなど）の利用状況が高い場合、それが性能のボトルネックになっている可能性があります。特に.NETアプリケーションからのアクセスが多い環境では、リソースの競合が起こりやすくなります。パフォーマンスモニター、リソースモニター、またはSQL Serverの動的管理ビュー（DMV）を使用して、リソースの利用状況を確認し、必要に応じてリソースを追加することを検討してください。

### 11. アプリケーションコードの最適化

.NETアプリケーション内のデータベース接続の開閉処理、クエリの発行方法、トランザクションの管理など、アプリケーションレベルでの最適化も重要です。例えば、不要なデータの取得を避けるためにSELECTクエリを最適化したり、接続プールを適切に管理したりすることが挙げられます。

これらの追加的な対策や考慮事項を通じて、SSMSと.NETアプリケーションからのストアドプロシージャ実行時の性能差を最小限に抑えること

### user — 2024-03-17T00:53:20.366421+00:00

結果セットの返信時簡に違いがある場合の対策

### assistant — 2024-03-17T00:54:28.051574+00:00

ストアドプロシージャやクエリの実行結果として得られる結果セットのサイズや形式によって、SQL Server Management Studio (SSMS) と .NET アプリケーション間でパフォーマンスに差が出ることがあります。これは、結果セットの取得と処理の仕方が異なるために生じることが多いです。以下に、結果セットの返信時にパフォーマンスの違いが生じた場合の対策をいくつか紹介します。

### 1. データのフェッチ方法の検討

.NET アプリケーションでは、`DataReader` や `DataSet` を使ってデータを取得しますが、これらのコンポーネントがデータをどのように扱うか（例えば、一度に全てのデータをメモリに読み込むか、ストリームとして扱うか）によってパフォーマンスが大きく変わることがあります。大量のデータを扱う場合は、`DataReader` を使用して、必要なデータを必要な時に少しずつ読み込むようにするとメモリ使用量を抑えられます。

### 2. 結果セットのサイズの最適化

返されるデータの量をできるだけ減らすことで、通信時間とメモリ使用量を削減できます。不要な列を取得しない、必要な行だけをフィルタリングして取得する、ページングを実装するなどの方法が考えられます。

### 3. ネットワーク遅延の考慮

大きな結果セットを返すクエリを実行する場合、ネットワークを介してデータを転送する時間がパフォーマンスに影響を与える可能性があります。アプリケーションとデータベースサーバー間のネットワーク遅延を減らすために、可能であれば両者を物理的に近づける、高速なネットワーク接続を使用するなどの対策が有効です。

### 4. アプリケーション側での処理の最適化

結果セットを受け取った後のアプリケーション側での処理にも注意が必要です。大量のデータを効率的に処理するために、LINQ や並列処理などを適切に利用することで、データ処理のパフォーマンスを向上させることができます。

### 5. T-SQLクエリの最適化

結果セットのサイズや形式に影響を与える可能性のあるT-SQLクエリ自体の最適化も重要です。例えば、不要な結合を避ける、インデックスを効果的に使用する、適切なWHERE句を使用して不要なデータをフィルタリングするなどの最適化が挙げられます。

### 6. データ圧縮の活用

SQL Server 2016以降では、行レベルとページレベルのデータ圧縮機能がサポートされています。これらの機能を使用することで、ディスク上およびメモリ上でのデータの格納効率を向上させ

### user — 2024-03-17T00:54:43.015178+00:00

DataReaderを使用する場合の適切なパラメータ

### assistant — 2024-03-17T00:55:49.229845+00:00

`.NET`の`DataReader`を使用する際に、パフォーマンスとリソースの管理を最適化するために検討すべきパラメータとベストプラクティスには以下のようなものがあります。これらは、データを効率的に読み込み、アプリケーションの応答性を保ちながらリソースを適切に利用するために重要です。

### 1. CommandBehavior

`ExecuteReader`メソッドを呼び出す際に、`CommandBehavior`列挙型を使用して特定の動作を指定できます。これは、実行時のパフォーマンスを向上させるために役立つ場合があります。特に注目すべき`CommandBehavior`の値には以下のものがあります：

- **CloseConnection**: `DataReader`が閉じられるときに、関連付けられている`Connection`も自動的に閉じます。これは、リソースを効果的に管理するのに役立ちます。
- **SingleResult**: コマンドが単一の結果セットを生成することがわかっている場合に使用します。これにより、SQL Serverはクエリの処理方法を最適化できる可能性があります。
- **SequentialAccess**: `DataReader`から大量のデータ、特に大きなバイナリデータや文字データを読み出す場合に有効です。これを指定すると、データをシーケンシャルにアクセスすることで、メモリ消費を抑えることができます。

### 2. Asynchronous Processing

非同期処理を有効にすることで、データの読み込み中にアプリケーションが他の作業を続けられるようになります。`SqlCommand`の`ExecuteReaderAsync`メソッドを使用して、非同期にデータを読み込むことができます。これは、特に大量のデータを扱う場合や、ユーザーインターフェースの応答性を保ちたい場合に有効です。

### 3. パラメータ化クエリ

SQLインジェクション攻撃を防ぐためにも、パフォーマンスを向上させるためにも、パラメータ化されたクエリを使用することが重要です。`SqlCommand`オブジェクトの`Parameters`コレクションを使用して、クエリにパラメータを安全に渡すことができます。パラメータ化クエリは、SQL Serverがクエリ計画を再利用しやすくするため、パフォーマンスの向上にも寄与します。

### 4. リソースの適切な解放

`DataReader`と`SqlConnection`オブジェクトは、使用後に適切に閉じるか破棄する必要があります。`using`ステートメントを利用することで、これらのリソースが自動的に解放されるようにすることができます。これは、リソースリークを防ぎ、アプリケーションの安定性とパフォーマンスを保つために重要です。

### 5. ネットワークパフォーマンスの最適化

大量のデータを転送する場合、ネットワークの遅延や帯域幅の制限がボトルネックになることがあります。可能であれば、データ

### assistant — 2024-03-17T00:56:09.618272+00:00

ベースサーバーに物理的に近い場所でアプリケーションを実行するか、データ転送量を減らす最適化（例：不要な列を省く、データをフィルタリングする）を行うことが推奨されます。

これらのベストプラクティスとパラメータを適切に使用することで、`.NET`アプリケーションでの`DataReader`の使用時に最適なパフォーマンスとリソース管理を実現することができます。
