---
conversation_id: "689d3990-c5a0-8325-9952-9f08c082b772"
title: "責務分離の提案"
create_time: 1755134364.249586
update_time: 1755134455.719638
language_guess: "en"
num_messages: 11
part_index: 1
part_count: 1
---

### user — 2025-08-14T01:19:23.895331+00:00

責務分離すべき？

巨大クラス (>250行) 
- KsqlContext.cs (942行) 
- EventSet.cs (630行) 
- Query/Pipeline/DMLQueryGenerator.cs (513行) 
- Query/Builders/Functions/KsqlFunctionTranslator.cs (475行) 
- Query/Pipeline/DDLQueryGenerator.cs (466行) 
- Query/Pipeline/GeneratorBase.cs (433行) 
- Query/Builders/WhereExpressionVisitor.cs (428行) 
- Query/Pipeline/JoinQueryGenerator.cs (360行) 
- Query/Builders/SelectExpressionVisitor.cs (360行) 
- Core/Window/WindowAggregatedEntitySet.cs (352行) 
- Query/Builders/GroupByExpressionVisitor.cs (325行) 
- Infrastructure/Admin/KafkaAdminService.cs (322行) 
- Mapping/KeyValueTypeMapping.cs (316行)

### system — 2025-08-14T01:19:24.249586+00:00

_(empty)_

### user — 2025-08-14T01:19:24.249586+00:00

_(empty)_

### system — 2025-08-14T01:19:24.249586+00:00

_(empty)_

### system — 2025-08-14T01:19:26.483394+00:00

_(empty)_

### system — 2025-08-14T01:19:26.493095+00:00

_(empty)_

### assistant — 2025-08-14T01:19:26.510356+00:00

_(empty)_

### assistant — 2025-08-14T01:19:26.793465+00:00

_(empty)_

### assistant — 2025-08-14T01:19:41.630837+00:00

やあ、司令。結論から：**上位の5〜6クラスは“責務分離（再配列）を即実施”、残りは“準備（集約ポイントの明確化）”で段階的にいきましょう。**  
テストの安定を最優先に、“切る順序”と“切り口”を決めます。

# まず判断基準（この条件を2つ以上満たせば分離）
- **行数 > 350** かつ **公開メンバ > 15**  
- **ユースケース/関心事が3つ以上**（例：定義・生成・実行・検証が同居）  
- **循環参照 or 多方向依存**（Builders⇄Pipeline⇄Contextの相互呼び）  
- **変更理由が複数**（例：KSQL方言追加、LINQ拡張、設定変更で同じクラスが毎回触れる）

# クラス別の推奨リファクタ（責務→モジュール化の提案）

## 1) KsqlContext.cs（942行）— 最優先で分割
**現状の“なんでも窓口”を薄いファサードに**。
- `Context.Model`（POCO/クエリモデル管理）
- `Context.Metadata`（トピック名、スキーマID、バージョン管理）
- `Context.Compiler`（LINQ→KSQL 変換のオーケストレーション：Builder呼び出しのみ）
- `Context.Executor`（ksqlDB への送出／検証、Dry-run/Validation）
- `Context.Configuration`（接続・方言・機能フラグ）
→ `KsqlContext` は **上記サービスの DI 受け渡しとライフサイクル管理だけ**に縮小。

## 2) EventSet.cs（630行）
読み書き・問い合わせ・コミットが同居しがち。**機能面で3分割**。
- `IReadableEventSet<T>`（購読・フィルタ・投影）
- `IWritableEventSet<T>`（Produce/Upsert・DLQ 送出）
- `ITransactionalCommit`（手動コミット、リトライ、エラー戦略）
実クラスは小さくして、**拡張メソッドで糖衣**（`ForEachAsync` など）を提供。  
※司令のIF要件（`OnError().WithRetry().ForEachAsync(...)`）は**拡張メソッド群に保持**し、中核は責務ごとに分離。

## 3) Query/Pipeline/*QueryGenerator.cs（DML:513, DDL:466, Join:360, Base:433）
**“文種 × 段”で整理**（GeneratorBaseはTemplate Methodの芯だけに）。
- `StatementModel`（中間表現：SELECT/INSERT/CREATE/ALTER などの AST 風）
- `Renderer`（`SelectRenderer`, `InsertRenderer`, `CreateStreamRenderer`…）
- `Dialect`（KSQL方言／バージョン差分をここに吸収）
- `Emitter`（最終文字列出力＋整形）
→ “生成（モデル化）”と“描画（整形）”を分けると、**方言追加やフォーマット変更**が安全に。

## 4) Query/Builders/Functions/KsqlFunctionTranslator.cs（475行）
**関数カテゴリ毎のプラグイン化**。
- `MathFunctions`, `StringFunctions`, `TimeWindowFunctions`, `AggregateFunctions`  
- `FunctionRegistry`（登録/解決・署名検証・型推論）  
→ 新関数や独自拡張の**追加コストを O(1)**に。

## 5) Expression Visitors（Where 428 / Select 360 / GroupBy 325）
**共通ユーティリティ層を新設**。
- `ExpressionNormalization`（定数巻き上げ・Null合成など）
- `MemberAccessResolver`（POCO→列名、別名管理）
- `TypeTranslation`（.NET 型→KSQL 型）
各 Visitor は **“規則（Rule）セット”を注入**して薄く保つ。  
`Select/Where/GroupBy` の重複ロジックは上記ユーティリティへ。

## 6) Core/Window/WindowAggregatedEntitySet.cs（352行）
課題に挙がっていた**Finalization/Watermark/StateStore**を分離。
- `WindowDefinition`（Hopping/Tumbling/Sessions）
- `AggregationStrategy`（Sum/Avg/Count/Custom）
- `FinalizationManager`（司令が懸念していた“収束点”の責務を単独化）
→ Finalization を個別テスト可能にして**不具合切り分け**を容易に。

## 7) Infrastructure/Admin/KafkaAdminService.cs（322行）
**管理 API を機能毎に**。
- `TopicAdmin`（作成・パラメータ更新）
- `ACLAdmin`（将来用）
- `HealthCheck`（ブローカー/スキーマレジストリ）
- `SchemaAdmin`（互換性モード、ID解決）
※ “起動時の初期化”と“運用時の変更”をモード分離。

## 8) Mapping/KeyValueTypeMapping.cs（316行）
**Key/Value/Headers を別々に**。
- `KeyMapping`, `ValueMapping`, `HeaderMapping`  
- `SchemaNegotiation`（Precision/Scale, LogicalType, 互換性チェック）
- `SerializerFactory`（Avro/JSON/Protobuf差し替え）
→ 例の **decimal(scale/precision) 問題**は `SchemaNegotiation` に寄せて一元管理。

# 実行プラン（壊さない順序・2週間目安の段階化）

1. **安全網**  
   - 変更が多い箇所から**特性テスト（Approval/Golden）**を作る：  
     - `LINQ→KSQL` 期待文字列（方言別）  
     - `Window Finalization` の時系列ケース  
     - `Mapping` の型境界（decimal, DateTime, nullable）
2. **フェーズA（3〜4日）**  
   - `KsqlContext` を薄く：内部サービスを抽出（Model/Compiler/Executor/Configuration）  
   - コンストラクタ/DIだけ差し替え、**外部IFは不変**
3. **フェーズB（3〜4日）**  
   - `EventSet` のインターフェース分離（読み/書き/コミット）  
   - 既存の `OnError().WithRetry().ForEachAsync(...)` は**拡張メソッドで互換維持**
4. **フェーズC（3〜4日）**  
   - Generators を `StatementModel→Renderer→Emitter` へ再配線  
   - KsqlFunctionTranslator をカテゴリ別に分割＋Registry導入
5. **フェーズD（2〜3日）**  
   - Expression 共通層新設＆ Visitors 軽量化  
   - Window 系の FinalizationManager 抽出
6. **仕上げ**  
   - KafkaAdminService, Mapping の分離  
   - 循環参照チェック（Roslyn analyzer or ArchUnitNET）

# 進め方の原則（司令の“やりすぎ分離は避けたい”方針に沿って）
- **“呼び出し頻度 × 変更頻度”が高い結節点のみ分離**（通らない道はそのまま）  
- **拡張メソッドでDX維持**：利用側の呼び味は変えない  
- **収束点を一箇所に**：Finalization、Emit、Schema など“最後に集まる”箇所は必ず分離  
- **1 PR = 1 責務分離**：レビュアブルな粒度を厳守

# 受け入れ基準（分離できたと言える状態）
- `KsqlContext` が **<300行**, 役割は “サービス束ね”に限定  
- `EventSet` のコアが **入出力/コミットを別IF** に分離され、拡張メソッドで従来IFを提供  
- `*QueryGenerator` が **Renderer/Dialect/Emitter** に層分けされ、  
  **方言追加が新規ファイル追加のみ**で成立  
- `FunctionTranslator` が**カテゴリ追加で O(1)**  
- `Expression Visitor` の重複が共通層へ移動、**個別Visitorは~200行級**  
- `Window Finalization` が単体テストで**時系列バグの再現と修正**を回せる

---

必要なら、各フェーズの**具体的なクラス雛形（空実装）とDI配線**まで一気に出します。  
「まずはA→B」でいきましょう。次に進めるなら、Aの**空クラスとインターフェース雛形**を今ここで提示します。

送信日時（日本時間）: [[REDACTED_PHONE]]:19

### assistant — 2025-08-14T01:19:43.422657+00:00

_(empty)_
