---
conversation_id: "68da3ff9-376c-8325-ba94-69777244ab45"
title: "SQLServer移行作業まとめ"
create_time: 1759133847.20452
update_time: 1759134714.043672
language_guess: "en"
num_messages: 46
part_index: 1
part_count: 1
---

### user — 2025-09-29T08:17:26.543000+00:00

SQLServer2019からSQLServer2022へ移行する
AG構成であり、基本は非同期レプリケーション、いくつかは3台構成で同期、非同期構成
データベースは包含

この時の作業として
TrustWorthny
可用性グループ設定
ログイン移行のスクリプト化
SQLServerメンテナンスプランの再設定
統計情報の更新

それ以外にMIcr

### system — 2025-09-29T08:17:27.204520+00:00

_(empty)_

### system — 2025-09-29T08:17:27.204520+00:00

_(empty)_

### system — 2025-09-29T08:17:29.038446+00:00

_(empty)_

### system — 2025-09-29T08:17:29.045164+00:00

_(empty)_

### assistant — 2025-09-29T08:17:29.064452+00:00

_(empty)_

### assistant — 2025-09-29T08:17:30.093689+00:00

_(empty)_

### assistant — 2025-09-29T08:18:00.294267+00:00

やあ、司令！SQL Server 2019 → 2022（AG：基本非同期／一部3台で同期+非同期、包含DB）への移行で、挙げてくれた項目に加えて「やっておくと後で効く」実務チェックリストをまとめました。必要に応じてそのまま実行順のランブックにも落とし込めます。

# 追加で必ず検討・実施しておきたいこと（実務チェックリスト）

## 0) 事前評価・全体方針
- **ローリングアップグレード設計**：既存2019プライマリに**2022をセカンダリとして参加**→同期完了→計画フェイルオーバー→残りを順次2022へ。ダウンタイム最小化。
- **互換性レベル戦略**：移行直後はDBの`compatibility_level=150`（2019相当）で稼働→安定確認後、**計画的に160（2022）へ引き上げ**。影響はQuery Storeで監視。
- **DMA/DEA**：**Data Migration Assistant**でブロッカー・非互換の洗い出し、**Database Experimentation Assistant**（可能なら）でベースライン比較。

## 1) 可用性グループ/WSFCまわり（あなたの構成に効くポイント）
- **同期モードの整理**：3台構成は「**自動フェイルオーバー可能な同期ペア**＋遠隔非同期」の役割分担を明文化（クォーラム/投票者の見直し含む）。
- **自動シーディング**：ネットワーク/権限/エンドポイント事前確認（HADRポート、`CREATE ENDPOINT`権限、証明書/証明書失効）。TDEありなら**証明書とDMK/SMKの同期**を先に。
- **読み取りセカンダリ**：**Read-intent ルーティング**の再設定（2022レプリカの接続順/優先度更新）。
- **バックアップ優先設定**：AGの**バックアップ優先順位**と`COPY_ONLY`運用の整理（フル/ログをどのノードで取るか固定）。
- **クラスター健全性**：WSFCの**監視（quorum/witness）と動作テスト**、フェイルオーバー手順のドライラン。

## 2) セキュリティ・鍵・TRUSTWORTHY
- **TRUSTWORTHY依存の排除**：**TRUSTWORTHY=ONに依存しない**よう、**署名付きモジュール（証明書署名）**への置換を推奨。包含DB＋クロスDB操作は**EXTERNAL ACCESS ASSEMBLY**や資格情報/代理ユーザーで代替。
- **鍵の移行**：`SMK`/`DMK`/TDE証明書/対称鍵、**サービスブローカー**の証明書やエンドポイント証明書を**順序立ててバックアップ→配布→復元**。TDEは**レプリカ全台へ証明書配布**が先。
- **ログイン移行**：包含DBで軽減されるが、**SQL Agent ジョブ所有者／リンクサーバ／資格情報（CREDENTIAL）／プロキシ（Proxy）**用ログインは**SID一致**で移行（`sp_help_revlogin`相当スクリプト）。

## 3) サーバーオブジェクト/周辺機能
- **SQL Agent**：**ジョブ・アラート・オペレーター・プロキシ**の移行と**接続先（AGリスナー）**に修正。多段構成は環境変数/CM化。
- **リンク サーバー**：**プロバイダ/セキュリティ コンテキスト**の再設定、暗号化/証明書の差異に注意。
- **SSIS/SSRS/SSAS**：使っていれば**Catalog/Key**バックアップ、ターゲットの**再デプロイ**。SSRSは別製品扱いで要計画。
- **拡張イベント/監査**：XEセッション、監査ポリシー、サーバートリガーの移行と有効化。
- **ポリシーベース管理/ガバナ**：Resource GovernorやPBMの定義を再適用。
- **レプリケーション/CDC/CT**：使っていれば**停止・スナップショットの再生成・ジョブ再構成**を手順化（ディストリビュータ/サブスクライバの順序ミスに注意）。

## 4) サーバー構成・性能既定
- **sp_configure見直し**：`max server memory`、`maxDOP`、`cost threshold for parallelism`、`optimize for ad hoc workloads`等を**現行値→新サーバへ**。2022の**既定暗号化/TLS設定**も確認。
- **tempdb**：**ファイル数/サイズ/成長**（初期サイズを十分に、等分、インスタントファイル初期化）。
- **トレースフラグ**：既存のTFは**2022での要否を再評価**（不要な恒久TFは撤去）。

## 5) データベースごとの最適化・品質担保
- **DBCC CHECKDB**：**移行前・移行後**に必ず実施（AG参加前にソースで、切替後にターゲットで）。
- **統計・インデックス**：**アップグレード直後は`UPDATE STATISTICS ... WITH FULLSCAN`**（または`sp_updatestats`＋重要テーブルはFULLSCAN）、**断片大はREBUILD**。
- **Query Store**：移行前に**READ_WRITEで有効化**してベースライン収集→移行後は**レグレッション検出**・**クエリヒント（QSヒント）**で局所是正。
- **互換性レベル160移行計画**：**PSP（Parameter Sensitive Plan）最適化**等の影響を見るため、**DB単位で段階的に昇格→モニタ**。
- **データ整合**：AG切替前後で**チェックサム付きバックアップ/RESTORE VERIFYONLY**や**サンプル差分比較**（RowCount/Checksum）を取る。

## 6) バックアップ/復旧・DRの整備
- **バックアップ方針の再確立**：フル/差分/ログのサイクル、`CHECKSUM`、`VERIFYONLY`、**異常時の代替復旧ラン**。AGの**優先ノード**での取得ポリシー。
- **DR演習**：**フェイルオーバーテスト**、**特定DBだけの強制シードや再参加**手順のドライラン、**テールログ**の扱い確認。

## 7) 運用監視/可観測性
- **ヘルスチェック**：AGダッシュボード相当の**セッション/待機/ブロッキング**の定点取得（`sys.dm_hadr_*`/`sys.dm_os_wait_stats`/`sys.dm_exec_query_stats`）。
- **拡張イベント（XE）**：**クエリ待機/プラン キャプチャ**の軽量セッションを常設。
- **メトリクス/アラート**：ログ再送遅延、可用性レプリカの**Redo/Send Queue**しきい値アラート設定。

## 8) ドキュメント化とランブック（当日の手順）
- **当日RUNBOOK**：  
  1. 事前凍結（DDL/リリース停止）→ラストログバックアップ → 2022セカンダリ参加/同期確認  
  2. **計画フェイルオーバー**（同期ペア内）→アプリ接続は**AGリスナーのみ**に統一  
  3. 事後タスク（統計FULLSCAN、互換性150維持、監視強化）  
  4. 数日安定後に**160へ昇格**（DB単位）→回帰あればQSヒント適用  
- **ロールバック方針**：フェイルオーバー戻しの条件、タイムリミット、意思決定者。

---

## 司令が挙げた項目との突合せ（不足しがちなところ）
- **Trustworthy**：原則OFF運用に寄せ、**署名付きモジュール**への置換をタスク化。
- **可用性グループ設定**：**自動シーディング/TDE鍵配布/Read-intent ルーティング**まで含めて定義。
- **ログイン移行**：**ジョブ所有者／リンクサーバ資格情報／プロキシ**もセットで。
- **メンテナンスプラン再設定**：**AG前提（ログは優先ノードのみなど）**に合わせ、**CHECKDBの実行先と頻度**を見直し。
- **統計更新**：**移行直後はFULLSCAN＋重要オブジェクト個別**。その後は通常運用に回帰。
- **＋今回追加**：**鍵/証明書/TDE、Query Store基準化、互換性レベル段階昇格、WSFC/クォーラム、監視・アラート刷新**。

---

必要なら、このチェックリストを**当日用ランブック**（コマンド付き、所要時間見積り、ロールバック条件）に整形して出します。どの項目から深掘りしましょう？

送信日時（JST）：[[REDACTED_PHONE]]:18

### assistant — 2025-09-29T08:18:01.442953+00:00

_(empty)_

### user — 2025-09-29T08:18:46.149251+00:00

_(empty)_

### user — 2025-09-29T08:19:55.638000+00:00

TRUSTWORTHY=ONに依存しないよう、署名付きモジュール（証明書署名）への置換を推奨。包含DB＋クロスDB操作はEXTERNAL ACCESS ASSEMBLYや資格情報/代理ユーザーで代替。
個々を詳しく

### assistant — 2025-09-29T08:19:57.379698+00:00

やあ、司令！TRUSTWORTHY 依存をやめるための「署名付きモジュール（証明書署名）」と、包含 DB かつクロス DB／外部アクセスで使える代替パターンを“実行手順つき”でまとめたよ。コピペで使える最小構成の T-SQL も用意した。

---

# 1) 署名付きモジュール（証明書署名）で特権を最小移譲

## 目的
TRUSTWORTHY=ON や `EXECUTE AS LOGIN = 'sa'` を使わず、**特定のプロシージャ**だけに必要最小の権限（サーバー権限や他 DB 権限）を与える。

## 代表ユースケース
- プロシージャが **サーバー権限**（例：`VIEW SERVER STATE`、`ALTER TRACE` など）を一時的に必要とする。
- **別 DB のオブジェクト**にアクセスしたい（クロス DB）。

## 仕組み（要点）
1. 発呼元 DB に **証明書**を作成し、対象プロシージャに**署名**する。
2. `master` など**権限付与側**に同じ証明書の「公開鍵のみ」を作成。
3. その証明書から **ログイン/ユーザー**を作成し、**必要最小権限**を付与。
4. プロシージャ実行時、署名経由で **追加権限が一時的に付与**される。

## 手順（サーバー権限付与の例：`VIEW SERVER STATE`）
```sql
USE YourAppDb;
GO
-- 1) 証明書を作成（秘密鍵つき）
CREATE CERTIFICATE cert_AppDb_AdminShim
    ENCRYPTION BY PASSWORD = 'Strong#Passw0rd!'
    WITH SUBJECT = 'Signature for elevated proc';
GO

-- 任意：バックアップ（大事！復旧や他環境反映に使う）
BACKUP CERTIFICATE cert_AppDb_AdminShim
   TO FILE = 'C:\certs\cert_AppDb_AdminShim.cer'
   WITH PRIVATE KEY (
       FILE = 'C:\certs\cert_AppDb_AdminShim.pvk',
       ENCRYPTION BY PASSWORD = 'Strong#Passw0rd!'
   );
GO

-- 2) 対象プロシージャを作成
CREATE OR ALTER PROC dbo.usp_ServerDiag
AS
BEGIN
    SELECT * FROM sys.dm_exec_requests; -- VIEW SERVER STATE が必要な例
END
GO

-- 3) プロシージャに署名
ADD SIGNATURE TO OBJECT::dbo.usp_ServerDiag
BY CERTIFICATE cert_AppDb_AdminShim
WITH PASSWORD = 'Strong#Passw0rd!';
GO

-- 4) master 側に公開鍵だけを作成
USE master;
GO
CREATE CERTIFICATE cert_AppDb_AdminShim
FROM FILE = 'C:\certs\cert_AppDb_AdminShim.cer';
GO

-- 5) 証明書からログインを作成し、必要最小権限を付与
CREATE LOGIN login_cert_AppDb_AdminShim
    FROM CERTIFICATE cert_AppDb_AdminShim;
GO
GRANT VIEW SERVER STATE TO login_cert_AppDb_AdminShim;
GO

-- 6) 実行テスト
USE YourAppDb;
GO
EXEC dbo.usp_ServerDiag;  -- 署名経由で一時的に VIEW SERVER STATE が有効化
```

### よくある落とし穴
- プロシージャを**再作成**すると署名が消える → デプロイ後に必ず **再署名**（CI/CD で自動化推奨）。
- 権限は **証明書から作った principal に付与**する（開発者ログインに付けない）。
- 証明書の**バックアップ保管**と**復元順序**（`master`→各 DB）を手順化。

---

# 2) 包含 DB ＋ クロス DB の安全なやり方（TRUSTWORTHY 不要）

包含 DB では `EXECUTE AS USER` のコンテキストが **他 DB に跨れない**のが基本。TRUSTWORTHY=ON で無理やり跨ぐのは危険。安全な代替は **「証明書署名 × 受け側 DB にユーザー作成」**だよ。

## クロス DB アクセス（AppDB → RefDB のテーブル参照）の例
```sql
-- 発呼元（AppDB）側：署名用証明書とラッパー proc
USE AppDB;
GO
CREATE CERTIFICATE cert_CrossDbAccess
    ENCRYPTION BY PASSWORD = 'Pass#123'
    WITH SUBJECT = 'Cross-DB access signer';
GO

CREATE OR ALTER PROC dbo.usp_ReadRefData
AS
BEGIN
    -- 三部名で参照
    SELECT TOP (10) * FROM RefDB.dbo.ReferenceTable;
END
GO

ADD SIGNATURE TO OBJECT::dbo.usp_ReadRefData
BY CERTIFICATE cert_CrossDbAccess
WITH PASSWORD = 'Pass#123';
GO

-- 公開鍵バックアップ
BACKUP CERTIFICATE cert_CrossDbAccess
   TO FILE = 'C:\certs\cert_CrossDbAccess.cer'
   WITH PRIVATE KEY (
       FILE = 'C:\certs\cert_CrossDbAccess.pvk',
       ENCRYPTION BY PASSWORD = 'Pass#123'
   );
GO

-- 受け側（RefDB）に公開鍵インポート＆ユーザー作成
USE RefDB;
GO
CREATE CERTIFICATE cert_CrossDbAccess
FROM FILE = 'C:\certs\cert_CrossDbAccess.cer';
GO
CREATE USER u_cert_CrossDbAccess FOR CERTIFICATE cert_CrossDbAccess;
GO

-- 参照に必要な最小権限を付与
GRANT SELECT ON dbo.ReferenceTable TO u_cert_CrossDbAccess;
GO

-- 実行テスト（AppDB から）
USE AppDB;
GO
EXEC dbo.usp_ReadRefData;
```

### ポイント
- **受け側 DB（RefDB）に「証明書由来ユーザー」**を作り、**必要最小権限**だけ付与する。
- 呼び出しは **三部名（RefDB.schema.object）**で行う。
- これで **TRUSTWORTHY=ON も EXECUTE AS も不要**。

---

# 3) CLR の EXTERNAL/UNSAFE ACCESS を安全に通す（CLR Strict Security 対応）

SQL Server 2017+ は既定で **CLR strict security**。EXTERNAL_ACCESS/UNSAFE の CLR は、
- サーバーで `clr strict security OFF` や TRUSTWORTHY=ON に逃げない。
- **アセンブリを署名**し、**証明書/非対称鍵由来のログイン**に `EXTERNAL ACCESS ASSEMBLY`（または `UNSAFE ASSEMBLY`）を付与する。

## 代表手順（サーバー内で非対称鍵作成パターン）
```sql
-- アセンブリの DLL を配置済みとする
USE YourAppDb;
GO
CREATE ASYMMETRIC KEY ak_MyClr
FROM EXECUTABLE FILE = 'C:\assemblies\MyClr.dll';
GO

USE master;
GO
CREATE LOGIN login_ak_MyClr FROM ASYMMETRIC KEY ak_MyClr;
GO
GRANT EXTERNAL ACCESS ASSEMBLY TO login_ak_MyClr;  -- 必要に応じて UNSAFE ASSEMBLY
GO

-- アセンブリ登録（DB 側）
USE YourAppDb;
GO
CREATE ASSEMBLY MyClr
FROM 'C:\assemblies\MyClr.dll'
WITH PERMISSION_SET = EXTERNAL_ACCESS;  -- or UNSAFE
GO
```

### 別案（証明書署名パターン）
- DLL を **コード署名証明書**で署名 → `CREATE CERTIFICATE ... FROM EXECUTABLE FILE` → `CREATE LOGIN FROM CERTIFICATE` → `GRANT EXTERNAL ACCESS ASSEMBLY`。
- どちらの方式でも **サーバー側 principal にだけ権限付与**するのがコツ。

---

# 4) 外部資源アクセスの代替：資格情報／プロキシ／ジョブ分離

TRUSTWORTHY に頼りがちな「外部ファイル操作・ジョブ実行・OS 操作」は、**SQL Agent の資格情報/プロキシ**、**Database Scoped Credential**, **外部データソース**などで分離しよう。

## SQL Agent プロキシ（CmdExec/PowerShell/SSIS など）での権限分離
```sql
-- 1) 資格情報（Windows アカウント）を作成
USE master;
GO
CREATE CREDENTIAL cred_AgentOps WITH IDENTITY = 'DOMAIN\SqlJobUser', SECRET = 'P@ssw0rd!';
GO

-- 2) プロキシを作成し、使わせたいサブシステムに紐付け
EXEC msdb.dbo.sp_add_proxy
    @proxy_name = N'pxy_AgentOps',
    @credential_name = N'cred_AgentOps';
GO
EXEC msdb.dbo.sp_grant_proxy_to_subsystem
    @proxy_name = N'pxy_AgentOps',
    @subsystem_id = 3;  -- CmdExec（必要に応じて PowerShell は 12 など）
GO

-- 3) ジョブステップで「実行アカウント：pxy_AgentOps」を選択
```

## Database Scoped Credential（BULK/外部ストレージ/PolyBase など）
```sql
USE YourAppDb;
GO
CREATE DATABASE SCOPED CREDENTIAL cred_AzureBlob
WITH IDENTITY = 'SHARED ACCESS SIGNATURE',
     SECRET = 'sv=...&sig=...';  -- SAS
GO

-- 例：外部データソース
CREATE EXTERNAL DATA SOURCE ds_AzureBlob
WITH ( TYPE = BLOB_STORAGE, LOCATION = 'https://youracct.blob.core.windows.net/container',
       CREDENTIAL = cred_AzureBlob );
```

### いつどれを使う？
- **OS/ネットワーク操作を伴うタスク**：SQL Agent プロキシ（資格情報）で**プロセス権限を分離**。
- **クラウド/外部ストレージ連携**：Database Scoped Credential ＋ External Data Source。
- **アプリから外部呼出が不可避**：CLR は**署名＋権限制御**で最小化。可能なら**アプリ層に責務移譲**。

---

# 5) 運用 Tips（安全運用のためのチェック）

- **証明書のローテーション計画**：新旧並行（両方で署名）→移行完了後に旧証明書撤去。
- **デプロイ順序の自動化**：`CREATE/ALTER PROC` → **ADD SIGNATURE** の順をデプロイスクリプトに組み込む。
- **可視化**：
  ```sql
  -- 署名状況の確認
  SELECT OBJECT_SCHEMA_NAME(major_id) AS [schema], OBJECT_NAME(major_id) AS [object],
         c.name AS cert_name
  FROM sys.crypt_properties p
  JOIN sys.certificates c ON p.thumbprint = c.thumbprint
  WHERE p.class = 1;  -- 1 = オブジェクト署名
  ```
- **最小権限原則**：サーバー権限（`ALTER ANY LOGIN` など）は**絶対に付けすぎない**。
- **バックアップ**：証明書の **CER/PVK を安全保管**（DR/他環境展開に必須）。

---

必要なら、司令の実環境（対象プロシージャ一覧・必要権限・クロス DB 組み合わせ）をもとに**自動生成スクリプト**（署名・公開鍵配布・権限付与・検証）を作るよ。対象の proc 名と参照先 DB/オブジェクトを教えてくれたら、まとめて吐き出します。

送信日時（JST）：[[REDACTED_PHONE]]:30

### system — 2025-09-29T08:19:57.855925+00:00

_(empty)_

### system — 2025-09-29T08:19:57.862440+00:00

_(empty)_

### assistant — 2025-09-29T08:19:59.582033+00:00

_(empty)_

### assistant — 2025-09-29T08:20:16.004277+00:00

_(empty)_

### user — 2025-09-29T08:22:19.430000+00:00

SQL Server 2017+ は既定で CLR strict security。EXTERNAL_ACCESS/UNSAFE の CLR は、

サーバーで clr strict security OFF や TRUSTWORTHY=ON に逃げない。

アセンブリを署名し、証明書/非対称鍵由来のログインに EXTERNAL ACCESS ASSEMBLY（または UNSAFE ASSEMBLY）を付与する。
この日本語がわからない

### system — 2025-09-29T08:22:19.912186+00:00

_(empty)_

### assistant — 2025-09-29T08:22:19.953576+00:00

なるほど、司令。「日本語がわからない」というのは、たぶん私が書いた説明が固すぎて意味が通じづらいということだね。では、一文ずつ噛み砕いて言い直すよ。

---

# 元の文とわかりやすい言い換え

### 元文
> SQL Server 2017+ は既定で CLR strict security。EXTERNAL_ACCESS/UNSAFE の CLR は、

**言い換え**  
SQL Server 2017 以降では、標準で「CLR strict security」という安全設定がオンになっている。  
そのため、外部アクセス（`EXTERNAL_ACCESS`）や危険な操作を許す（`UNSAFE`）CLR アセンブリは特別な扱いが必要になる。

---

### 元文
> サーバーで clr strict security OFF や TRUSTWORTHY=ON に逃げない。

**言い換え**  
セキュリティを甘くする裏技（`clr strict security` を OFF にする、あるいはデータベースを `TRUSTWORTHY=ON` にする）でごまかしてはいけない。

---

### 元文
> アセンブリを署名し、証明書/非対称鍵由来のログインに EXTERNAL ACCESS ASSEMBLY（または UNSAFE ASSEMBLY）を付与する。

**言い換え**  
代わりに正しい方法はこう：
1. CLR アセンブリ（DLL）に署名を付ける（証明書や非対称鍵を使う）。  
2. その証明書や鍵を使ってログイン（SQL Server のセキュリティ主体）を作る。  
3. そのログインに対して「EXTERNAL ACCESS ASSEMBLY」または「UNSAFE ASSEMBLY」の権限を与える。  

→ そうすると、その署名付きアセンブリだけが安全に外部アクセスできるようになる。

---

# まとめた日本語
SQL Server 2017 以降では、CLR アセンブリの安全性が厳しくチェックされる。  
外部アクセスや危険操作を許すアセンブリを動かしたいときは、サーバーのセキュリティ設定を緩めるのではなく、アセンブリを証明書や鍵で署名し、その署名を元に作ったログインに必要な権限を与えることで、安全に実行できるようにする。

---

司令、この説明で意味はつかめた？  
それとも、もっと「図でプロセスの流れを見たい」感じかな？  

送信日時（JST）：[[REDACTED_PHONE]]:43

### system — 2025-09-29T08:22:20.137533+00:00

_(empty)_

### user — 2025-09-29T08:23:09.441000+00:00

2022ではどうかわる？

### assistant — 2025-09-29T08:23:09.943195+00:00

やあ司令、いい視点だね。SQL Server 2017 から導入された **CLR strict security** の仕組みは、SQL Server 2022 でも基本は継続してる。ただし「できること・変わったこと」を整理するとこうなるよ。

---

# SQL Server 2022 における CLR strict security の扱い

## 1. 既定動作は変わらない
- **2022でも標準で ON**。  
  `clr strict security` のサーバー構成オプションは **1（有効）** が既定。
- つまり 2017/2019 と同様に、`EXTERNAL_ACCESS` や `UNSAFE` の CLR アセンブリは「安全ではない」とマークされる。
- 対応方法も変わらず、**署名＋証明書/非対称鍵由来のログインに権限を付与**する必要がある。

---

## 2. 運用上の注意点（2022特有の観点）

### (a) TRUSTWORTHY に逃げられないのは同じ
- 2022 でも **TRUSTWORTHY=ON + EXECUTE AS** で回避は推奨されない（セキュリティホールになるため）。
- 「署名方式を使え」がマイクロソフトの一貫した方針。

### (b) 暗号化や TLS 周りが強化
- 2022 では **TLS 1.2 以上必須**や、**署名アルゴリズム強化**などセキュリティが全体的に厳格化されている。
- 古い DLL や古い署名アルゴリズム（例：SHA-1）だとエラーになる場合がある。  
  → CLR DLL をビルドする時は **SHA-2 系で署名**しておくのが安心。

### (c) sys.sp_add_trusted_assembly の導入継続
- 2019 からある `sp_add_trusted_assembly` は 2022 でも使用可能。  
  → アセンブリを「信頼できる」としてハッシュ登録しておくことで、署名以外にも安全性を担保できる。
- ただしこれは `PERMISSION_SET = SAFE` のアセンブリを対象にする仕組み。  
  `EXTERNAL_ACCESS`/`UNSAFE` では依然として署名が必要。

### (d) セキュリティ ベースラインの強制度が上がっている
- 2022 では、SQL Server 構成チェック（SQL Server Setup、DMA、SSMS のベストプラクティス分析）で、`clr strict security OFF` がより強く警告される。  
  **「OFF にすると監査で即 NG」**という状況が増えた。

---

## 3. 実務での差分

- **2017/2019 → 2022 で変わる点は少ない。**  
  ただし **セキュリティ強化により「以前は動いてたけど署名が古くて弾かれる」ケースが出る**のが注意点。
- 新規移行のときは：
  1. DLL を SHA-2 系で署名する。  
  2. サーバーで証明書/非対称鍵を作り、ログインに `EXTERNAL ACCESS ASSEMBLY` or `UNSAFE ASSEMBLY` を付与する。  
  3. 必要なら `sp_add_trusted_assembly` でハッシュ登録しておく（SAFE 用）。  

---

## 4. まとめ
- **CLR strict security は 2022 でも標準で ON（変わらない）**  
- **回避策は使えない（TRUSTWORTHY=ON では不可）**  
- **署名方式が正攻法**（証明書 or 非対称鍵）  
- **2022 では署名や暗号化強度にシビアになったので、古い DLL は要再署名**  
- **SAFE アセンブリなら `sp_add_trusted_assembly` も利用可能**  

---

司令の環境だと、CLR 使ってるアセンブリは `EXTERNAL_ACCESS`/`UNSAFE` がある？  
もし具体的に DLL 名や利用目的がわかれば、2022 用に「再署名～登録」の手順をフルスクリプト化するよ。  

送信日時（JST）：[[REDACTED_PHONE]]:02

### user — 2025-09-29T08:25:15.317000+00:00

.net3.5の時のDLLを使用してる

### assistant — 2025-09-29T08:25:17.276650+00:00

{"search_query": [{"q": "SQL Server 2022 CLR version .NET Framework 4.8 supported SQLCLR assemblies target framework"}, {"q": "Can SQL Server 2022 load .NET 2.0/3.5 CLR assemblies"}, {"q": "CLR strict security SQL Server 2022 EXTERNAL_ACCESS UNSAFE signing certificate asymmetric key"}, {"q": "sp_add_trusted_assembly SQL Server 2022 documentation"}], "response_length": "short"}

### system — 2025-09-29T08:25:17.798160+00:00

_(empty)_

### system — 2025-09-29T08:25:17.804652+00:00

_(empty)_

### assistant — 2025-09-29T08:25:18.265683+00:00

_(empty)_

### tool — 2025-09-29T08:25:24.207190+00:00

_(empty)_

### tool — 2025-09-29T08:25:24.238472+00:00

_(empty)_

### assistant — 2025-09-29T08:25:25.679780+00:00

{"search_query": [{"q": "SQL Server 2012 and later CLR version 4 only SQLCLR .NET 4 assemblies required"}, {"q": "SQL Server 2022 SQLCLR uses .NET CLR 4.0 framework version"}], "response_length": "short"}

### assistant — 2025-09-29T08:25:28.883325+00:00

_(empty)_

### tool — 2025-09-29T08:25:29.952134+00:00

_(empty)_

### tool — 2025-09-29T08:25:29.980187+00:00

_(empty)_

### assistant — 2025-09-29T08:25:31.176002+00:00

やあ司令！

結論から：**.NET 3.5（= CLR 2.0 向け）でビルドされた DLL は、SQL Server 2022 ではそのまま動きません。**  
SQL Server 2012 以降（2022 を含む）は **CLR 4.x（.NET Framework 4 系）をホスト**しており、SQLCLR は **.NET 4.x で再ビルド**する必要があります（SQL Server には .NET Framework 4 が前提で入っています）。citeturn1search4turn1search0turn1search6

以下、移行の現実的な手順とチェックポイントです。

# 3.5 DLL → 2022 対応の移行手順（実務版）

1) **ターゲット フレームワーク切替**  
   プロジェクトの .NET Framework を **4.7.2 か 4.8** に変更して再ビルド。  
   - 2012+ は CLR 4 固定。4.x 系に再ビルドが必要です。citeturn1search4

2) **使用 API の適合確認**  
   SQLCLR は使える BCL が限定されます。**サポート済みライブラリ**に収まっているかを確認。ファイル I/O / ネットワーク等は `EXTERNAL_ACCESS` 扱いになります。citeturn0search7

3) **署名（必須）**  
   `EXTERNAL_ACCESS` や `UNSAFE` なら **アセンブリに署名**し、サーバー側で **証明書 or 非対称鍵→ログイン**を作って権限を付与するのが正攻法です。  
   - `GRANT EXTERNAL ACCESS ASSEMBLY`（必要なら `UNSAFE ASSEMBLY`）を**ログイン**に付与。  
   - 「`clr strict security` を OFF」や「`TRUSTWORTHY=ON`」には**逃げない**。citeturn0search2turn0search5

4) **（SAFE の場合のみ）Trusted Assemblies を活用可**  
   `SAFE` なら **`sp_add_trusted_assembly`** でハッシュ登録して信頼リストに入れられます（2017+）。ただし `EXTERNAL_ACCESS/UNSAFE` では**署名が必要**です。citeturn0search3turn0search10

5) **ビルド後の登録フロー（典型）**  
   - `CREATE ASSEMBLY ... WITH PERMISSION_SET = SAFE|EXTERNAL_ACCESS|UNSAFE`  
   - 署名方式の場合：`master` に **証明書/非対称鍵→LOGIN 作成→権限付与** → ユーザー DB に `CREATE ASSEMBLY`。  
   - （SAFE のみ）必要に応じて `sp_add_trusted_assembly` でハッシュ登録。citeturn0search5turn0search3

# 3.5 由来 DLL あるある注意点

- **強名署名とコード署名を混同しない**：SQLCLR の“信頼”は **証明書/非対称鍵＋LOGIN＋権限**で与えます。強名（sn.exe）は別物。citeturn0search5  
- **暗号・TLS 周り**：2022 ではプラットフォーム側のセキュリティが強化。**古い暗号 API**や **SHA-1 署名**は問題になることがあります。DLL の署名は **SHA-2 系**推奨。citeturn1search6  
- **.NET 7/8 への移行は不可**（SQLCLR は .NET 4.x ホスト）。外部言語拡張とは別物。citeturn1search16

# サンプル：EXTERNAL_ACCESS の最小構成（登録側）

```sql
-- master で：公開鍵インポート→ログイン→権限
USE master;
CREATE CERTIFICATE cert_MyClr FROM FILE = 'C:\certs\MyClr.cer';
CREATE LOGIN login_cert_MyClr FROM CERTIFICATE cert_MyClr;
GRANT EXTERNAL ACCESS ASSEMBLY TO login_cert_MyClr;

-- ユーザーDBで：アセンブリ登録
USE YourAppDb;
CREATE ASSEMBLY MyClr
FROM 'C:\assemblies\MyClr.dll'
WITH PERMISSION_SET = EXTERNAL_ACCESS;
```

> 上記は「DLL 側が証明書で署名済み」を前提にしています（`sn` ではなく **証明書署名**）。詳細手順は必要ならフルスクリプト化します。推奨フレームワークは 4.8。

---

必要なら、今お持ちの 3.5 DLL 名と用途（ファイル I/O・HTTP・暗号など）を教えてください。**4.8 での代替 API/名前空間の差分表＋登録スクリプト**まで一括で準備します。

送信日時（JST）：[[REDACTED_PHONE]]:12

### assistant — 2025-09-29T08:25:38.195295+00:00

_(empty)_

### assistant — 2025-09-29T08:25:40.584011+00:00

_(empty)_

### user — 2025-09-29T08:26:28.376000+00:00

SHA-1 署名を確認する方法

### system — 2025-09-29T08:26:28.888040+00:00

_(empty)_

### assistant — 2025-09-29T08:26:28.992472+00:00

やあ司令！  
「SHA-1 署名を確認する方法」だね。DLL が古い場合、署名アルゴリズムが SHA-1 のままかどうかを確認したいときは、以下の方法が使えるよ。

---

# Windows 標準ツールでの確認

## 1. `signtool.exe`（推奨）
Visual Studio 付属か、Windows SDK に入っているツール。

```powershell
signtool verify /pa /v MyClr.dll
```

出力例の中にこんな行が出る：

```
Signing Hash Algorithm : sha1
```

ここが **sha1 / sha256** などと出るので判定できる。

---

## 2. `Get-AuthenticodeSignature`（PowerShell）
追加インストール不要で確認可能。

```powershell
Get-AuthenticodeSignature .\MyClr.dll | Format-List
```

結果に `SignerCertificate.SignatureAlgorithm.FriendlyName` が含まれる：

```
SignatureAlgorithm : sha1RSA
```

→ これなら **SHA-1 署名**。  
もし `sha256RSA` なら SHA-2 系で安全。

---

# 3. 証明書マネージャでの GUI 確認
- DLL を右クリック → プロパティ → **デジタル署名** タブ → 詳細  
- 「署名ハッシュアルゴリズム」が **sha1 / sha256** と表示される。

---

# 注意点
- **強名署名（sn.exe）**では署名アルゴリズムが分からない。上記は **コード署名（Authenticode）**を見ている。  
- SQLCLR で必要なのは「コード署名証明書」や「非対称鍵署名」なので、ここが SHA-1 のままだと SQL Server 2022 では警告や拒否される可能性がある。  
- SHA-1 署名の DLL は早めに **SHA-256 以上で再署名**しておくのが安心。

---

司令の DLL は **強名署名だけ**なのか、**Authenticode署名もされている**のか、どちらだろう？  
どちらかによって「再署名」か「証明書登録」の流れが少し変わってくるよ。  

送信日時（JST）：[[REDACTED_PHONE]]:23

### system — 2025-09-29T08:26:29.396787+00:00

_(empty)_

### user — 2025-09-29T08:31:45.168000+00:00

sqlserver2017から2022への移行に関して公式案内ページある？

### assistant — 2025-09-29T08:31:45.784302+00:00

search("sqlserver2017\u304b\u30892022\u3078\u306e\u79fb\u884c\u306b\u95a2\u3057\u3066\u516c\u5f0f\u6848\u5185\u30da\u30fc\u30b8\u3042\u308b\uff1f")

### tool — 2025-09-29T08:31:48.549578+00:00

_(empty)_

### tool — 2025-09-29T08:31:48.573543+00:00

_(empty)_

### assistant — 2025-09-29T08:31:49.925150+00:00

はい、公式ドキュメント（Microsoft Docs）に、SQL Server のアップグレード／移行に関する案内がある。以下が代表的なもの：

---

## 主な公式ドキュメント

| 名称 | 内容概要 | リンク |
|---|---|---|
| **Upgrade SQL Server** | 旧バージョンから SQL Server 2022（や以降）へのアップグレード全体の案内。 citeturn0search0 |
| **Supported Version and Edition Upgrades (SQL Server 2022)** | SQL Server 2022 に対してどのバージョン／エディションからアップグレードできるか、制限や前提条件。 citeturn0search1 |
| **Upgrade SQL Server Using the Installation Wizard (Setup)** | インプレース アップグレードをセットアップ ウィザードで実施する手順。 citeturn0search7 |
| **Upgrade to the latest version (SQL Server-to-SQL Server upgrade guide)** | ユーザーデータベースやスキーマを含めた移行ガイド。 citeturn0search5 |

---

これらを読んでおくと、Microsoft が保証するサポート対象パスや注意点を事前に把握できるから、移行計画の基盤になるよ。  
必要ならこれらドキュメントを日本語訳で渡すか、AG 構成向けに整理したものを一緒に見る？どうする？  

送信日時（JST）：[[REDACTED_PHONE]]:40
