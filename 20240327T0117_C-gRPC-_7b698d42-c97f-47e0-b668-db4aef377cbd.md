---
conversation_id: "7b698d42-c97f-47e0-b668-db4aef377cbd"
title: "C# gRPC クライアント作成"
create_time: 1711502275.058303
update_time: 1711507373.425275
language_guess: "en"
num_messages: 20
part_index: 1
part_count: 1
---

### system — 2024-03-27T01:17:55.058303+00:00

_(empty)_

### user — 2024-03-27T01:17:55.059005+00:00

k8s上のPodでgrpcのhttp3でホストしているサーバに接続するPodをC#で構築する場合、接続先の指定方法はどのようになるのか。相手側がダウンしている場合は他のPodに再度リクエストを送信する機能も含めてソースを提示

### assistant — 2024-03-27T01:18:07.503831+00:00

C#でgRPCを使用してKubernetes上のPodに接続する場合、接続先の指定方法と再試行ロジックを含む基本的なソースコードを以下に示します。以下の例では、gRPCのクライアントを作成し、接続先を指定する方法と、接続が失敗した場合の再試行ロジックを実装します。

まず、`Grpc.Core`パッケージをインストールする必要があります。これは、gRPCのC#実装を提供します。

```bash
dotnet add package Grpc.Core
```

以下は、接続先の指定と再試行ロジックを含むC#の基本的なコードです。

```csharp
using System;
using Grpc.Core;
using System.Threading.Tasks;
using Grpc.Net.Client;

namespace GrpcClient
{
    class Program
    {
        static async Task Main(string[] args)
        {
            // gRPCサービスのアドレス
            string serviceAddress = "http://grpc-service.default.svc.cluster.local:50051"; // ここにサービスのアドレスを入力

            // gRPCチャンネルを作成
            GrpcChannel channel = GrpcChannel.ForAddress(serviceAddress);

            // gRPCサービスに接続するクライアントを作成
            var client = new YourGrpcService.YourGrpcServiceClient(channel);

            // 接続を試行し、例外が発生した場合はリトライする
            int retryCount = 3; // リトライ回数
            int currentRetry = 0;

            while (currentRetry < retryCount)
            {
                try
                {
                    // gRPCサービスのメソッドを呼び出し
                    var response = await client.YourGrpcMethodAsync(new YourRequest());

                    // レスポンスを処理
                    Console.WriteLine("Response: " + response);

                    // 成功したのでループを終了
                    break;
                }
                catch (RpcException ex)
                {
                    // RPC例外をキャッチし、ログに出力
                    Console.WriteLine($"An error occurred: {ex.Status.StatusCode}, {ex.Status.Detail}");

                    // リトライする
                    currentRetry++;

                    if (currentRetry < retryCount)
                    {
                        // 一定時間待ってから再試行
                        await Task.Delay(1000); // 1秒待機してから再試行
                    }
                }
            }

            if (currentRetry >= retryCount)
            {
                // リトライ回数を超えても接続できない場合の処理
                Console.WriteLine("Failed to connect after multiple retries.");
            }

            // gRPCチャンネルをシャットダウン
            await channel.ShutdownAsync();
        }
    }
}
```

上記のコードでは、`GrpcChannel.ForAddress()`メソッドを使用して、gRPCサービスのアドレスを指定します。また、`YourGrpcService`と`YourGrpcMethod`は、実際のgRPCサービスとメソッドに置き換える必要があります。

再試行のロジックは、`try-catch`ブロック内でRPC例外が発生した場合にリトライを試みます。最大リトライ回数は`retryCount`で指定され、リトライの間に一定の待機時間があります。リトライ回数を超えた場合、適切なエラーハンドリングを行います。

このコードは、基本的な構造を提供し、実際のシステムに組み込む際に適切に調整する必要があります。

### user — 2024-03-27T01:18:31.537598+00:00

Pollyを使用する例を提示

### assistant — 2024-03-27T01:18:41.852239+00:00

Pollyは、リトライ、キャッシュ、回路の断絶などのポリシーを定義し、これらのポリシーをHTTPリクエストや他のアクションに適用するための.NETライブラリです。以下は、Pollyを使用してC#でgRPC接続をリトライする例です。

まず、Polly NuGet パッケージをインストールします。

```bash
dotnet add package Polly
```

次に、Pollyを使用して gRPC 接続をリトライする例を示します。

```csharp
using System;
using System.Net.Http;
using System.Threading.Tasks;
using Grpc.Core;
using Grpc.Net.Client;
using Polly;

namespace GrpcClient
{
    class Program
    {
        static async Task Main(string[] args)
        {
            // gRPCサービスのアドレス
            string serviceAddress = "http://grpc-service.default.svc.cluster.local:50051"; // ここにサービスのアドレスを入力

            // Polly ポリシーを定義
            var policy = Policy
                .Handle<RpcException>() // ハンドルする例外のタイプを指定
                .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))); // リトライポリシーを設定 (最大3回、指数バックオフ)

            // gRPC チャンネルを作成
            GrpcChannel channel = GrpcChannel.ForAddress(serviceAddress);

            // ポリシーを適用した gRPC クライアントを作成
            var policyWrappedClient = policy.WrapAsync<AsyncUnaryCall<Response>>(async () =>
            {
                // gRPC クライアントの作成
                var client = new YourGrpcService.YourGrpcServiceClient(channel);
                
                // gRPC サービスのメソッドを呼び出し
                return await client.YourGrpcMethodAsync(new YourRequest());
            });

            try
            {
                // ポリシーに従って gRPC メソッドを呼び出し
                var response = await policyWrappedClient();

                // レスポンスを処理
                Console.WriteLine("Response: " + response);
            }
            catch (RpcException ex)
            {
                // RPC 例外をキャッチし、ログに出力
                Console.WriteLine($"An error occurred: {ex.Status.StatusCode}, {ex.Status.Detail}");
            }

            // gRPC チャンネルをシャットダウン
            await channel.ShutdownAsync();
        }
    }
}
```

この例では、Pollyの`WaitAndRetryAsync`ポリシーを使用して、最大3回のリトライを行います。リトライ間隔は指数バックオフに従います。PollyによってラップされたgRPCクライアントを作成し、リトライが自動的に行われるようにします。

リトライの他にも、Pollyを使用してさまざまなポリシーを適用できます。詳細については、Pollyの公式ドキュメントを参照してください。

### user — 2024-03-27T01:40:01.148188+00:00

C#を前提にBroadcastメッセージを送信する側と受信する側のコードを示せ

### assistant — 2024-03-27T01:40:11.435259+00:00

C#を使用してブロードキャストメッセージを送信する側と受信する側のコードを示します。以下の例では、UDPソケットを使用してブロードキャストメッセージを送信し、受信します。

送信側のコード:

```csharp
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

class Program
{
    static void Main(string[] args)
    {
        // ブロードキャスト送信用のポート番号
        int port = 11000;

        // ブロードキャストを送信するメッセージ
        string message = "Hello, World!";

        // ブロードキャストアドレス
        IPAddress broadcastAddress = IPAddress.Parse("192.168.1.255"); // ここにブロードキャストアドレスを入力

        // UDPソケットを作成し、ブロードキャストを有効にする
        using (UdpClient client = new UdpClient())
        {
            client.EnableBroadcast = true;

            // メッセージをバイト配列にエンコード
            byte[] bytes = Encoding.UTF8.GetBytes(message);

            // ブロードキャストを送信
            client.Send(bytes, bytes.Length, new IPEndPoint(broadcastAddress, port));

            Console.WriteLine("Broadcast message sent: " + message);
        }
    }
}
```

受信側のコード:

```csharp
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        // ブロードキャスト受信用のポート番号
        int port = 11000;

        // ブロードキャストアドレス
        IPAddress broadcastAddress = IPAddress.Any;

        // UDPソケットを作成し、ブロードキャストを受信する
        using (UdpClient client = new UdpClient(port))
        {
            // ブロードキャストアドレスとポートにバインド
            client.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            client.Client.Bind(new IPEndPoint(IPAddress.Any, port));

            // 受信待機
            Console.WriteLine("Waiting for broadcast messages...");

            // ブロードキャストを受信
            while (true)
            {
                // メッセージを受信
                IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                byte[] receivedBytes = client.Receive(ref remoteEndPoint);
                string message = Encoding.UTF8.GetString(receivedBytes);

                // 受信したメッセージを表示
                Console.WriteLine("Received broadcast message from " + remoteEndPoint + ": " + message);
            }
        }
    }
}
```

送信側では、`UdpClient` を使用してブロードキャストメッセージを送信し、受信側では同様に `UdpClient` を使用してブロードキャストメッセージを受信します。送信側では `EnableBroadcast` プロパティを true に設定してブロードキャストを有効にし、受信側では受信待機してメッセージを受信します。

### user — 2024-03-27T01:48:05.197730+00:00

C#のGrpcでcallbackを行うサンプルコード

### assistant — 2024-03-27T01:48:19.348027+00:00

C#のgRPCでは、サーバー側で受信したリクエストに対して非同期で処理を行い、クライアントにレスポンスを返すことが一般的です。これは、gRPCの自然な動作です。しかし、クライアントが非同期的にサーバーにメッセージを送信し、サーバーがそれに応答してからクライアントが処理を継続するような、典型的なコールバックのシナリオは、gRPCには含まれていません。

ただし、非同期の処理を模倣してコールバックを実現する方法があります。以下は、簡単な例です：

まず、クライアントがサーバーにリクエストを送信し、サーバーが処理を開始したことを通知するコールバックを実装します。

クライアント側のコード:

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        // gRPCサービスのアドレス
        string serviceAddress = "localhost:50051"; // ここにサービスのアドレスを入力

        // gRPCチャンネルを作成
        var channel = new Channel(serviceAddress, ChannelCredentials.Insecure);

        // gRPCサービスに接続するクライアントを作成
        var client = new YourGrpcService.YourGrpcServiceClient(channel);

        // サーバーにリクエストを送信し、コールバックを受信する
        var response = await client.SendRequestAsync(new YourRequest());

        // サーバーがリクエストを受け付けたことを通知
        Console.WriteLine("Request sent. Waiting for response...");

        // サーバーからのレスポンスを待機
        await response.ResponseStream.MoveNext();

        // レスポンスを取得
        var serverResponse = response.ResponseStream.Current;

        // サーバーからのレスポンスを処理
        Console.WriteLine("Received response from server: " + serverResponse);

        // gRPCチャンネルをシャットダウン
        await channel.ShutdownAsync();
    }
}
```

サーバー側のコード:

```csharp
using Grpc.Core;
using System.Threading.Tasks;

class YourGrpcServiceImplementation : YourGrpcService.YourGrpcServiceBase
{
    public override async Task<YourResponse> SendRequest(YourRequest request, ServerCallContext context)
    {
        // クライアントにリクエストを受け付けたことを通知
        Console.WriteLine("Request received from client.");

        // ここで実際の処理を行う

        // レスポンスを生成
        var response = new YourResponse { Message = "Processing request..." };

        // クライアントにレスポンスを返す
        await Task.Delay(2000); // 仮の非同期処理をシミュレート
        return response;
    }
}

class Program
{
    const int Port = 50051;

    static void Main(string[] args)
    {
        Server server = new Server
        {
            Services = { YourGrpcService.BindService(new YourGrpcServiceImplementation()) },
            Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
        };
        server.Start();

        Console.WriteLine("Server listening on port " + Port);
        Console.WriteLine("Press any key to stop the server...");
        Console.ReadKey();

        server.ShutdownAsync().Wait();
    }
}
```

この例では、クライアントがリクエストを送信すると、サーバーはリクエストを受け取ったことを通知します。ただし、この通知はブロックされず、クライアントはこの通知を受け取ってからサーバーからのレスポンスを待機します。サーバー側では、受け取ったリクエストを処理し、2秒後にレスポンスを返します。

### user — 2024-03-27T01:49:33.723518+00:00

通信が切れた場合のコードを追加

### assistant — 2024-03-27T01:49:46.328946+00:00

通信が切れた場合のハンドリングを追加するために、クライアントとサーバーの両方にエラーハンドリングを導入します。以下は、エラーハンドリングを追加したコードです。

クライアント側のコード:

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        // gRPCサービスのアドレス
        string serviceAddress = "localhost:50051"; // ここにサービスのアドレスを入力

        // gRPCチャンネルを作成
        var channel = new Channel(serviceAddress, ChannelCredentials.Insecure);

        // gRPCサービスに接続するクライアントを作成
        var client = new YourGrpcService.YourGrpcServiceClient(channel);

        try
        {
            // サーバーにリクエストを送信し、コールバックを受信する
            var response = await client.SendRequestAsync(new YourRequest());

            // サーバーがリクエストを受け付けたことを通知
            Console.WriteLine("Request sent. Waiting for response...");

            // サーバーからのレスポンスを待機
            await response.ResponseStream.MoveNext();

            // レスポンスを取得
            var serverResponse = response.ResponseStream.Current;

            // サーバーからのレスポンスを処理
            Console.WriteLine("Received response from server: " + serverResponse);
        }
        catch (RpcException ex)
        {
            // gRPCエラーが発生した場合の処理
            Console.WriteLine($"gRPC Error: {ex.Status.StatusCode}, {ex.Status.Detail}");
        }
        finally
        {
            // gRPCチャンネルをシャットダウン
            await channel.ShutdownAsync();
        }
    }
}
```

サーバー側のコード:

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

class YourGrpcServiceImplementation : YourGrpcService.YourGrpcServiceBase
{
    public override async Task<YourResponse> SendRequest(YourRequest request, ServerCallContext context)
    {
        try
        {
            // クライアントにリクエストを受け付けたことを通知
            Console.WriteLine("Request received from client.");

            // ここで実際の処理を行う

            // レスポンスを生成
            var response = new YourResponse { Message = "Processing request..." };

            // クライアントにレスポンスを返す
            await Task.Delay(2000); // 仮の非同期処理をシミュレート
            return response;
        }
        catch (Exception ex)
        {
            // エラーハンドリング
            Console.WriteLine($"Error: {ex.Message}");
            throw; // エラーを再スローしてクライアントに伝播
        }
    }
}

class Program
{
    const int Port = 50051;

    static void Main(string[] args)
    {
        Server server = new Server
        {
            Services = { YourGrpcService.BindService(new YourGrpcServiceImplementation()) },
            Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
        };
        server.Start();

        Console.WriteLine("Server listening on port " + Port);
        Console.WriteLine("Press any key to stop the server...");
        Console.ReadKey();

        server.ShutdownAsync().Wait();
    }
}
```

このようにすることで、クライアントがgRPCエラーをキャッチし、サーバー側でも例外が発生した場合にそれをハンドリングすることができます。

### user — 2024-03-27T02:40:07.650293+00:00

C#でGRPCのサービスのサンプルコード

### assistant — 2024-03-27T02:40:19.008251+00:00

以下は、C#で gRPC のサービスを作成するための基本的なサンプルコードです。

まず、gRPC のプロトコル バッファー ファイル (`.proto` ファイル) を作成します。以下は、簡単な例です。

```protobuf
syntax = "proto3";

package YourNamespace;

service YourService {
    rpc YourMethod (YourRequest) returns (YourResponse);
}

message YourRequest {
    string data = 1;
}

message YourResponse {
    string result = 1;
}
```

次に、このプロトコル バッファー ファイルから C# のクライアントとサーバー コードを生成します。gRPC ツールを使用して行います。

```
protoc --proto_path=./protos --csharp_out=./generated --grpc_out=./generated --plugin=protoc-gen-grpc=C:\path_to_grpc_csharp_plugin\grpc_csharp_plugin.exe ./protos/your_proto_file.proto
```

上記のコマンドで生成されたクライアントおよびサーバー コードを使用して、gRPC サービスを実装します。

サーバー側の実装:

```csharp
using Grpc.Core;
using System.Threading.Tasks;

namespace YourNamespace
{
    public class YourServiceImplementation : YourService.YourServiceBase
    {
        public override Task<YourResponse> YourMethod(YourRequest request, ServerCallContext context)
        {
            // クライアントからのリクエストを処理
            string result = "Hello, " + request.Data;
            return Task.FromResult(new YourResponse { Result = result });
        }
    }

    class Program
    {
        const int Port = 50051;

        static void Main(string[] args)
        {
            Server server = new Server
            {
                Services = { YourService.BindService(new YourServiceImplementation()) },
                Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
            };
            server.Start();

            Console.WriteLine("Server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();

            server.ShutdownAsync().Wait();
        }
    }
}
```

クライアント側の実装:

```csharp
using Grpc.Core;
using System;

namespace YourNamespace
{
    class Program
    {
        static void Main(string[] args)
        {
            // gRPCサービスのアドレス
            string serviceAddress = "localhost:50051"; // ここにサービスのアドレスを入力

            // gRPCチャンネルを作成
            var channel = new Channel(serviceAddress, ChannelCredentials.Insecure);

            // gRPCサービスに接続するクライアントを作成
            var client = new YourService.YourServiceClient(channel);

            // サービスのメソッドを呼び出す
            var response = client.YourMethod(new YourRequest { Data = "World" });

            // レスポンスを処理
            Console.WriteLine("Response from server: " + response.Result);

            // gRPCチャンネルをシャットダウン
            channel.ShutdownAsync().Wait();
        }
    }
}
```

これで、簡単な gRPC のサービスとクライアントが作成されました。必要に応じて、プロトコル バッファー ファイルを変更し、新しいメソッドやメッセージを追加して機能を拡張できます。

### user — 2024-03-27T02:40:30.069984+00:00

ProtoBufを利用する前提で

### assistant — 2024-03-27T02:40:39.793691+00:00

了解しました。ProtoBuf を使用して gRPC のサービスを作成するための基本的なサンプルコードを提供します。

まず、プロトコル バッファー ファイル (`.proto` ファイル) を作成します。

```protobuf
syntax = "proto3";

option csharp_namespace = "YourNamespace";

package YourPackage;

message YourRequest {
    string data = 1;
}

message YourResponse {
    string result = 1;
}

service YourService {
    rpc YourMethod (YourRequest) returns (YourResponse);
}
```

次に、この `.proto` ファイルから C# のクライアントとサーバー コードを生成します。

```
protoc --proto_path=./protos --csharp_out=./generated ./protos/your_proto_file.proto
```

サーバー側の実装:

```csharp
using Google.Protobuf;
using Grpc.Core;
using System.Threading.Tasks;

namespace YourNamespace
{
    class YourServiceImplementation : YourService.YourServiceBase
    {
        public override Task<YourResponse> YourMethod(YourRequest request, ServerCallContext context)
        {
            // クライアントからのリクエストを処理
            string result = "Hello, " + request.Data;
            return Task.FromResult(new YourResponse { Result = result });
        }
    }

    class Program
    {
        const int Port = 50051;

        static void Main(string[] args)
        {
            Server server = new Server
            {
                Services = { YourService.BindService(new YourServiceImplementation()) },
                Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
            };
            server.Start();

            Console.WriteLine("Server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();

            server.ShutdownAsync().Wait();
        }
    }
}
```

クライアント側の実装:

```csharp
using Google.Protobuf;
using Grpc.Core;
using System;

namespace YourNamespace
{
    class Program
    {
        static void Main(string[] args)
        {
            // gRPCサービスのアドレス
            string serviceAddress = "localhost:50051"; // ここにサービスのアドレスを入力

            // gRPCチャンネルを作成
            var channel = new Channel(serviceAddress, ChannelCredentials.Insecure);

            // gRPCサービスに接続するクライアントを作成
            var client = new YourService.YourServiceClient(channel);

            // サービスのメソッドを呼び出す
            var response = client.YourMethod(new YourRequest { Data = "World" });

            // レスポンスを処理
            Console.WriteLine("Response from server: " + response.Result);

            // gRPCチャンネルをシャットダウン
            channel.ShutdownAsync().Wait();
        }
    }
}
```

これで、ProtoBuf を使用して簡単な gRPC のサービスとクライアントが作成されました。

### user — 2024-03-27T02:41:32.135808+00:00

.protoファイルではなくinterfaceを利用する前提で

### assistant — 2024-03-27T02:41:41.084921+00:00

了解しました。ProtoBuf ファイルを使用せずに gRPC のサービスをインターフェースで定義し、そのインターフェースを実装するサーバークラスを作成する方法があります。以下は、その方法に基づいたサンプルコードです。

まず、gRPC のサービスを定義するためのインターフェースを作成します。

```csharp
using System.Threading.Tasks;

namespace YourNamespace
{
    public interface IYourService
    {
        Task<YourResponse> YourMethod(YourRequest request);
    }

    public class YourRequest
    {
        public string Data { get; set; }
    }

    public class YourResponse
    {
        public string Result { get; set; }
    }
}
```

次に、このインターフェースを実装するサービスクラスを作成します。

```csharp
using System.Threading.Tasks;

namespace YourNamespace
{
    public class YourService : IYourService
    {
        public Task<YourResponse> YourMethod(YourRequest request)
        {
            // クライアントからのリクエストを処理
            string result = "Hello, " + request.Data;
            return Task.FromResult(new YourResponse { Result = result });
        }
    }
}
```

最後に、このサービスクラスを gRPC のサービスとして公開します。これには、gRPC のサーバーを作成し、作成したサービスクラスのインスタンスを登録する必要があります。

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

namespace YourNamespace
{
    class Program
    {
        const int Port = 50051;

        static void Main(string[] args)
        {
            var server = new Server
            {
                Services = { YourService.BindService(new YourService()) },
                Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
            };
            server.Start();

            Console.WriteLine("Server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();

            server.ShutdownAsync().Wait();
        }
    }
}
```

クライアント側では、同じインターフェースを使用して gRPC サービスに対するリクエストを行います。

この方法では、ProtoBuf ファイルを使用せずにインターフェースを使用して gRPC のサービスを定義し、そのサービスを実装するサービスクラスを作成することができます。

### user — 2024-03-27T02:42:44.796783+00:00

protobufを利用する、.protoファイルは利用しない、interfaceを利用する前提で作成

### assistant — 2024-03-27T02:42:53.416941+00:00

了解しました。ProtoBuf ファイルを使用せずに gRPC のサービスをインターフェースで定義し、そのインターフェースを実装するサーバークラスを作成する方法があります。以下は、その方法に基づいたサンプルコードです。

まず、gRPC のサービスを定義するためのインターフェースを作成します。

```csharp
using System.Threading.Tasks;

namespace YourNamespace
{
    public interface IYourService
    {
        Task<YourResponse> YourMethod(YourRequest request);
    }

    public class YourRequest
    {
        public string Data { get; set; }
    }

    public class YourResponse
    {
        public string Result { get; set; }
    }
}
```

次に、このインターフェースを実装するサービスクラスを作成します。

```csharp
using System.Threading.Tasks;

namespace YourNamespace
{
    public class YourService : IYourService
    {
        public Task<YourResponse> YourMethod(YourRequest request)
        {
            // クライアントからのリクエストを処理
            string result = "Hello, " + request.Data;
            return Task.FromResult(new YourResponse { Result = result });
        }
    }
}
```

最後に、このサービスクラスを gRPC のサービスとして公開します。これには、gRPC のサーバーを作成し、作成したサービスクラスのインスタンスを登録する必要があります。

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

namespace YourNamespace
{
    class Program
    {
        const int Port = 50051;

        static void Main(string[] args)
        {
            var server = new Server
            {
                Services = { YourService.BindService(new YourService()) },
                Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
            };
            server.Start();

            Console.WriteLine("Server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();

            server.ShutdownAsync().Wait();
        }
    }
}
```

クライアント側では、同じインターフェースを使用して gRPC サービスに対するリクエストを行います。

この方法では、ProtoBuf ファイルを使用せずにインターフェースを使用して gRPC のサービスを定義し、そのサービスを実装するサーバークラスを作成することができます。
