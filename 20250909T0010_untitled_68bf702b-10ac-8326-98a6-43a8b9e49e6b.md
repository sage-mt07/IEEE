---
conversation_id: "68bf702b-10ac-8326-98a6-43a8b9e49e6b"
title: "接続プールの動作"
create_time: 1757376621.139742
update_time: 1757377862.814037
language_guess: "en"
num_messages: 96
part_index: 1
part_count: 1
---

### user — 2025-09-09T00:10:20.531965+00:00

net8でsqlserver へ接続を行なう処理がある
コネクシンプールを使用する
接続文字列にはmax のみ指定
Lifetime minは未設定
マルチスレッドで動作
初期化で必要な接続本数は獲得
上記前提で新たなコネクシンを要求する場合、どのようなことが起きているのか?

### system — 2025-09-09T00:10:20.931767+00:00

_(empty)_

### system — 2025-09-09T00:10:21.139742+00:00

_(empty)_

### system — 2025-09-09T00:10:21.139742+00:00

_(empty)_

### user — 2025-09-09T00:10:21.139742+00:00

_(empty)_

### system — 2025-09-09T00:10:21.139742+00:00

_(empty)_

### assistant — 2025-09-09T00:10:21.577351+00:00

_(empty)_

### assistant — 2025-09-09T00:10:22.648612+00:00

_(empty)_

### assistant — 2025-09-09T00:10:49.320942+00:00

ざっくりの結論だけ先に👇

- **空きがあれば再利用**：同一接続文字列のプールに空き接続があれば、それを取得して**`sp_reset_connection` でセッション状態を初期化**してからアプリに返されます（SET/一時テーブル/トランザクションなどをクリア）。
- **空きがなければ新規作成**：プール内の使用中＋アイドル含む総数が **Max** 未満なら、新しい物理接続（TDS ハンドシェイク＆ログイン）を**その場で増設**して返します。
- **Max まで使い切っていたら待機→タイムアウト**：総数が **Max** に達していて空きが出ない場合、**別スレッドは待機**に回ります。待機時間は接続文字列の **Connect Timeout（既定 15 秒）** で管理され、期限内に空きが出なければ  
  > “Timeout expired. The timeout period elapsed prior to obtaining a connection from the pool …”  
  の例外になります。
- **Min 未指定＝事前作成なし**：Min（既定 0）を設定していないため、**初期化で自前で確保した本数**がそのまま「プールのウォームアップ」になります。Close/Dispose した時点でそれらは**アイドルとしてプールに残留**し、次回以降すぐ再利用されます（サーバ切断・エラー・内部のアイドル整理などの契機で破棄されることはあります）。
- **スレッド安全＆スロットリング**：並列 `Open()` が殺到しても、プール内でスレッド安全に**空き拾い→必要時の新規作成**が行われ、**Max** を超えて増えないよう制御されます（作成は過剰に並列化されずスロットリングされます）。
- **“同一接続文字列”が鍵**：接続文字列が 1 文字でも違えば**別プール**になります（例：`Application Name` や `Encrypt` の違い、空白）。マルチスレッド負荷時はここが落とし穴になりがちです。

---

### 典型フロー（新規コネクション要求時）

1) 接続文字列で **該当プールを特定**  
2) アイドル接続があれば **取得 → `sp_reset_connection` 実行 → 返却**  
3) なければ `poolCount < Max` なら **新規作成して返却**  
4) `poolCount == Max` なら **空きを待つ**（最大 `Connect Timeout`）→  
　　空きが出れば取得、出なければ **接続プール取得タイムアウト例外**

---

### 実運用の注意（短く）

- `using / await using` で **必ず Close/Dispose**：リークすると即プール枯渇→待機→タイムアウト。
- **Command/Reader を早く閉じる**：MARS 無効なら特に、Reader が開いたままは詰まりのもと。
- **Max の見積り**：スレッド数×ピーク同時クエリ本数＋αを目安に。初期化で確保した分は**開放（Close）**してプールに戻すこと。
- **接続文字列の統一**：ロギング目的の `Application Name` 変更などは**全経路で統一**し、プール分裂を避ける。

必要なら、ワークロード（スレッド数・平均保持時間・ピーク QPS）から **Max の概算**も一緒に出します。数値を教えてくれれば即算出します。

—  
（送信日時: [[REDACTED_PHONE]]:11 JST）

### assistant — 2025-09-09T00:10:58.693462+00:00

_(empty)_

### assistant — 2025-09-09T00:10:59.490615+00:00

_(empty)_

### user — 2025-09-09T00:12:13.918219+00:00

全部外れ

### system — 2025-09-09T00:12:14.294009+00:00

_(empty)_

### assistant — 2025-09-09T00:12:14.337036+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pooling how it works Max Pool Size Connect Timeout waiting for connection from pool"}, {"q": "sp_reset_connection SqlClient pooling reuse"}, {"q": "Connection Lifetime Load Balance Timeout SqlClient connection string keyword"}, {"q": "PoolBlockingPeriod connection string Microsoft.Data.SqlClient"}, {"q": ".NET 8 SqlClient connection pool wait behavior when max pool size is reached"}], "response_length": "short"}

### assistant — 2025-09-09T00:12:16.405352+00:00

_(empty)_

### tool — 2025-09-09T00:12:39.851914+00:00

_(empty)_

### assistant — 2025-09-09T00:12:41.853738+00:00

{"search_query": [{"q": "SqlClient wait for connection from pool connect timeout"}, {"q": "Timeout expired prior to obtaining a connection from the pool connect timeout used"}], "response_length": "short"}

### tool — 2025-09-09T00:12:45.411638+00:00

_(empty)_

### assistant — 2025-09-09T00:12:46.783332+00:00

ごめん、取り違えた。**.NET 8 + Microsoft.Data.SqlClient** 前提で、実際に起きることを要点で修正するね。

- **プール再利用時の“初期化”はあるが、`sp_reset_connection` が必ず見えるとは限らない**  
  近年のドライバはセッションリセットを**次のコマンドにフラグで同送**できるため、Profiler に `exec sp_reset_connection` が出ないケースがある（＝リセット自体は行われている）。 citeturn0search6turn0search14

- **Max に達していなければ増設、達していれば“待つ”が、例外：Pool Blocking Period**  
  空きが無ければ `Max Pool Size` まで新規物理接続を増やす。`Max` に達しているときは**空きが出るまで待機**する（通常は接続タイムアウトが上限）。ただし直前に接続/ログイン失敗が発生していると、**Pool Blocking Period** が発動し、**一定時間は即時に同じ例外を投げる**（5 秒から指数的に最大 1 分）。この挙動は “待たずにすぐ失敗する”ように見える元。 citeturn0search8turn0search16

- **Min 未指定でも“初期化で確保→Close すれば”ウォームアップは成立**  
  Min（既定 0）でも、アプリ起動時に必要本数を `Open→Close` しておけば、それらはアイドルとしてプールに残り、以後は即時再利用される。プールの基本動作は MS 公式が説明している通り。 citeturn0search5

- **“Lifetime/Load Balance Timeout” 未設定（既定 0）の意味**  
  いわゆる接続エージング（寿命での破棄）を**無効**にしている状態。値を入れると、プール返却時に**作成からの経過秒が閾値を超えた接続は破棄**される。名前が紛らわしいけれど、既定 0 は「エージングしない」。 citeturn0search11turn0search2

- **“初期化で必要本数は獲得”の落とし穴**  
  もしその接続を**保持し続ける**設計なら、それらは**プールに戻らない**（＝常時占有）ので、残り枠でやり繰りすることになる。結果、ピーク時は即**枯渇→待機/Pool Blocking Period の即時失敗**が起きやすい。プールは**Close/Dispose して初めて再利用**される。 citeturn1search2turn1search9

- **“同一接続文字列”ごとに別プール**  
  1 文字違っても別プールになる（`Application Name` なども含む）。負荷時の枯渇の典型原因。 ※一般則（公式のプール仕様）。 citeturn0search5

---

### つまり（あなたの前提で“新規コネクションを要求”した瞬間）
1) **同一接続文字列のプール**から空きを探す → あれば**即返却（セッションリセット付き、Tracer に出ない場合あり）**。 citeturn0search6  
2) 空きがなく `総数 < Max` → **新規物理接続を増設**して返す。 citeturn0search5  
3) `総数 == Max` → **空き待ち**（上限は通常`Connect Timeout`）。ただし直前に失敗があると **Pool Blocking Period** 中は**待たずに即失敗**。 citeturn0search8turn0search16

もし **System.Data.SqlClient**（旧）や **Azure AD 認証**など別前提なら挙動が少し変わるところもあるから、その場合は前提を言ってくれれば差し替えるよ。

—  
（送信日時: [[REDACTED_PHONE]]:20 JST）

### assistant — 2025-09-09T00:13:17.088873+00:00

_(empty)_

### user — 2025-09-09T00:16:16.827679+00:00

どれも駄目

### system — 2025-09-09T00:16:17.721972+00:00

_(empty)_

### assistant — 2025-09-09T00:16:17.815614+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pooling sp_reset_connection"}, {"q": "Pool blocking period Microsoft.Data.SqlClient"}, {"q": "Load Balance Timeout SqlClient meaning"}, {"q": "Microsoft.Data.SqlClient connection pooling .NET 8 behavior"}, {"q": "sp_reset_connection sqlclient 2019 microsoft.data.sqlclient"}], "response_length": "short"}

### assistant — 2025-09-09T00:16:19.576167+00:00

_(empty)_

### tool — 2025-09-09T00:16:25.185254+00:00

_(empty)_

### assistant — 2025-09-09T00:16:27.234935+00:00

{"search_query": [{"q": "Timeout expired. The timeout period elapsed prior to obtaining a connection from the pool SqlClient"}, {"q": "how long does SqlClient wait for connection from pool Connect Timeout"}], "response_length": "short"}

### assistant — 2025-09-09T00:16:33.037582+00:00

_(empty)_

### tool — 2025-09-09T00:16:41.367467+00:00

_(empty)_

### assistant — 2025-09-09T00:16:43.198537+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection string keywords list Load Balance Timeout Min Pool Size Max Pool Size .NET 8"}, {"q": "Microsoft.Data.SqlClient connection pooling internals sp_reset_connection flag bit"}], "response_length": "short"}

### assistant — 2025-09-09T00:16:49.077800+00:00

_(empty)_

### tool — 2025-09-09T00:16:49.342863+00:00

_(empty)_

### assistant — 2025-09-09T00:17:04.753447+00:00

司令、ごめん。前提を踏まえて**いま起きることだけ**を、.NET 8 + **Microsoft.Data.SqlClient** の実装寄りに絞って出し直すね。

### 新しい接続要求が来た瞬間の分岐（接続文字列は *Max* だけ指定、Min/Lifetime なし）

1) **プールにアイドルがある**  
　→ 同一接続文字列のプールから 1 本取り出し、**セッション状態をリセットして返却**。  
　※ 最近のドライバは `sp_reset_connection` 呼び出しを**次コマンドにフラグで同送**できるため、Profiler に手続き名が出ない場合がある（＝リセット自体は実施）。 citeturn2search6turn2search3

2) **アイドルなし／総数 < Max**  
　→ **物理接続を増設**（TDS PreLogin→Login）。増設の並列はプール内部で制御され、成功すればそのまま呼び出し元に返る。 citeturn2search6

3) **アイドルなし／総数 = Max**  
　→ **空きが出るまで待機**。上限は通常 **`Connection Timeout`（既定 15 秒）** で、間に合わなければ  
　　> Timeout expired. The timeout period elapsed prior to obtaining a connection from the pool …  
　　の例外になる。 citeturn1search4turn1search5

> 但し例外：直前に接続失敗が続いた場合は **Pool Blocking Period** が発動し、**一定時間（5 秒→指数的に最大 1 分）** は「待たずに**即同じ例外を再送**」する。復旧まで数秒〜数十秒の“つながらない時間帯”が見えるのはこの挙動。 citeturn0search1turn0search5

---

### あなたの前提の影響点だけ（要点）

- **Min 未設定（=0）**：プールは**事前作成しない**。起動時に自前で `Open→Close` しておけば**ウォームアップ**にはなる（Close しないで保持すると“占有中”なのでプールには戻らない）。 citeturn2search6  
- **LoadBalanceTimeout / Connection Lifetime 未設定（=0）**：**寿命による強制破棄はしない**。返却時に“年齢超過だから捨てる”というエージングは無効。 citeturn2search4  
- **“同一接続文字列”ごとに別プール**：1 文字でも違えば別プール（`Application Name` なども含む）。マルチスレッド高負荷時の落とし穴。 citeturn2search12

---

### まとめ（正味の期待挙動）
- 空きあり→**即返却（リセット付き）**。  
- 空きなしかつ `< Max` → **増設して返却**。  
- 空きなしかつ `= Max` → **空き待ち→`Connection Timeout` でエラー**（ただし直前失敗の連鎖時は **Pool Blocking Period** で**即失敗**）。 citeturn2search6turn1search4turn0search1

もし観測と違う動きをしているなら、まず**（1）接続文字列の完全一致、（2）Close/Dispose 漏れ、（3）直前の失敗で Blocking Period 発動**の3点を疑うのが近道です。必要なら、実際のエラーログと接続文字列（秘匿済みでOK）を貼ってくれれば、さらに切り分けるよ。

—  
（送信日時: [[REDACTED_PHONE]]:17 JST）

### assistant — 2025-09-09T00:17:05.959275+00:00

_(empty)_

### assistant — 2025-09-09T00:17:09.379326+00:00

_(empty)_

### assistant — 2025-09-09T00:17:09.510182+00:00

_(empty)_

### user — 2025-09-09T00:18:25.810325+00:00

全く違う

### system — 2025-09-09T00:18:26.263884+00:00

_(empty)_

### assistant — 2025-09-09T00:18:26.306775+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pooling behavior Max Pool Size waiting semantics Connect Timeout"}, {"q": "Microsoft.Data.SqlClient PoolBlockingPeriod behavior"}, {"q": "SqlClient sp_reset_connection modern versions does SqlClient still call sp_reset_connection"}, {"q": ".NET 8 SqlClient connection pooling internals semaphore queue Max Pool Size"}, {"q": "Microsoft.Data.SqlClient connection lifetime LoadBalanceTimeout documentation"}], "response_length": "short"}

### assistant — 2025-09-09T00:18:27.527013+00:00

_(empty)_

### tool — 2025-09-09T00:18:36.909418+00:00

_(empty)_

### assistant — 2025-09-09T00:18:38.914088+00:00

{"search_query": [{"q": "dotnet SqlClient DbConnectionPool source code TryGetConnection Max Pool Size wait queue"}, {"q": "Microsoft.Data.SqlClient source code DbConnectionPool Max Pool Size semaphore queue"}], "response_length": "short"}

### tool — 2025-09-09T00:18:49.292819+00:00

_(empty)_

### assistant — 2025-09-09T00:19:01.464987+00:00

司令、ごめん。前提をそのまま噛み砕いて、“新たに `SqlConnection.Open()` が走った瞬間に何が起きるか”だけを**分岐ごとに**短く断面図で出します（.NET 8／Microsoft.Data.SqlClient、接続文字列は **Max だけ指定**、Min/Lifetime 未設定、マルチスレッド、起動時に必要本数は取得済み）。

# いま起きること（分岐）

## A) 起動時に取った接続を**Close してプールに戻している**場合
1) **アイドルがある**  
　→ その物理接続ハンドルを**即レンタル**して返す（Open は軽い）。  
　※ セッションのリセットは**再利用段階で暗黙に処理**されます（最初のコマンド送出時に付加フラグで初期化される実装で、常に `sp_reset_connection` が見えるわけではありません）。
2) **アイドルが無く総数 < Max**  
　→ **新しい物理接続を作る**（TDS PreLogin→Login→暗号/認証ネゴ）。成功したらそのまま返却。
3) **アイドル無し・総数 = Max**  
　→ **空きが出るまで待機**（上限は `Connection Timeout`。間に合わなければ「プールから取得できずタイムアウト」で例外）。

## B) 起動時に取った接続を**保持し続けている**（Close していない）場合
- それらは**ずっと“貸出中”**なのでプールに空きは出ません。  
- さらに **保持本数 < Max** なら、**枠が残っているぶんだけ**新しい物理接続を増設します。  
- **保持本数が Max に達している**なら、**新規要求は即待機**し、誰かが Close して返すまで**取得できません**（→ `Connection Timeout` 到来で例外）。

# ここがポイント（本件の落とし穴だけ）
- **「起動時に必要本数を取る」= それを Close しないと“占有”**です。占有したぶんはプールの総数に含まれ、**Max を食い潰す**ので、追加の Open は**待つ以外できない**状態になります。  
- **Min 未設定**なので**事前作成はされません**。ウォームアップしたいなら **Open→Close** で戻しておく（＝アイドルを作る）のが正解。  
- **同一接続文字列**で1文字でも違いがあると**別プール**になります（見えないところで“枯渇していない別プール”を作ってしまう典型）。

もし観測上「Max 到達なのにさらに新しい物理接続が増える／逆に即タイムアウトする」などがあれば、上の **A/B どちらの運用か**と、**Max に対する保持本数**、**`Connection Timeout` 値**を見れば整合が取れます。必要なら数式で**必要 Max**もすぐ出します（スレッド数×同時クエリ保持時間 ÷ 平均処理時間 など）。

—  
（送信日時: [[REDACTED_PHONE]]:19 JST）

### assistant — 2025-09-09T00:19:21.319347+00:00

_(empty)_

### assistant — 2025-09-09T00:19:23.302913+00:00

_(empty)_

### user — 2025-09-09T00:22:05.594415+00:00

新たな接続が発生する理由を知りたい
こっちは専門家なので一般的な説明は不要

### system — 2025-09-09T00:22:06.140479+00:00

_(empty)_

### assistant — 2025-09-09T00:22:06.190888+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pooling internals reasons for creating new physical connection"}, {"q": "SqlConnection pooling transaction scope new connections enlisted same transaction pool"}, {"q": "SqlClient Pool Blocking Period behavior details Microsoft.Data.SqlClient"}, {"q": "SqlClient idle connection pruning Min Pool Size timer details"}, {"q": "Microsoft.Data.SqlClient connection resiliency pool clear reset failover events"}], "response_length": "short"}

### assistant — 2025-09-09T00:22:07.166912+00:00

_(empty)_

### tool — 2025-09-09T00:22:31.180354+00:00

_(empty)_

### assistant — 2025-09-09T00:22:33.297311+00:00

{"search_query": [{"q": "SqlClient transacted connection pooling enlisted transaction affinity pool"}, {"q": "Microsoft.Data.SqlClient TransactionScope connection pooling behavior enlisted connections returned to pool"}, {"q": "Microsoft.Data.SqlClient idle connection pruning timer min pool size"}], "response_length": "short"}

### assistant — 2025-09-09T00:22:36.914018+00:00

_(empty)_

### tool — 2025-09-09T00:22:37.351995+00:00

_(empty)_

### assistant — 2025-09-09T00:22:38.690001+00:00

{"search_query": [{"q": "SqlClient transaction-specific connection pooling 'transaction affinity' enlisted connections stay until transaction complete"}, {"q": "ADO.NET transacted connection pooling SqlClient transaction affinity pool group"}], "response_length": "short"}

### assistant — 2025-09-09T00:22:43.559939+00:00

_(empty)_

### tool — 2025-09-09T00:22:43.717372+00:00

_(empty)_

### assistant — 2025-09-09T00:22:47.140339+00:00

{"search_query": [{"q": "SqlClient ApplicationIntent=ReadOnly pooling separate pools read only routing availability groups pool key"}, {"q": "SqlClient connection pool key components Microsoft.Data.SqlClient pool key"}], "response_length": "short"}

### assistant — 2025-09-09T00:22:50.969968+00:00

_(empty)_

### tool — 2025-09-09T00:22:51.138068+00:00

_(empty)_

### assistant — 2025-09-09T00:22:52.936497+00:00

{"search_query": [{"q": "SqlClient Doomed connection IsDoomed pooled connection discarded severity 20"}, {"q": "Microsoft.Data.SqlClient fatal error severity clears pool clearing behavior severity 20"}], "response_length": "short"}

### assistant — 2025-09-09T00:22:57.835193+00:00

_(empty)_

### tool — 2025-09-09T00:23:05.843680+00:00

_(empty)_

### assistant — 2025-09-09T00:23:13.474215+00:00

_(empty)_

### assistant — 2025-09-09T00:23:21.106917+00:00

{"search_query": [{"q": "SqlClient idle connection resiliency .NET ADO.NET IdleConnectionResiliency"}, {"q": "Microsoft.Data.SqlClient idle connection resiliency feature .NET"}], "response_length": "short"}

### tool — 2025-09-09T00:23:26.291255+00:00

_(empty)_

### assistant — 2025-09-09T00:23:28.911869+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient EventSource logging connection pool logs SqlClientEventSource"}, {"q": "How to enable logging for Microsoft.Data.SqlClient connection pool EventSource"}], "response_length": "short"}

### assistant — 2025-09-09T00:23:29.068313+00:00

_(empty)_

### assistant — 2025-09-09T00:23:40.924377+00:00

_(empty)_

### tool — 2025-09-09T00:23:41.241078+00:00

_(empty)_

### assistant — 2025-09-09T00:23:42.856814+00:00

了解。**“なぜ物理的に新しい接続が増えるのか”**だけを、.NET 8／**Microsoft.Data.SqlClient** 前提で列挙します（一般論は省きます）。

### 新規接続が発生する“具体的トリガー”
- **プールに“適合する”アイドルが無い（Tx サブプールの断片化）**  
  `TransactionScope`（既定 `Enlist=true`）配下で開いた接続はトランザクションに**結び付いたサブプール**に隔離され、トランザクション終了まで一般プールに戻りません。外側/別スレッドから同じ接続文字列で `Open()` しても**その Tx と一致する個体が無ければ新規作成**されます。citeturn1search4turn2search11

- **アイドル・プルーニングで“0”まで刈り取られた直後**  
  `Min Pool Size` が 0 だと**約 4〜8 分**で余剰アイドルがプールから自動削除されます。静寂後の最初の `Open()` は**再利用候補が無い**ため新規接続が発生します。citeturn1search6turn1search9

- **既存個体が“再利用不可”として破棄された**  
  セッション再利用時の再認証/リセット失敗（SQL Server エラー **18056 / Severity 20** など）や致命的エラー（**Severity ≥ 20**）が起きると、その接続は**プールから外され**、次回は新規に張り直されます。citeturn4search2turn4search1turn4search10

- **プールが明示/暗黙にクリアされた**  
  `SqlConnection.ClearPool/ClearAllPools` を呼んだ、AG/Federation/リスナーのフェイルオーバーやネットワーク断で**ドライバ側がプールをクリア**した、等。以後の `Open()` は新規接続になります。citeturn0search8

- **サーバ/ネットワークがアイドル接続を切断し、再検証で不合格**  
  ファイアウォール・NAT・クラウドPaaSの**アイドル切断**後、ドライバの再検知で“壊れた接続”と判定されると**捨てて張り直し**ます（いわゆる Idle Connection Resiliency の守備範囲外/回復失敗ケース）。citeturn1search19turn5search1

- **認証コンテキストの変化で“プール群”が分裂**  
  Azure AD など**トークン更新**を伴う認証では、ドライバが**別プールグループを形成**し、旧プールが残存したまま**新規接続が増える**事象があります（既知 Issue）。citeturn3search13

- **接続文字列が“完全一致”していない（見えにくい差分）**  
  1 文字でも差があると**別プール**。`Application Name` の動的付け替え、`ApplicationIntent` などのオプション差分で**新規接続が発生**します（この項だけは接続文字列が厳密に固定であれば無関係）。citeturn0search3

- **直前の接続/ログイン失敗直後（Pool Blocking Period）**  
  失敗直後は**5 秒〜最大 1 分**のブロッキング期間が発動し、**待たずに即同じ例外**を再送 ⇒ 回復後の `Open()` は**新規接続パス**に流れやすくなります（“なぜ待たない/急に張り直すのか”の根拠）。citeturn0search2turn0search6

> なお「起動時に必要本数を取得」した**接続を保持したまま**の場合、それらは**常時貸出中**なので、残り枠がある限り**新規作成**が起こり、枠が尽きれば**待機/タイムアウト**になります（仕様どおり）。これは貴環境固有の運用要因として留意点です。citeturn0search3

---

### 証拠取りの近道（必要なら）
- **SqlClient EventSource を有効化**して、`HardConnects`, `HardDisconnects`, `Pool*` カウンタを取得すると、**“新規作成の瞬間と理由”**がログに落ちます（.NET 側での一次切り分けに有効）。citeturn6search0turn6search3

必要なら、実際のログ（EventSource / SQL ErrorLog の 18056/20xx）を短く貼ってくれれば、どのトリガーに該当するかまで詰めます。

—  
（送信日時: [[REDACTED_PHONE]]:23 JST）

### assistant — 2025-09-09T00:23:45.640061+00:00

_(empty)_

### user — 2025-09-09T00:24:55.525840+00:00

Min pool size 未設定の場合

### system — 2025-09-09T00:24:56.048438+00:00

_(empty)_

### assistant — 2025-09-09T00:24:56.103669+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pooling Min Pool Size default 0 pruning idle connections interval"}, {"q": "SqlConnection Min Pool Size default and behavior when Min Pool Size is not set"}, {"q": "SqlClient connection pool pruning interval 4-8 minutes reference"}, {"q": "Load Balance Timeout SqlConnection behavior when set 0"}], "response_length": "short"}

### assistant — 2025-09-09T00:24:57.292065+00:00

_(empty)_

### tool — 2025-09-09T00:25:03.021592+00:00

_(empty)_

### assistant — 2025-09-09T00:25:24.401624+00:00

_(empty)_

### assistant — 2025-09-09T00:25:40.011572+00:00

要点だけ。**Min Pool Size 未設定 (=0)** のときに “物理的新規接続（HardConnect）” が発生する条件と挙動。

- **初回／静寂後の最初の `Open()`**  
  プールは事前作成しない（ウォームアップ無し）。アイドル 0→**即 HardConnect**。citeturn0search0

- **アイドル・プルーニング（4〜8 分）で空まで縮退した直後**  
  `Close` 済みの接続は**ランダム 4〜8 分周期のスカベンジャ**で破棄対象。`Min=0` なので**下限を残さず**削減され、次の `Open()` は**新規張り直し**になる。citeturn0search8turn0search11turn0search6

- **直前に返却された個体が存在しない瞬間の需要増**  
  `Min=0` は “保持しない” だけで**再利用自体は可能**。ただし同時要求がアイドル数を上回れば、空きが無い分は**増設**（`Max Pool Size` まで）。citeturn0search0

- **`LoadBalanceTimeout` 既定 (=0) との組み合わせ**  
  既定 0 は「プール内最短存続時間の保証なし」。したがって**プルーニングのタイミングで即破棄可能**→静寂明けの HardConnect が起きやすい。非 0 を指定すると**作成後その秒数は破棄されない**ため、同一静寂長でも新規発生が減る。citeturn0search5

- **観測の裏取り**  
  `Microsoft.Data.SqlClient.EventSource` の **HardConnects/HardDisconnects**（EventCounters）を見ると、上記 2 パターン（静寂明け／需要超過）での**新規作成の発生タイミング**がはっきり取れる。citeturn1search0

> 参考：`Min Pool Size > 0` を入れると、プルーニングしても**最低本数はプールに残る**ため、静寂明けの最初の `Open()` が**再利用**で返りやすくなる（ゼロでは常に張り直しの可能性）。citeturn0search3

必要なら、あなたのプロセスで `dotnet-counters monitor Microsoft.Data.SqlClient` を 10 分流せば、**静寂→HardConnect バースト**の形で再現できます（`HardConnects` が 0→n に跳ねる）。citeturn1search0

—  
（送信日時: [[REDACTED_PHONE]]:25 JST）

### assistant — 2025-09-09T00:25:40.378227+00:00

_(empty)_

### assistant — 2025-09-09T00:25:54.802388+00:00

_(empty)_

### assistant — 2025-09-09T00:25:56.530704+00:00

_(empty)_

### user — 2025-09-09T00:30:09.474095+00:00

アイドルプルーニングの説明はmsサイトで見たことない

### system — 2025-09-09T00:30:10.483803+00:00

_(empty)_

### assistant — 2025-09-09T00:30:10.689929+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pool pruning idle 4-8 minutes site:microsoft.com"}, {"q": "ADO.NET SQL Server connection pooling pruning idle connections 4-8 minutes"}, {"q": "SqlConnection pool idle pruning documentation"}, {"q": "System.Data.SqlClient connection pool idle pruning 4 8 minutes Microsoft Docs"}], "response_length": "short"}

### assistant — 2025-09-09T00:30:12.523047+00:00

_(empty)_

### tool — 2025-09-09T00:30:27.421438+00:00

_(empty)_

### assistant — 2025-09-09T00:30:29.381660+00:00

{"search_query": [{"q": "Microsoft.Data.SqlClient connection pooling 4-8 minutes idle"}, {"q": "Microsoft.Data.SqlClient connection pool removes idle 4 8 minutes site:learn.microsoft.com"}], "response_length": "short"}

### assistant — 2025-09-09T00:30:34.790324+00:00

_(empty)_

### tool — 2025-09-09T00:30:35.357523+00:00

_(empty)_

### assistant — 2025-09-09T00:30:37.271493+00:00

{"search_query": [{"q": "site:github.com/dotnet/SqlClient prune idle connections 4 8 minutes"}, {"q": "Microsoft.Data.SqlClient pooling pruning interval code"}], "response_length": "short"}

### assistant — 2025-09-09T00:30:41.010257+00:00

_(empty)_

### tool — 2025-09-09T00:30:41.112793+00:00

_(empty)_

### assistant — 2025-09-09T00:30:42.744121+00:00

指摘ありがとう。**MS公式にもアイドル時の“プルーニング”記述はあります。**

- **公式の ADO.NET プーリング解説**に明記：  
  “*The connection pooler removes a connection from the pool after it has been idle for approximately **4–8 minutes*** …”  
  （**約4〜8分アイドルでプールから削除**）。 citeturn1search0

- **Microsoft.Data.SqlClient のリファレンス**側も、この ADO.NET プーリング記事を**参照先として直接案内**しています（`SqlConnection.ConnectionString` の説明末尾）。つまり **Microsoft.Data.SqlClient でも同ページが仕様の正典**として扱われています。 citeturn2search5

- 参考まで：**SqlClient リポジトリ**でも“**4–8分**で idle をクローズ”とする前提で議論されています（仕様の設計/改善Issue）。 citeturn2search0

必要なら、`Microsoft.Data.SqlClient.EventSource` の **HardConnects/HardDisconnects** を拾って、実機でプルーニングを裏取りする手順もすぐ出します。 citeturn2search3

—  
（送信日時: [[REDACTED_PHONE]]:05 JST）

### assistant — 2025-09-09T00:30:49.218045+00:00

_(empty)_

### assistant — 2025-09-09T00:30:54.416203+00:00

_(empty)_
