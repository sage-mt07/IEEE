---
conversation_id: "68c27c8d-0a3c-832d-961e-9139e6a035e8"
title: "SQL Server 2022 メモリ対策"
create_time: 1757576396.144572
update_time: 1757576595.050298
language_guess: "en"
num_messages: 18
part_index: 1
part_count: 1
---

### user — 2025-09-11T07:39:55.901808+00:00

Sqlserver memory grants pendingのcpu使用率が100%近い

### system — 2025-09-11T07:39:56.144572+00:00

_(empty)_

### system — 2025-09-11T07:39:56.144572+00:00

_(empty)_

### user — 2025-09-11T07:39:56.144572+00:00

_(empty)_

### system — 2025-09-11T07:39:56.144572+00:00

_(empty)_

### system — 2025-09-11T07:39:57.089303+00:00

_(empty)_

### system — 2025-09-11T07:39:57.097564+00:00

_(empty)_

### assistant — 2025-09-11T07:39:57.119237+00:00

_(empty)_

### assistant — 2025-09-11T07:39:58.240665+00:00

_(empty)_

### assistant — 2025-09-11T07:40:13.021270+00:00

やあ司令、状況わかった。**`Memory Grants Pending` が出ていて CPU がほぼ100%**は、並行したクエリが「ソート/ハッシュ用メモリ（workspace memory）」を取り合って詰まっている典型パターン。まずは“止血→特定→恒久対策”の順でいこう。

# まずは止血（安全に即効性）
1) **並列度を一時的に絞る**（コンテキスト切替と過剰並列を抑える）
```sql
-- サーバ全体（即時反映・リスク低）: 物理コア数に応じて暫定値
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'max degree of parallelism', 4; RECONFIGURE;  -- 例
```
2) **クエリ同時実行の上限を下げる**（Grant待ち行列を短く）
- アプリ側の接続プール/並列バッチを一段下げる  
- 可能なら重いバッチを順番実行に切替

3) **`max server memory` の見直し**  
OS/他プロセスに余裕を残しつつ、SQL Server のバッファが過小なら引き上げ。過小だと Grant プールも窮屈になる。

---

# 何が詰まってるか即診断
```sql
-- 1) 今、誰がメモリ待ち/どれだけ要求しているか
SELECT
  mg.session_id, mg.request_time, mg.dop, mg.requested_memory_kb, mg.granted_memory_kb,
  mg.required_memory_kb, mg.max_used_memory_kb, mg.is_next_candidate,
  r.status, r.cpu_time, r.wait_type, r.blocking_session_id,
  DB_NAME(r.database_id) AS dbname,
  SUBSTRING(t.text, (r.statement_start_offset/2)+1,
            CASE r.statement_end_offset WHEN -1 THEN LEN(t.text)
                 ELSE (r.statement_end_offset - r.statement_start_offset)/2 + 1 END) AS stmt
FROM sys.dm_exec_query_memory_grants AS mg
JOIN sys.dm_exec_requests AS r ON mg.session_id = r.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
ORDER BY mg.request_time;

-- 2) 全体の待機状況（RESOURCE_SEMAPHORE が多い？ / SOS_SCHEDULER_YIELD でCPU飽和？）
SELECT TOP 20 wait_type, waiting_tasks_count, wait_time_ms
FROM sys.dm_os_wait_stats
ORDER BY wait_time_ms DESC;

-- 3) 大きな Grant を出しているクエリの傾向
SELECT TOP 20
  qs.total_worker_time/qs.execution_count AS avg_cpu,
  qs.max_grant_kb, qs.max_used_grant_kb, qs.execution_count,
  DB_NAME(st.dbid) AS dbname,
  SUBSTRING(st.text, 1, 4000) AS sample_sql
FROM sys.dm_exec_query_stats AS qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
ORDER BY qs.max_grant_kb DESC;
```

見どころ：
- `RESOURCE_SEMAPHORE` が目立つ → **Grant待ち渋滞**確定
- `max_grant_kb` が異常に大きいSQL → **過剰見積もり**（統計/推定行数/スキュー）や**巨大ソート/ハッシュ**
- `SOS_SCHEDULER_YIELD` が多い → **CPU競合**（過並列/オペレーターCPU重い）

---

# 根本原因と対処の打ち手
**A. 統計・推定が外れて過大Grant**
- 直近で重い対象テーブルに **`UPDATE STATISTICS ... WITH FULLSCAN`**（まずは犯人テーブルだけ）
- **適切なインデックス**でソート/ハッシュを回避（`ORDER BY`/`GROUP BY`/`JOIN` キーに合わせる）
- クエリに **`OPTION (RECOMPILE)`** を付け、実行時推定を取得（バッチ一撃なら有効）
- SQL 2019+ なら **Row Mode Memory Grant Feedback** が自動で矯正（DBの互換性レベルと自動調整が有効か確認）

**B. 1本あたりの Grant が巨大**
- SQL 2019+：クエリヒント **`MIN_GRANT_PERCENT` / `MAX_GRANT_PERCENT`** で上限/下限を絞る（該当SQLだけに適用）
- 設計側で **ストリーミング化**（`TOP`＋`ORDER BY`の工夫、段階集約、不要な`SORT/HASH`削減）

**C. 同時に重いクエリが走りすぎ**
- バッチの**スロットリング**（実行キュー導入）
- **Resource Governor** でクラス分け（重いレポート系の並行数/メモリ割合を制限）

**D. 過剰並列でCPU飽和 & Grant競合を悪化**
- サーバ既定の **`MAXDOP`最適化**（NUMA/コア数に合わせる）
- 問題SQLだけ **`OPTION (MAXDOP 1|2|4)`** で抑制

**E. TempDB/ディスクがボトルネックでスピル多発**
- **TempDBの複数データファイル**・十分なIO
- 実行計画で **`Hash/SORT spills to tempdb`** の警告確認 → メモリ不足 or オペレーター設計見直し

---

# すぐ試せる“犯人あぶり出し”テンプレ
1) 上の DMV 3本で「Grant大」かつ「実行中/頻発」のSQLを特定  
2) そのSQLの**実行計画**を取得して警告（spills/過大Grant/行数誤推定）を見る  
3) 対象テーブルの統計更新 → 再実行  
4) まだ過大なら、**ヒント（MAXDOP/（MIN|MAX）_GRANT_PERCENT/RECOMPILE）** で応急処置  
5) 恒久策として **インデックス/書き換え/バッチ分割/スケジューリング** を設計反映

---

必要なら、該当 DMV の結果（上位10件）を貼ってくれれば、**その場で実行計画の着眼点と具体的な書き換え案**まで落とし込むよ。

——  
送信日時（日本時間）: [[REDACTED_PHONE]]:40:13

### assistant — 2025-09-11T07:40:15.520358+00:00

_(empty)_

### user — 2025-09-11T07:42:27.448271+00:00

Sqlserver 2022

### system — 2025-09-11T07:42:28.670481+00:00

_(empty)_

### system — 2025-09-11T07:42:28.727735+00:00

_(empty)_

### assistant — 2025-09-11T07:42:29.086013+00:00

_(empty)_

### assistant — 2025-09-11T07:42:50.173493+00:00

やあ司令。**SQL Server 2022 前提**で、`Memory Grants Pending`×高CPUに効く“2022ならでは”の打ち手だけをギュッとまとめるね。

# 即効ワークアラウンド（コード触らず）
- **Query Store ヒントで犯人SQLだけ抑える**  
  ・`MAXDOP` を 2～4 に制限（過並列抑制）  
  ・必要に応じて **`MAX_GRANT_PERCENT` / `MIN_GRANT_PERCENT`** を指定（過大/過小Grantの矯正）  
  ※アプリ改修なしで適用できるのが 2022 の強み。  
- **実行時再コンパイルで推定精度UP**  
  一発物の重いSQLには `OPTION (RECOMPILE)`（パラメータ別にGrant見積りを最適化）。

# 2022の “IQP vNext” を活かす（有効化チェック）
- **互換性レベル = 160（SQL 2022）** を確認。これで  
  - **Parameter Sensitive Plan (PSP)**：パラメータ偏りでの“過大Grant”を自動で分岐最適化  
  - **Degree of Parallelism (DOP) Feedback**：過剰/過小並列を学習して自動調整  
  - **CE（Cardinality Estimation） Feedback**：行数推定ズレを学習補正  
  が効く。  
- **Memory Grant Feedback（行/バッチ両方）** が有効か確認。過大Grant→縮小、過小→拡張を学習。

> 互換性レベル160＋Query Store有効が前提。新規DBは既定でQSオンだが、既存DBは要確認。

# “CPU100%＋Grant待ち”を2022流で特定する
```sql
-- 今まさにメモリ待ちの実行中クエリを特定
SELECT mg.session_id, mg.requested_memory_kb, mg.granted_memory_kb,
       mg.required_memory_kb, mg.dop, r.status, r.wait_type, r.cpu_time,
       DB_NAME(r.database_id) AS dbname,
       SUBSTRING(t.text, (r.statement_start_offset/2)+1,
                 CASE r.statement_end_offset WHEN -1 THEN LEN(t.text)
                 ELSE (r.statement_end_offset - r.statement_start_offset)/2 + 1 END) AS stmt
FROM sys.dm_exec_query_memory_grants AS mg
JOIN sys.dm_exec_requests AS r ON mg.session_id = r.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
ORDER BY mg.request_time;

-- 待機の輪郭（RESOURCE_SEMAPHORE 多発ならGrant渋滞）
SELECT TOP (20) wait_type, waiting_tasks_count, wait_time_ms
FROM sys.dm_os_wait_stats
ORDER BY wait_time_ms DESC;

-- Query Store で “Grant大＆頻出” を洗い出し（要: Query Store 有効）
SELECT TOP (20)
    qsq.query_id, qsq.plan_id, rs.avg_cpu_time, rs.avg_duration,
    rs.avg_query_max_used_memory, rs.last_execution_time
FROM sys.query_store_plan AS qsp
JOIN sys.query_store_query AS qsq ON qsp.query_id = qsq.query_id
JOIN sys.query_store_runtime_stats AS rs ON qsp.plan_id = rs.plan_id
ORDER BY rs.avg_query_max_used_memory DESC;
```

# 対策パス（優先度順）
1) **犯人SQLに QSヒント**  
   - まず `MAXDOP = 2～4`、次いで `MAX_GRANT_PERCENT`（例: 5～15%）で天井を作る  
   - スピルが出るようなら `MIN_GRANT_PERCENT` を微調整  
   - “夜間レポート/集計”系なら同時実行数をアプリ側でスロットリング
2) **PSP が刺さるパラメータ偏り**  
   - 互換レベル160にしてPSPを効かせる  
   - それでも不安定なら “高/低選択性”を分岐する **手動ヒント or ビュー分割**
3) **推定ズレ源を潰す**  
   - 問題テーブルの **統計を粒度高く更新**（必要なら `FULLSCAN`）  
   - **適切なインデックス**で `SORT/HASH` を減らし、Grant自体を小さくする  
   - 2022なら **Batch Mode on Rowstore**（集計系のCPU/メモリ効率が劇的に改善）
4) **サーバ側の土台調整**  
   - `MAXDOP`（既定値見直し）＋ **`max server memory`** の適正化  
   - **TempDB** 複数データファイル/十分なIOでスピルのダメージを最小化  
   - **Resource Governor** で重いワークロードの並行数とメモリ配分を制御

# 具体アクション（安全コマンド例）
```sql
-- 互換性レベル（=160でIQP強化が有効）
SELECT name, compatibility_level FROM sys.databases;

-- Query Store（既存DBで未有効なら）
ALTER DATABASE YourDB SET QUERY_STORE = ON;

-- Batch Mode on Rowstore（DBスコープで有効化も可）
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = ON;

-- （必要なら）行モードの Memory Grant Feedback を明示ON
ALTER DATABASE SCOPED CONFIGURATION SET ROW_MODE_MEMORY_GRANT_FEEDBACK = ON;

-- 犯人クエリに Query Store ヒント（例：MAXDOP 2）
-- ※実際は該当 query_id/plan_id を特定して適用
EXEC sys.sp_query_store_set_hints @query_id = 12345,
     @value = N'OPTION(MAXDOP 2)';
```

---

**このあと**：直近の DMV/Query Store の上位結果（TOP 10）を貼って。  
司令の現場SQLに合わせて、**QSヒントの具体値（MAXDOP / MIN・MAX_GRANT_PERCENT）と、インデックス or 書き換え案**まで踏み込んで提案するよ。

——  
送信日時（日本時間）: [[REDACTED_PHONE]]:42:50

### assistant — 2025-09-11T07:42:50.710354+00:00

_(empty)_
