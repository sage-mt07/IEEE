---
conversation_id: "07f61922-b565-4032-a119-45fd1752e508"
title: "Code-First gRPC Implementation"
create_time: 1721803359.726466
update_time: 1721898435.96738
language_guess: "en"
num_messages: 14
part_index: 1
part_count: 1
---

### system — 2024-07-24T06:42:39.726466+00:00

_(empty)_

### user — 2024-07-24T06:42:39.731587+00:00

WebAPIをホストするサービスとWebAPIからの要求を処理するサービスを作成する
サービス間はGRPCで通信をおこなう
.net8で作る
GRPCはcodefirstで作る
proto-bufを利用する

### assistant — 2024-07-24T06:42:49.892777+00:00

以下は、.NET 8でWebAPIサービスとWebAPIからの要求を処理するバックエンドサービスを作成し、gRPCを使用してこれらのサービス間の通信を行う手順です。gRPCはcode-firstアプローチで設定し、protobufを使用します。

### 1. プロジェクトの作成

まず、.NET CLIを使用してプロジェクトを作成します。

```bash
dotnet new webapi -n WebAPIService
dotnet new console -n BackendService
dotnet new classlib -n SharedLib
```

### 2. 共通のプロトコル定義（SharedLib）

SharedLibプロジェクトにgRPCサービスのプロトコル定義を追加します。

**SharedLib/Protos/service.proto**

```proto
syntax = "proto3";

option csharp_namespace = "SharedLib.Protos";

service MyService {
  rpc GetResponse (Request) returns (Response);
}

message Request {
  string message = 1;
}

message Response {
  string result = 1;
}
```

**SharedLib/SharedLib.csproj**

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <Protobuf Include="Protos\service.proto" GrpcServices="Both" />
  </ItemGroup>

</Project>
```

### 3

### assistant — 2024-07-24T06:42:53.823530+00:00

_(empty)_

### user — 2024-07-24T06:43:12.268185+00:00

codefirstのため、.protoファイルは使用しない

### assistant — 2024-07-24T06:43:48.000221+00:00

了解しました。code-firstアプローチを使用して、.protoファイルを使用せずにgRPCサービスを設定します。

### 1. プロジェクトの作成

まず、.NET CLIを使用してプロジェクトを作成します。

```bash
dotnet new webapi -n WebAPIService
dotnet new console -n BackendService
dotnet new classlib -n SharedLib
```

### 2. 共通のプロジェクト（SharedLib）

SharedLibプロジェクトに共通のメッセージとサービスインターフェースを定義します。

**SharedLib/Messages.cs**

```csharp
namespace SharedLib;

public class Request
{
    public string Message { get; set; }
}

public class Response
{
    public string Result { get; set; }
}
```

**SharedLib/IMyService.cs**

```csharp
using System.Threading.Tasks;

namespace SharedLib;

public interface IMyService
{
    Task<Response> GetResponse(Request request);
}
```

### 3. バックエンドサービスの実装（BackendService）

バックエンドサービスでgRPCサービスを実装します。

**BackendService/Program.cs**

```csharp
using System.Threading.Tasks;
using Grpc.Core;
using Grpc.Net.Client;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using SharedLib;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((context, services) =>
    {
        services.AddGrpc();
        services.AddSingleton<IMyService, MyService>();
    })
    .Build();

await host.RunAsync();

public class MyService : IMyService
{
    public Task<Response> GetResponse(Request request)
    {
        return Task.FromResult(new Response { Result = $"Hello, {request.Message}" });
    }
}

public class MyGrpcService : MyService.MyServiceBase
{
    private readonly IMyService _myService;

    public MyGrpcService(IMyService myService)
    {
        _myService = myService;
    }

    public override async Task<Response> GetResponse(Request request, ServerCallContext context)
    {
        return await _myService.GetResponse(request);
    }
}
```

**BackendService/BackendService.csproj**

```xml
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" Version="2.44.0" />
    <PackageReference Include="Grpc.Net.Client" Version="2.44.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\SharedLib\SharedLib.csproj" />
  </ItemGroup>

</Project>
```

### 4. WebAPIサービスの実装（WebAPIService）

WebAPIサービスでgRPCクライアントを使用してバックエンドサービスに要求を送信します。

**WebAPIService/Controllers/MyController.cs**

```csharp
using Microsoft.AspNetCore.Mvc;
using Grpc.Net.Client;
using SharedLib;

namespace WebAPIService.Controllers;

[ApiController]
[Route("[controller]")]
public class MyController : ControllerBase
{
    private readonly IMyService _myService;

    public MyController(IMyService myService)
    {
        _myService = myService;
    }

    [HttpGet]
    public async Task<IActionResult> Get(string message)
    {
        var request = new Request { Message = message };
        var response = await _myService.GetResponse(request);
        return Ok(response);
    }
}
```

**WebAPIService/Program.cs**

```csharp
using Grpc.Net.Client;
using SharedLib;
using Microsoft.Extensions.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddGrpcClient<IMyService>(options =>
{
    options.Address = new Uri("https://localhost:5001");
});
builder.Services.AddScoped<IMyService, MyServiceClient>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();

public class MyServiceClient : IMyService
{
    private readonly IMyService.MyServiceClient _client;

    public MyServiceClient(IMyService.MyServiceClient client)
    {
        _client = client;
    }

    public async Task<Response> GetResponse(Request request)
    {
        var grpcRequest = new SharedLib.Request { Message = request.Message };
        var grpcResponse = await _client.GetResponseAsync(grpcRequest);
        return new Response { Result = grpcResponse.Result };
    }
}
```

**WebAPIService/WebAPIService.csproj**

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.Net.Client" Version="2.44.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\SharedLib\SharedLib.csproj" />
  </ItemGroup>

</Project>
```

これで、WebAPIサービスがgRPCクライアントを使用してバックエンドサービスに要求を送信する構成が完了しました。サービスを起動する前に、両方のプロジェクトで依存関係を復元し、ビルドします。

```bash
dotnet restore
dotnet build
```

次に、バックエンドサービスを起動し、続いてWebAPIサービスを起動して動作を確認します。

```bash
cd BackendService
dotnet run

cd ../WebAPIService
dotnet run
```

### user — 2024-07-24T06:51:06.449466+00:00

WEBAPIにはswaggerを追加する

### assistant — 2024-07-24T06:51:23.866666+00:00

WebAPIサービスにSwaggerを追加するためには、Swashbuckleパッケージを使用します。以下の手順でSwaggerを設定します。

### 1. Swaggerパッケージのインストール

WebAPIServiceプロジェクトにSwashbuckle.AspNetCoreパッケージを追加します。

```bash
dotnet add package Swashbuckle.AspNetCore
```

### 2. Swaggerの設定

**WebAPIService/Program.cs**を編集して、Swaggerの設定を追加します。

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Grpc.Net.Client;
using SharedLib;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddGrpcClient<IMyService>(options =>
{
    options.Address = new Uri("https://localhost:5001");
});
builder.Services.AddScoped<IMyService, MyServiceClient>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "WebAPIService v1");
    });
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();

public class MyServiceClient : IMyService
{
    private readonly IMyService.MyServiceClient _client;

    public MyServiceClient(IMyService.MyServiceClient client)
    {
        _client = client;
    }

    public async Task<Response> GetResponse(Request request)
    {
        var grpcRequest = new SharedLib.Request { Message = request.Message };
        var grpcResponse = await _client.GetResponseAsync(grpcRequest);
        return new Response { Result = grpcResponse.Result };
    }
}
```

### 3. Controllerの設定

すでに設定されている**WebAPIService/Controllers/MyController.cs**はそのままで問題ありません。

### 4. プロジェクトのビルドと実行

プロジェクトをビルドし、実行します。

```bash
dotnet restore
dotnet build
dotnet run
```

### 5. Swagger UIの確認

ブラウザで以下のURLにアクセスして、Swagger UIを確認します。

```
https://localhost:5001/swagger/index.html
```

これで、WebAPIサービスにSwagger UIが追加され、APIのエンドポイントを確認およびテストすることができます。

### user — 2024-07-25T09:04:20.176412+00:00

grpc呼び出し時に３秒タイムアウトを設定する

### system — 2024-07-25T09:04:59.426655+00:00

_(empty)_

### assistant — 2024-07-25T09:04:59.426781+00:00

gRPCクライアントでタイムアウトを設定するには、`GrpcChannelOptions`を使用して`HttpClient`のタイムアウトを設定します。以下の手順で、gRPCクライアント呼び出しに3秒のタイムアウトを設定します。

### 1. タイムアウトの設定

**WebAPIService/Program.cs**にて、gRPCクライアントの設定を追加します。

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Grpc.Net.Client;
using SharedLib;
using System;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Configure gRPC client with 3-second timeout
builder.Services.AddGrpcClient<IMyService>(options =>
{
    options.Address = new Uri("https://localhost:5001");
})
.ConfigureChannel(options =>
{
    options.HttpHandler = new HttpClientHandler
    {
        Timeout = TimeSpan.FromSeconds(3)
    };
});

builder.Services.AddScoped<IMyService, MyServiceClient>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "WebAPIService v1");
    });
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();

public class MyServiceClient : IMyService
{
    private readonly IMyService.MyServiceClient _client;

    public MyServiceClient(IMyService.MyServiceClient client)
    {
        _client = client;
    }

    public async Task<Response> GetResponse(Request request)
    {
        var grpcRequest = new SharedLib.Request { Message = request.Message };
        var grpcResponse = await _client.GetResponseAsync(grpcRequest, deadline: DateTime.UtcNow.AddSeconds(3));
        return new Response { Result = grpcResponse.Result };
    }
}
```

### 2. バックエンドサービスの起動

バックエンドサービスを起動します。

```bash
cd BackendService
dotnet run
```

### 3. WebAPIサービスの起動

WebAPIサービスを起動します。

```bash
cd ../WebAPIService
dotnet run
```

これで、WebAPIサービスがgRPCクライアントでバックエンドサービスを呼び出す際に、3秒のタイムアウトが設定されるようになります。タイムアウトが発生した場合は、適切な例外処理を行うことをお勧めします。

例えば、`MyServiceClient`クラスでタイムアウト例外をキャッチし、適切なレスポンスを返すようにします。

**WebAPIService/Program.cs**の一部修正：

```csharp
public class MyServiceClient : IMyService
{
    private readonly IMyService.MyServiceClient _client;

    public MyServiceClient(IMyService.MyServiceClient client)
    {
        _client = client;
    }

    public async Task<Response> GetResponse(Request request)
    {
        try
        {
            var grpcRequest = new SharedLib.Request { Message = request.Message };
            var grpcResponse = await _client.GetResponseAsync(grpcRequest, deadline: DateTime.UtcNow.AddSeconds(3));
            return new Response { Result = grpcResponse.Result };
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.DeadlineExceeded)
        {
            // Handle timeout
            return new Response { Result = "Request timed out" };
        }
    }
}
```

これにより、3秒以内に応答がない場合は「Request timed out」という結果を返すようになります。

### user — 2024-07-25T09:06:36.516806+00:00

CallContextを利用し、タイムアウト設定をおこなう

### assistant — 2024-07-25T09:07:14.519431+00:00

gRPCで`CallContext`を利用してタイムアウトを設定するには、gRPC呼び出し時に`CallOptions`を使用してタイムアウトを指定します。以下の手順で設定を行います。

### 1. タイムアウトの設定

**WebAPIService/Program.cs**にて、`CallOptions`を使用してタイムアウトを設定します。

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Grpc.Net.Client;
using SharedLib;
using System;
using System.Threading.Tasks;
using Grpc.Core;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Configure gRPC client
builder.Services.AddGrpcClient<IMyService>(options =>
{
    options.Address = new Uri("https://localhost:5001");
});

builder.Services.AddScoped<IMyService, MyServiceClient>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "WebAPIService v1");
    });
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();

public class MyServiceClient : IMyService
{
    private readonly IMyService.MyServiceClient _client;

    public MyServiceClient(IMyService.MyServiceClient client)
    {
        _client = client;
    }

    public async Task<Response> GetResponse(Request request)
    {
        var grpcRequest = new SharedLib.Request { Message = request.Message };
        var callOptions = new CallOptions().WithDeadline(DateTime.UtcNow.AddSeconds(3));
        
        try
        {
            var grpcResponse = await _client.GetResponseAsync(grpcRequest, callOptions);
            return new Response { Result = grpcResponse.Result };
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.DeadlineExceeded)
        {
            // Handle timeout
            return new Response { Result = "Request timed out" };
        }
    }
}
```

### 2. バックエンドサービスの起動

バックエンドサービスを起動します。

```bash
cd BackendService
dotnet run
```

### 3. WebAPIサービスの起動

WebAPIサービスを起動します。

```bash
cd ../WebAPIService
dotnet run
```

これで、WebAPIサービスがgRPCクライアントでバックエンドサービスを呼び出す際に、`CallOptions`を使用して3秒のタイムアウトが設定されるようになります。タイムアウトが発生した場合は、適切な例外処理を行い、エラーメッセージを返すようにしています。

### 追加の例外処理

タイムアウト以外のgRPCエラーも考慮する場合は、以下のように例外処理を追加できます。

```csharp
public class MyServiceClient : IMyService
{
    private readonly IMyService.MyServiceClient _client;

    public MyServiceClient(IMyService.MyServiceClient client)
    {
        _client = client;
    }

    public async Task<Response> GetResponse(Request request)
    {
        var grpcRequest = new SharedLib.Request { Message = request.Message };
        var callOptions = new CallOptions().WithDeadline(DateTime.UtcNow.AddSeconds(3));
        
        try
        {
            var grpcResponse = await _client.GetResponseAsync(grpcRequest, callOptions);
            return new Response { Result = grpcResponse.Result };
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.DeadlineExceeded)
        {
            // Handle timeout
            return new Response { Result = "Request timed out" };
        }
        catch (RpcException ex)
        {
            // Handle other gRPC errors
            return new Response { Result = $"gRPC error: {ex.Status}" };
        }
    }
}
```

これにより、タイムアウトだけでなく、他のgRPCエラーも適切に処理できます。
