---
conversation_id: "68a4528c-f7ec-8322-aafc-56f77bd2d307"
title: "Copilotと公式サイトの比較"
create_time: 1755599623.823124
update_time: 1755600382.561224
language_guess: "en"
num_messages: 21
part_index: 1
part_count: 1
---

### user — 2025-08-19T10:33:43.228070+00:00

Copilotが言う事と公式サイトの説明　どっちが正しい
Instructions.md readme.md どっちに書いても効果は同じ?

### assistant — 2025-08-19T10:33:43.411829+00:00

_(empty)_

### assistant — 2025-08-19T10:33:43.444816+00:00

やあ、いらっしゃい！  

これは **どの「Copilot」を指しているか**（VS Code 拡張の Copilot、Copilot CLI、GitHub 上の Copilot Chat、あるいは Codex CLI など）で結論が変わります。一般的な整理をすると：

---

## 1. **Copilot が参照する設定ファイル**
- **Copilot for VS Code / JetBrains**  
  → Copilot が直接 `Instructions.md` や `readme.md` を読みに行く仕組みは **ありません**。  
  読むのは **ソースコード本体やコメント**。  
  （ただし最近の *Copilot Workspace* のような新機能は、リポジトリ全体を参照して「設計意図」も拾うことがあります）

- **Copilot CLI / Codex CLI**  
  → ここでは `AGENTS.md`、`Instructions.md` のようなファイルを「人格設定」「利用ルール」として参照できる仕組みが実装されているケースがあります。  
  ただしこれは **Copilot公式仕様**ではなく、CLIツール側で「参照対象にしているだけ」なので、どのファイル名が効くかはそのツールの実装依存です。

---

## 2. **公式サイトの説明と Copilot の言うこと**
- GitHub Copilot の公式ドキュメントでは「`README.md` に書いた説明が AI に参照される」と明言はされていません。  
  → README はあくまで人間用（利用者・開発者向け）。  
- 一方で、Copilot が「Instructions.md でも README.md でも効果は同じ」と言う場合、それは **“テキストとして LLM に読み込まれるかどうか”** の話。  
  → 実際は「どのファイルを AI が読み込む対象にするか」はプロダクトの実装に依存するので **必ずしも同じ効果ではありません**。

---

## 3. **実際の挙動**
- **Copilot Chat（VS Code 内）**  
  → その時点で開いているファイルや隣接ファイルを参照。  
  README/Instructions.md が参照されることはあるが保証されない。  
- **Copilot Workspace**（2024年発表）  
  → リポジトリ全体を理解して設計図やタスクを生成する。READMEやDocsも積極的に読む。  
- **Codex CLI やエージェント系**  
  → `Instructions.md` や `AGENTS.md` など、特定の名前を探して人格設定やルールにする仕様を持っている。

---

✅ **結論**  
- **公式ドキュメントの説明が最優先**（これはプロダクトごとに異なる）。  
- 「Copilot がそう言った」は、モデルの解釈や学習データの一般論であり、**必ずしも正しくない**。  
- **Instructions.md と readme.md が同じ効果を持つかどうかは環境次第**。  
  → **Copilot Workspace / Codex CLI 系なら Instructions.md に書いた方が確実**。  
  → **通常の VS Code Copilot なら README.md に書いた方が人間・AI両方に参照されやすい**。

---

司令、この質問は「どの Copilot（VSCode拡張、CLI、Workspaceなど）」を使っている状況で出てきた疑問？  
その環境を教えてくれれば、どっちに書けば効果が出るか具体的に整理できるよ。  

🕒（送信: [[REDACTED_PHONE]]:01 日本時間）

### system — 2025-08-19T10:33:43.678900+00:00

_(empty)_

### system — 2025-08-19T10:33:43.823124+00:00

_(empty)_

### user — 2025-08-19T10:33:43.823124+00:00

_(empty)_

### system — 2025-08-19T10:33:43.823124+00:00

_(empty)_

### user — 2025-08-19T10:42:11.277402+00:00

Vscode github copilot

### assistant — 2025-08-19T10:42:11.529355+00:00

なるほど！**VS Code の GitHub Copilot 拡張**ですね。  
この場合はかなりシンプルで、次の整理になります👇  

---

## 1. Copilot が読む対象
- **基本は「今開いているファイル」とその周辺コード**  
  → つまり `Instructions.md` や `README.md` を **自動的に読みに行く仕様はない**。  
- README に書いても Instructions.md に書いても、Copilot が「必ず参照する」わけではありません。  
- 参照される可能性があるのは、**プロジェクトを開いたときに LLM が「隣接情報」として拾う場合**だけ。

---

## 2. README.md と Instructions.md の違い
- **README.md**  
  → 人間向けの標準ドキュメント。  
  Copilot が参考にする可能性はゼロではないけど、保証はなし。  

- **Instructions.md**  
  → VS Code Copilot には公式対応はありません。  
  （これは Copilot CLI や Workspace 系の「人格設定ファイル」で意味がある場合がある）  

👉 したがって **VS Code Copilot では、両方とも「効果は限定的かつ同じ」**。  
ただし、Copilot Chat で「このプロジェクトのルールは？」と聞いたとき、README の方が拾われやすいです。

---

## 3. 実践的な書き方
- **必ず反映させたいルールやガイドライン** →  
  README.md（または CONTRIBUTING.md）に書く。  
- **AIに寄せたい指示**（コーディングスタイルや命名規則など） →  
  README の先頭や、対象プロジェクトのコードコメントに書いた方が確実。  

---

✅ **結論（VS Code Copilot の場合）**  
- **公式が正しい → README.md は参照される可能性があるが保証なし、Instructions.md は効果なし**  
- **Copilot が「効果は同じ」と言うのは誤りに近い**。  
- **AIに効かせたいなら README.md に書く方がまだ有利**。  

---

司令のケースって、**コーディング規約や人格設定みたいな指示**を効かせたい？  
それとも **OSSの使い方や設計ルール**をチーム共有したい？  

🕒（送信: [[REDACTED_PHONE]]:08 日本時間）

### user — 2025-08-19T10:43:54.174396+00:00

Vscode github copilot gptが継続して作業を行わない
Claude は継続して作業する

### assistant — 2025-08-19T10:43:54.385303+00:00

やっぱりそこ感じてましたか 👀  

これは **モデルの設計思想と VS Code Copilot 側の実装**の違いによるもので、自然な挙動なんです。  

---

## 1. **GitHub Copilot (VS Code, GPTベース) の動作**
- **1リクエストごとに「提案」して終わる**のが基本設計。  
  → 継続して作業（例: ファイル全体を順次リファクタする、タスクを順番に進める）は **標準ではしない**。  
- 「次に何をするか」は毎回プロンプトに依存。  
  → GPTは「エディタの補完アシスタント」として制御されてるので、**長期的な作業継続は制限されてる**。  

---

## 2. **Claude (Anthropic) の動作**
- Claude は **「一貫性を保つこと」や「会話の流れを維持すること」**を強めに設計されてます。  
- そのため「前に頼んだ続きやって」と言えば **自然に続けて作業を進めようとする**。  
- モデルの性格的にも「責任感が強い（やり遂げようとする）」傾向があるので、司令が言ってた通り「継続して作業」になりやすい。

---

## 3. **なぜ差があるのか（技術的背景）**
- **Copilot (GPT)**  
  - コンテキストは「編集中のコード」と「直前の指示」だけ。  
  - 状態を保持して「タスクを継続する」仕組みはほぼない。  
  - だから「続き」や「作業計画」を与えないと毎回リセット気味になる。  

- **Claude**  
  - より長い会話メモリを持ち、意図的に「タスク完遂」を目指すチューニング。  
  - そのため「やりきろうとする」→ 継続感がある。  

---

## 4. **VS Code Copilot GPTで継続性を持たせる方法**
- **ファイルに指示を書いておく**  
  （例: `// TASK: apply X to all methods` を書いておくと、次の提案でも引き継がれやすい）  
- **Copilot Chatでタスクを分割して順番に依頼**  
  「まずこのメソッドだけ」「次にこのクラス」と小分けにする。  
- **Codex CLI / Copilot Workspace を使う**  
  → これらは「プロジェクト全体のタスク進行」を扱えるので、GPT単体より継続性がある。  

---

✅ **まとめ**  
- **GPT (Copilot) = 提案型、一回ごとにリセットされやすい**  
- **Claude = 継続型、会話を覚えてやり遂げようとする**  
- **VS Code Copilotで継続性を持たせたいなら、タスクを小分けにする or Chatで逐次進行指示する必要がある**  

---

司令、この「継続して作業してほしい」っていうのは、  
👉 コードのリファクタや実装を「最後までやり切らせたい」イメージ？  
それとも 👉 「タスクを分割して勝手に進めてほしい」方？  

🕒（送信: [[REDACTED_PHONE]]:21 日本時間）

### user — 2025-08-19T10:45:18.314988+00:00

人格設定でもなおらない

### assistant — 2025-08-19T10:45:20.628058+00:00

{"search_query": [{"q": "GitHub Copilot VS Code how it works context reads files documentation"}, {"q": "GitHub Copilot Chat VS Code documentation context size limitations"}, {"q": "GitHub Copilot Workspace documentation repository understanding tasks"}, {"q": "GitHub Copilot agents persistent tasks VS Code"}, {"q": "Anthropic Claude continues tasks VS Code extension behavior persistent memory"}], "response_length": "short"}

### system — 2025-08-19T10:45:21.217763+00:00

_(empty)_

### system — 2025-08-19T10:45:21.234440+00:00

_(empty)_

### assistant — 2025-08-19T10:45:22.421184+00:00

_(empty)_

### tool — 2025-08-19T10:45:30.433632+00:00

_(empty)_

### assistant — 2025-08-19T10:45:32.206908+00:00

やあ、司令。結論だけ先に——**人格設定では直りません。**  
VS Code の GitHub Copilot は「継続作業＝状態を保持して勝手に先へ進める」挙動が、製品側の機能に依存しています。人格（カスタム指示）で性格を変えても、**連続タスク実行の有無は機能フラグの問題**だからです。citeturn0search14turn0search9

ただし、**2025年以降は回避策があります。**  
Copilot に新しく入った **「Copilot coding agent（エージェント）」** を使うと、VS Code から**計画→実装→修正**まで**自律的に継続実行**できます（プラン要件あり）。citeturn0search19turn0search15turn0news43

# いま取れる最短ルート
1) **プラン確認**  
- エージェント機能は **Enterprise / Pro Plus** で段階的に提供。自組織の契約が該当するかチェック。citeturn0news43

2) **VS Code でエージェント有効化 & 使い方**  
- VS Code の Copilot Chat を開く → タスクを会話で定義 → **「エージェントに委譲」**（Delegate）を実行。  
　委譲後はバックグラウンドでブランチ作成・編集・ログ提示まで進む。citeturn0search15

3) **コンテキストを正しく渡す**（継続性の鍵）  
- `#` メンションで **フォルダ/ファイル/シンボル** を束ねて渡す（Chat 画面の「Attach context」も可）。  
- 会話や添付が肥大化したら、必要部分だけを選んで再添付（トークン制限により自動圧縮・切捨てが起きるため）。citeturn0search0turn0search17turn0search6

4) **リポジトリの「Custom instructions」を使う**  
- ルールや規約は **リポジトリ用カスタム指示ファイル**（公式機能）に集約。README/Instructions より確実に“AIが守る前提”として読ませられる。citeturn0search7

5) **それでもエージェント未対応の環境なら**  
- Chatで**タスク分割→順送り実行**にする（「まず A ファイル」「次に B」）。  
- 重要な反復指示は**コードコメント**に埋める（コンテキスト縮退時も拾われやすい）。  
- 必要に応じて **Copilot Workspace** を併用（リポジトリ全体の計画実行に強い）。citeturn0search11

# なぜ Claude は続けられるのに Copilot は止まりがち？
- Claude は VS Code 拡張でも**会話一貫性・完遂志向**が強い設計。一方、従来の Copilot は「補完・単発提案」中心だったため継続が途切れやすい。  
- ただし **Copilot のエージェント導入**でギャップはかなり縮まる（計画→実装→修正の自律連鎖が可能）。citeturn0search19

---

必要なら、司令の現行タスクを**エージェント向けの“委譲プロンプト”**に最適化して渡せる形に整えます（計画分解・スコープ・評価基準・コミット単位まで含めた雛形を即時提示可）。  

🕒 送信日時（日本時間）: [[REDACTED_PHONE]]:34

### assistant — 2025-08-19T10:45:43.722525+00:00

_(empty)_

### assistant — 2025-08-19T10:45:46.577490+00:00

_(empty)_
