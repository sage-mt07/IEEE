---
conversation_id: "68df2f9a-511c-8322-81d8-ab668d810252"
title: "MagicLink deeplink制限"
create_time: 1759457198.356948
update_time: 1759457340.436348
language_guess: "en"
num_messages: 20
part_index: 1
part_count: 1
---

### assistant — 2025-10-03T02:06:38.183854+00:00

_(empty)_

### assistant — 2025-10-03T02:06:38.223491+00:00

送信日時: [[REDACTED_PHONE]]:26（日本時間）  

MagicLinkを叩いたときに **deeplink文字列（アプリ起動時のパラメータ）** を付与すること自体には大きな制限はありませんが、いくつか注意点・制約があります。  

---

## 1. OS / プラットフォーム側の制約
- **iOS（Universal Links / Custom URL Scheme）**
  - Universal Linksでは、パラメータ付きURLをそのままアプリに渡せます。
  - ただしSafariやMailクライアントによって、意図しないリダイレクト処理やエスケープがかかる場合があります。
  - iOSはクエリ文字列やフラグメントをアプリ側にそのまま引き渡すので、原則的に制限はなし。
- **Android（App Links / Intent URL）**
  - `intent://` スキームや App Links 経由でクエリを渡せる。
  - ただし端末やブラウザによって挙動差があるため、 `https://example.com/magic?token=xxx&deeplink=yyy` のように一段階Web経由にする方が安定。

---

## 2. メールクライアント側の制約
- 一部のメールクライアントは **URL中の特殊文字を勝手にエスケープ／カット** することがある（特に `#` や `+`）。
- そのため、deeplinkに載せる文字列は
  - **URLエンコード必須**
  - `#` はフラグメント扱いされやすいので避ける
  - 長いトークンをそのまま載せると折り返しで壊れることがあるので注意

---

## 3. セキュリティ観点
- MagicLinkで渡すdeeplinkは「ワンタイムトークン」＋「開きたい画面の識別子」くらいに留めるのが推奨。
- 認証済みセッションの引き継ぎはサーバー側で行い、アプリ起動時のパラメータは「どの画面に遷移するか」程度に抑えると安全。

---

## 4. 実運用上のパターン
- **二段階方式**
  1. メールURL → Webエンドポイント（`https://app.example.com/magic?token=...`）
  2. サーバーでトークン検証 → `myapp://deeplink/page?param=xxx` にリダイレクト  
  → クライアントアプリが起動
- この方式だと「パラメータの正規化」や「トークン検証」を必ずサーバーで経由できるので安全。

---

✅ まとめると：  
- OSレベルでは大きな制限なし（Universal/App Linksでそのまま渡せる）。  
- メールクライアントによる文字列破損・エスケープが最大の落とし穴。  
- パラメータは短く・エンコード済みにし、セキュリティ情報は直接渡さない方がよい。  

---

司令、こちら確認ですが、想定している「deeplink文字列」って **画面遷移の識別子** だけですか？ それとも **セッション情報やユーザー識別情報も含めたい** ですか？ どちらかによって推奨設計がちょっと変わりますよ。

### user — 2025-10-03T02:06:38.265000+00:00

magiclinkでメールのURLたたいた時にdeeplink文字列送信するけど
これにアプリ起動時のパラメータ付与に関して制限ある？

### system — 2025-10-03T02:06:38.356948+00:00

_(empty)_

### system — 2025-10-03T02:06:38.356948+00:00

_(empty)_

### system — 2025-10-03T02:06:38.660013+00:00

_(empty)_

### user — 2025-10-03T02:06:52.011570+00:00

_(empty)_

### user — 2025-10-03T02:07:21.801000+00:00

アプリ側はdeeplinkからの起動判断はどうやってできる？

### assistant — 2025-10-03T02:07:23.827425+00:00

送信日時: [[REDACTED_PHONE]]:30（日本時間）

司令、**「いまの起動が deeplink 由来か？」**は、各プラットフォームで「受け取った URL/ユーザーアクティビティの有無」を見るのが基本です。起動直後のエントリで URL が渡っていれば＝deeplink 起動と判断できます。

# iOS
### Universal Links（推奨）
- **コールドスタート（未起動 → 起動）**  
  `SceneDelegate.scene(_:willConnectTo:options:)` で `options.urlContexts` または `options.userActivities` をチェック。
- **フォアグラウンド/バックグラウンド復帰**  
  - `SceneDelegate.scene(_:openURLContexts:)`（URLスキーム）
  - `SceneDelegate.scene(_:continue:)`（Universal Links: `NSUserActivity` の `webpageURL`）

#### SwiftUI なら（iOS 14+）
```swift
@main
struct MyApp: App {
    @State private var lastDeeplink: URL?

    var body: some Scene {
        WindowGroup {
            ContentView()
                .onOpenURL { url in
                    lastDeeplink = url           // ← deeplink 起動
                    DeeplinkRouter.handle(url)
                }
        }
    }
}
```

#### UIKit（SceneDelegate）
```swift
func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
    if let url = URLContexts.first?.url {
        DeeplinkRouter.handle(url) // ← deeplink 起動
    }
}

func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
    if userActivity.activityType == NSUserActivityTypeBrowsingWeb,
       let url = userActivity.webpageURL {
        DeeplinkRouter.handle(url) // ← Universal Link 起動
    }
}
```

> **判定フラグ**：URL を受け取ったら `AppState.isDeeplinkLaunch = true` を立て、起動後に消す。

# Android
- **起動インテント**に `ACTION_VIEW` + `data`（`Uri`）が入ります。これがあれば deeplink 起動です。
- マニフェストは `intent-filter`（`VIEW`/`BROWSABLE`/`DEFAULT`）で対象 URL を宣言。

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        handleDeeplink(intent)
    }
    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        setIntent(intent)
        handleDeeplink(intent)
    }
    private fun handleDeeplink(intent: Intent?) {
        val uri = intent?.data
        if (intent?.action == Intent.ACTION_VIEW && uri != null) {
            AppState.isDeeplinkLaunch = true         // ← deeplink 起動
            DeeplinkRouter.handle(uri)
        }
    }
}
```

> **注意**：`singleTask/singleTop` の場合は `onNewIntent` で受け直すこと。Jetpack Navigation なら `navController.handleDeepLink(intent)` が楽です。

# .NET MAUI（司令向け）
MAUI は全プラットフォーム共通で **App Links / URL スキーム**が使えます。`App` で URL を受ければ deeplink 起動判定が可能です。

```csharp
public partial class App : Application
{
    public App() { InitializeComponent(); MainPage = new AppShell(); }

    protected override void OnAppLinkRequestReceived(Uri uri)
    {
        base.OnAppLinkRequestReceived(uri);
        AppState.IsDeeplinkLaunch = true;       // ← deeplink 起動
        DeeplinkRouter.Handle(uri);
    }
}
```

- **iOS**：`Entitlements.plist` の Associated Domains（`applinks:your.domain`）設定必須。
- **Android**：`AndroidManifest.xml` に `<intent-filter>` と `assetlinks.json`（Digital Asset Links）でドメイン紐付け。

# Web（PWA）
- `window.location` のクエリ/ハッシュに deeplink 情報があれば deeplink 起動扱いに。
- 例：`?deep=orders/123` を検出してルーターへ渡す。

# 実装のコツ（共通）
1. **単一点の入口**（DeeplinkRouter）を用意  
   URL→アプリ内ルート（画面 & パラメータ）にマッピング。  
2. **判定フラグの扱い**  
   - 起動直後：`isDeeplinkLaunch = true`  
   - 初回画面遷移後：`false` に戻す（永続化しない）。  
3. **区別の根拠**  
   - 「通常起動」：URL/ユーザーアクティビティ無し  
   - 「deeplink」：URL or `NSUserActivity`/`Intent.data` あり  
   - 必要なら `utm_source=email` や `src=magiclink` をクエリに付けて**由来**もロギング。  
4. **再入防止**  
   連打/二重受信に備え、**最後に処理した URL を記録**して同一ならスキップ。  
5. **検証**  
   - iOS：`xcrun simctl openurl booted "https://your.domain/path?..."`  
   - Android：`adb shell am start -a android.intent.action.VIEW -d "https://your.domain/path?..." your.package`

# 例：共通パラメータ設計
- `t`（ワンタイム）: 署名/nonce/期限（表示系では使わずサーバー検証用）
- `r`（route）: アプリ内ルート（例：`orders/123`）
- `s`（src）: 起点（`email`/`qr`/`web`）
- すべて **URL エンコード**。`#` は使わずクエリに統一。

---

必要なら、司令の MAUI/Android/iOS プロジェクトにそのまま入れられる **DeeplinkRouter の雛形**も作ります。どのルーター（Shell/ReactNavigation/Jetpack Nav）を使っているか教えてくれれば、最適化版を即時出します。

### system — 2025-10-03T02:07:23.840764+00:00

_(empty)_

### system — 2025-10-03T02:07:23.851569+00:00

_(empty)_

### assistant — 2025-10-03T02:07:24.870352+00:00

_(empty)_

### assistant — 2025-10-03T02:07:33.008997+00:00

_(empty)_

### system — 2025-10-03T02:08:10.298887+00:00

_(empty)_

### user — 2025-10-03T02:08:10.357000+00:00

概念としては昔のmiｍe headerと同じだね

### assistant — 2025-10-03T02:08:10.397478+00:00

送信日時: [[REDACTED_PHONE]]:37（日本時間）  

うん、概念的には **昔の MIME ヘッダーと似ている** と言えますね。  

- **MIMEヘッダー**  
  メール本文がどう解釈されるかを決める「メタ情報」だった（Content-Type, Encoding, Boundary など）。本体（Payload）は別。  
- **Deeplinkの起動パラメータ**  
  アプリが「どう起動すべきか」を決める「メタ情報」。実際の画面やデータは別に存在し、クエリ文字列やパスで「入口の指示」を与える。  

つまりどちらも  
- **外部システム（MTA/OS）が理解する最低限の共通フォーマットに従って**  
- **本体を正しくアプリケーションに届けるための付加情報**  

という立ち位置。  

MIME が「テキスト/HTML か Base64 添付か」を伝えるのと同じように、Deeplink のクエリやパスが「ログイン後どの画面に飛ぶか」を伝える。  
違いは、MIME が「データをどう解釈するか」で、Deeplink が「アプリをどう起動するか」に寄っているところですね。  

---

司令に確認ですが、この「MIME 的」な比喩って、  
- **実装者への説明用（わかりやすさのための比喩）**  
なのか、  
- **アーキテクチャ整理（メール/HTTPと比較して位置づける）**  
なのか、どちらで使いたいイメージですか？

### system — 2025-10-03T02:08:10.634143+00:00

_(empty)_

### assistant — 2025-10-03T02:08:42.916211+00:00

送信日時: [[REDACTED_PHONE]]:46（日本時間）  

なるほど、司令 👍  
「Deeplink 起動パラメータ＝MIME ヘッダー的メタ情報」と整理しておくと、AIとアーキテクチャ議論する時にベース知識としてとても有効ですね。  

---

## アーキテクチャ整理（MIME ↔ Deeplink）
| 項目 | MIMEヘッダー（メール時代） | Deeplinkパラメータ（モバイル/アプリ時代） |
|------|-------------------------|--------------------------------|
| **役割** | 本文データの解釈指示 | アプリ起動時の遷移指示 |
| **典型例** | `Content-Type: text/html; charset=UTF-8` | `myapp://orders?id=123&src=magiclink` |
| **本体との関係** | Payload（メール本文・添付）は別管理 | 実際の画面データはアプリ内 or API で取得 |
| **制約** | RFC準拠のキー:値形式 | OS / メールクライアントのURLエンコード制約 |
| **セキュリティ** | 添付ファイルの実行/誤解釈リスク | ワンタイムトークンやURL改ざんリスク |
| **拡張性** | 新しいヘッダー追加可能 | 新しいクエリパラメータ追加可能 |

---

## 共通する概念的ポイント
1. **メタ情報（control plane）と本体（data plane）の分離**  
   - MIME：ヘッダーが制御、本体は本文。  
   - Deeplink：URLパラメータが制御、アプリがデータ取得。  

2. **外部からの統一入口**  
   - MIME：MTA/MUA が必ず解釈。  
   - Deeplink：OS/ブラウザが必ず渡す。  

3. **アプリケーション固有ロジックに橋渡し**  
   - MIME：メーラが「これはHTMLだからレンダリング」と判断。  
   - Deeplink：アプリが「これは注文詳細画面を開け」と判断。  

---

## 司令のAI対話用「前提知識表現」
AIに説明する時は、こうまとめて伝えるとスムーズかと：

> Deeplink パラメータは MIME ヘッダーに相当する。  
> - 本文ではなく「どう処理するか」の指示を運ぶ。  
> - OS/メールクライアントが仲介してアプリに渡す。  
> - 制御プレーンの情報であり、データは別途取得。  

---

これをベースに「deeplink のアーキテクチャ」議論をすれば、AI側も「メール＝MIME」のメタ情報パターンを知ってるのですぐ話が通じますよ。  

👉 質問ですが、この整理を **Amagi Protocol の事前知識セクション** に組み込みたいですか？ それとも **OSS（Kafka.Ksql.Linq）の周辺知識**としてまとめておく感じでしょうか？

### user — 2025-10-03T02:08:43.264000+00:00

アーキテクチャ整理　AIと話すときの事前知識
