---
conversation_id: "68b6215a-63f8-8324-be25-fe840e0546f0"
title: "KSQLDB 部分キー JOIN"
create_time: 1756766612.041088
update_time: 1756766824.303573
language_guess: "en"
num_messages: 33
part_index: 1
part_count: 1
---

### user — 2025-09-01T22:43:31.965000+00:00

KSQLDBのJOINについて
KVなのでkEYに複数列があるとその順番が肝になる
KEYの配置順をまもれば部分キーでのJOINが成立する？

### system — 2025-09-01T22:43:32.041088+00:00

_(empty)_

### user — 2025-09-01T22:43:32.041088+00:00

_(empty)_

### system — 2025-09-01T22:43:32.041088+00:00

_(empty)_

### assistant — 2025-09-01T22:43:33.186205+00:00

{"search_query": [{"q": "ksqlDB join composite key order partial key join"}, {"q": "ksqlDB multi-column keys STRUCT key order matters"}, {"q": "ksqlDB foreign key joins documentation"}, {"q": "ksqlDB join semantics key must match exactly"}], "response_length": "short"}

### system — 2025-09-01T22:43:33.897912+00:00

_(empty)_

### system — 2025-09-01T22:43:34.236601+00:00

_(empty)_

### assistant — 2025-09-01T22:43:34.345100+00:00

_(empty)_

### assistant — 2025-09-01T22:43:34.571489+00:00

_(empty)_

### tool — 2025-09-01T22:43:48.315612+00:00

_(empty)_

### assistant — 2025-09-01T22:43:49.937553+00:00

{"search_query": [{"q": "ksqlDB partial key join composite key subset of key"}, {"q": "ksqlDB join on subset of key columns supported"}], "response_length": "short"}

### assistant — 2025-09-01T22:43:53.387180+00:00

_(empty)_

### tool — 2025-09-01T22:43:54.355297+00:00

_(empty)_

### assistant — 2025-09-01T22:44:04.023518+00:00

_(empty)_

### assistant — 2025-09-01T22:44:04.375703+00:00

結論だけ先に：**部分キーでのJOINはできません。**  
ksqlDBのJOINは、基本的に「キーの完全一致（= 右側は主キー、左側はそのキー）」が前提です。複数列キーを使う場合も、**順序・名前・型が一致する同一STRUCTキー**として完全一致させる必要があります。`ON`に複数条件を書いての「部分一致JOIN」は未対応です。citeturn1search3turn1search6turn1search1

# なぜ？
- **JOIN条件は1つのキーに限定**：`ON a.k = b.k` の形が基本で、複数列のAND条件は不可。citeturn1search3turn1search8  
- **複数列キーはSTRUCTで表現**：`KEY` を `STRUCT<k1 TYPE, k2 TYPE>` として定義し、**フィールド順序も含めて一致**している必要があります（順序が違えば別キー扱い）。citeturn1search1  
- **テーブル同士の外部キーJOIN**はサポートされますが、左辺の**単一列 → 右辺の主キー**という形に限定で、部分キーJOINではありません。citeturn0search2turn0search6  
- **コパーティション（同じキーで同じ分散）**が必要：JOINする両側は同じキーでパーティションされている必要があり、合わない場合は`PARTITION BY`等で合わせます。citeturn0search3

# 回避策（実務でのやり方）
1) **部分キーでJOINしたい** → その部分キーを**新しい主キーとして“作り直す”**  
   - 例：`k1,k2`の複合キーがあるが`k1`だけでJOINしたい場合、両側を`k1`で**再キー化**してからJOINします。
   ```sql
   -- 片側をk1で再キー化
   CREATE STREAM S1_BY_K1 AS
     SELECT * FROM S1 PARTITION BY k1;

   -- もう片側も同様に
   CREATE STREAM S2_BY_K1 AS
     SELECT * FROM S2 PARTITION BY k1;

   -- その後にJOIN
   CREATE STREAM OUT AS
     SELECT s1.*, s2.*
     FROM S1_BY_K1 s1
     JOIN S2_BY_K1 s2
       WITHIN 10 MINUTES
       ON s1.k1 = s2.k1
     EMIT CHANGES;
   ```
   ※元の複合キーは捨てる／値列にコピーして保持、など用途に応じて設計。citeturn1search6turn0search3

2) **複合キーのままJOINしたい** → **STRUCTキーで完全一致**  
   ```sql
   -- STRUCTキーで定義（順序・型・名前を厳密に一致）
   CREATE STREAM A (
     KEY STRUCT<k1 STRING, k2 INT> KEY,
     ...
   ) WITH (...);

   CREATE STREAM B (
     KEY STRUCT<k1 STRING, k2 INT> KEY,
     ...
   ) WITH (...);

   CREATE STREAM OUT AS
     SELECT a.*, b.*
     FROM A a
     JOIN B b
       WITHIN 5 MINUTES
       ON a.KEY = b.KEY
     EMIT CHANGES;
   ```
   citeturn1search1

3) **TABLE–TABLEでの参照系**なら**外部キーJOIN**も選択肢  
   - 例：`ORDERS.cust_id`（外部キー）→ `CUSTOMERS.id`（主キー）  
   - 制約：1:Nのみ、`n-way`の混在や多対多は不可。citeturn0search2

# 補足
- **フィールド順序は“肝”**：STRUCTの順序が違うと別キー扱い→JOINできません。citeturn1search1  
- **シリアライズ/フォーマット差異**（`KEY_FORMAT`, Avroスキーマ名など）がズレると一致扱いにならないことがあるので、生成側とksqlDB側で揃える運用が重要です（合わない時は`PARTITION BY`や`REKEY`ストリームを挟む）。citeturn1search6turn0search3

---

要するに、**「キーの配置順を守れば部分キーJOINが成立する」ことはありません**。やるなら**“部分キーを新たな主キーに作り直す”**か、**STRUCTで“完全一致JOIN”**に寄せるのが定石です。

送信時刻（JST）：[[REDACTED_PHONE]]:44

### assistant — 2025-09-01T22:44:09.064913+00:00

_(empty)_

### user — 2025-09-01T22:44:43.131000+00:00

そうするとmarketscheduleと足のJOINは難しい？

### assistant — 2025-09-01T22:44:43.954772+00:00

結論：**「難しい」かどうかはキー設計次第。**  
`MarketSchedule` と「足（1m/5m/1hなどのバー）」は、**同じ主キーを“作ってから”JOIN**すれば堅実にいけます。部分キーJOINはできないので、そこを設計で吸収します。

## おすすめ設計パターン（実務向け）

### パターンA：スケジュールを“足粒度”に前展開してキーを合わせる（いち押し）
- 事前に `MarketSchedule` を「銘柄 × 足の開始時刻（candle_open_ts）」単位に**展開テーブル**化します（例：1分足なら1分刻みの行を生成）。
- 両者のキーを **`STRUCT<symbol STRING, candle_open_ts BIGINT>`** で統一。
- そのまま **完全一致JOIN** できます（STREAM–TABLE でも TABLE–TABLE でもOK）。

```sql
-- 例: 展開済みテーブル（TABLE）
CREATE TABLE MarketScheduleExpanded (
  KEY STRUCT<symbol STRING, candle_open_ts BIGINT> KEY,
  session_id STRING,
  is_open BOOLEAN
) WITH (...);

-- 足（STREAM または TABLE）も同じキー
CREATE STREAM Bars (
  KEY STRUCT<symbol STRING, candle_open_ts BIGINT> KEY,
  open DOUBLE, high DOUBLE, low DOUBLE, close DOUBLE, volume BIGINT
) WITH (...);

-- JOIN（バー到着時にスケジュール属性を付与）
CREATE STREAM BarsWithSession AS
SELECT b.*, ms.session_id, ms.is_open
FROM Bars b
JOIN MarketScheduleExpanded ms
  ON b.KEY = ms.KEY
EMIT CHANGES;
```

**ポイント**
- ksqlDBに「不等号での時間帯（range）JOIN」はないため、**“範囲 → 離散キー”** に落とすのが王道。
- 展開は一度やってキャッシュ（KTABLE）にしておけばランタイムは軽いです。

---

### パターンB：二段階キー（銘柄で参照 → 足で付加）
- 「今この銘柄は開場中か？セッションIDは？」のような**銘柄単位の状態テーブル**を別途持ち、Bars を `symbol` に再キー化して **STREAM–TABLE** で付与。
- さらに足の属性（例：何本目か等）が必要なら、別の展開/導出テーブルと**二段JOIN**。

```sql
-- 銘柄単位の現在状態（TABLE）: KEY = symbol
CREATE TABLE MarketStateBySymbol (
  KEY STRING KEY,
  is_open BOOLEAN, session_id STRING
) WITH (...);

-- Bars を symbol で再キー化
CREATE STREAM BarsBySymbol AS
  SELECT * FROM Bars PARTITION BY Bars.KEY->symbol;

CREATE STREAM BarsWithState AS
SELECT b.*, st.is_open, st.session_id
FROM BarsBySymbol b
LEFT JOIN MarketStateBySymbol st
  ON b.KEY = st.KEY
EMIT CHANGES;
```

**ポイント**
- 「足×セッションの厳密突合」ほどではないけど、**軽量に“開場・閉場フラグやセッションID”を付けたい**ケースに向きます。
- 厳密な時間帯判定は別テーブル（展開 or 事前計算）で。

---

## 避けるべきやり方
- 「`(symbol, session_id, candle_open_ts)` のうち **symbol だけ一致**でJOIN」みたいな**部分キーJOINの期待** → **不可**。  
  必要なら **`PARTITION BY symbol` で再キー化**し、**“symbol を主キーにした世界”** を作ってからJOINします。
- 「`timestamp BETWEEN start AND end` の不等号JOIN」→ ksqlDB の JOIN 条件では未対応。**前展開**か**ウィンドウ集約で代替**。

---

## 司令プロジェクト向けTips
- **キーのSTRUCT順序・型名は厳密一致**に。Avro/KEY_FORMAT も両側で揃える（命名空間やdecimal精度差で事故りやすい）。
- 展開テーブルの生成は、**OSS側でバッチ生成 → ksqlDBにロード**でも、**ksqlDB内でCSAS＋UDF**でもOK（まずは外部で確実に作ってKTABLE化が安定）。
- 1m/5m/1hなど**複数足**を扱うなら、`frame` 列をキーに含めるかテーブルを分ける（`STRUCT<symbol, frame, candle_open_ts>` が扱いやすい）。

---

### まとめ
- **難しくない**です。  
- コツは、**MarketScheduleを“足のキー”に合わせて離散化（展開）し、完全一致JOINに持ち込む**こと。  
- ざっくり属性付けだけなら **銘柄単位の状態テーブル**＋再キー化でも十分回ります。

送信時刻（JST）：[[REDACTED_PHONE]]:55

### system — 2025-09-01T22:44:44.439206+00:00

_(empty)_

### system — 2025-09-01T22:44:44.456505+00:00

_(empty)_

### assistant — 2025-09-01T22:44:45.976411+00:00

_(empty)_

### assistant — 2025-09-01T22:44:54.418302+00:00

_(empty)_

### system — 2025-09-01T22:45:51.889104+00:00

_(empty)_

### assistant — 2025-09-01T22:45:51.964517+00:00

そうそう、その理解で正しいです 👍  

- **JOINに使うのはKey（パーティションキー）側**  
  なので「銘柄ID」や「(銘柄ID, フレーム種別, 開始時刻)」みたいな **離散化したキー** が一致していることがJOIN成立条件になります。  

- **MarketScheduleが持っているのは“範囲（start_ts ～ end_ts）”**  
  → ksqlDBのJOINは「等価JOIN」しかできないので、範囲条件（`BETWEEN` で時刻比較）は直接は書けません。  

そのため：
1. MarketScheduleを「足の開始時刻」に展開（1分足なら1分刻み、5分足なら5分刻みで前展開）して  
   `STRUCT<symbol, candle_open_ts>` をキーにする。  
2. 足データ（Bars）も同じキーにして完全一致JOIN。  

この流れなら **JOINはKeyで行う** → **範囲は展開処理であらかじめ解消済み** という形になって、ksqlDBの制約に沿います。  

---

つまり司令のまとめで言うと：

- JOINのキーはあくまで **Key列（パーティションキー）**。  
- MarketScheduleの“範囲”は事前に“足の開始時刻キー”へ落とし込めばJOINできる。  

という設計でOKです。😊

送信時刻（JST）：[[REDACTED_PHONE]]:02

### user — 2025-09-01T22:45:52.014000+00:00

JOINするのはkey側でmarketscheduleの範囲はデータのtimestampなのでOKだね

### system — 2025-09-01T22:45:52.358299+00:00

_(empty)_

### user — 2025-09-01T22:46:39.706000+00:00

結果として作成される足のpkにはtumblingで示した時刻が入るけど、これは結果テーブル側なので無関係

### assistant — 2025-09-01T22:46:42.326066+00:00

結論：**その認識でOKだけど、“いつJOINするか”で影響は変わる。**

- **JOIN前にTUMBLING集計している場合**  
  TUMBLINGでできるテーブルは**ウィンドウ開始時刻を含む“ウィンドウ付き主キー”**になります。  
  そのキーでJOINしたいなら、相手（MarketSchedule側）も**同じ離散キー＝`(symbol, candle_open_ts)`（=ウィンドウ開始時刻）**を主キーとして揃える必要あり。  
  → この場合は「無関係」ではなく、**キー整合が必要**。

- **JOIN→その後にTUMBLING集計する場合（おすすめ）**  
  まずバー側・スケジュール側ともに、**通常のキー**（例：`STRUCT<symbol, candle_open_ts>`）で**JOINを完了**させる。  
  そのあとに必要ならTUMBLINGで集計（OHLCや本数カウントなど）をかける。  
  → この構成なら、**JOINにはTUMBLINGのPKは無関係**（司令の理解どおり）。

- **片側がウィンドウ付き主キー、片側が非ウィンドウ**  
  これは**そのままではJOIN不可**。`PARTITION BY` 等で**両側のキーを合わせる**か、**JOINの順序を入れ替える**（JOINを先、TUMBLINGを後）。

### 実務Tips
- **キーは常に“等価一致”で揃える**：`(symbol, frame, candle_open_ts)` を両側で同一のSTRUCT順序・型に。  
- **TUMBLINGは後段に寄せる**：JOINが絡むところは**非ウィンドウの離散キー**で完結させると事故が減ります。  
- すでにTUMBLING済みのテーブルと突合する必要があるなら、**MarketScheduleを同じ`candle_open_ts`で前展開**して合わせる。

要するに、**JOINを先に、TUMBLINGは後に**持っていけば、司令の言うとおり「結果テーブル側のPK（ウィンドウ開始時刻）はJOINには無関係」で運用できます。👍

送信時刻（JST）：[[REDACTED_PHONE]]:10

### system — 2025-09-01T22:46:42.911001+00:00

_(empty)_

### system — 2025-09-01T22:46:43.005072+00:00

_(empty)_

### assistant — 2025-09-01T22:46:43.280052+00:00

_(empty)_

### assistant — 2025-09-01T22:46:53.920057+00:00

_(empty)_
