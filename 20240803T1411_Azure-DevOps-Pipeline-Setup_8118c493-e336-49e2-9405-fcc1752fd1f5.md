---
conversation_id: "8118c493-e336-49e2-9405-fcc1752fd1f5"
title: "Azure DevOps Pipeline Setup"
create_time: 1722694298.021162
update_time: 1722694826.669615
language_guess: "en"
num_messages: 23
part_index: 1
part_count: 1
---

### system — 2024-08-03T14:11:38.021162+00:00

_(empty)_

### user — 2024-08-03T14:11:38.024167+00:00

Azure Devopsで依存関係を持つパッケージのパイプラインを構成する
また、依存関係によりパッケージが変更になった際のC# のプロジェクトファイルの変更も自動で行うものとする
パッケージのバージョン番号も自動で更新をおこなうものとする

### assistant — 2024-08-03T14:11:54.372614+00:00

_(empty)_

### assistant — 2024-08-03T14:11:54.372682+00:00

The user is configuring an Azure DevOps pipeline for a project with dependent packages. They want the pipeline to automatically update the C# project file when a package changes, including automatically updating the package version numbers.

### tool — 2024-08-03T14:11:54.372730+00:00

Model set context updated.

### assistant — 2024-08-03T14:11:54.372775+00:00

To configure an Azure DevOps pipeline that manages dependencies, updates C# project files, and automatically updates package version numbers, you can follow these steps:

1. **Set Up Your Pipeline:**

   - Create a new pipeline in Azure DevOps and connect it to your repository.

2. **Install Required Tools:**

   - Ensure you have tools like `dotnet` CLI, `nuget`, and `Git` installed in your pipeline environment.

3. **Define Pipeline Steps:**

   - Use a YAML file to define your pipeline steps. Below is an example YAML configuration for a pipeline:

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x' # Adjust to the version of .NET SDK you're using
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

- task: GitHubRelease@1
  inputs:
    gitHubConnection: 'YourGitHubConnection'
    repositoryName: 'your-repo-name'
    target: '$(Build.SourceBranch)'
    tagSource: 'gitTag'
    tag: '$(Build.BuildId)'
    title: 'New release'
    assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

4. **Update Package Versions Automatically:**

   - Use a script to update the `csproj` files with the latest package versions. You can include this script as a step in your pipeline.

```bash
#!/bin/bash
# Update-PackageVersions.sh
for csproj in $(find . -name '*.csproj'); do
  echo "Updating packages in $csproj"
  dotnet add "$csproj" package YourPackageName --version latest
done
```

   - Add this script to your pipeline:

```yaml
- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'
```

5. **Commit Changes Back to Repository:**

   - After updating the project files, commit and push the changes back to the repository.

```yaml
- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions"
    git push
  displayName: 'Commit and push changes'
```

6. **Publish Artifacts and Create Release:**

   - Publish the built artifacts and create a new release if needed.

```yaml
- task: CopyFiles@2
  inputs:
    contents: '**/bin/$(buildConfiguration)/**'
    targetFolder: '$(Build.ArtifactStagingDirectory)'

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
```

This setup ensures that your dependencies are updated, your project files reflect these changes, and your build artifacts are created and published correctly. Adjust the specifics of each step to fit your project's requirements.

### user — 2024-08-03T14:14:42.042640+00:00

このバージョンはテストが完了するまではRCとして管理をおこなう

### assistant — 2024-08-03T14:14:52.096860+00:00

_(empty)_

### assistant — 2024-08-03T14:14:52.096974+00:00

RC（Release Candidate）としてバージョンを管理するために、テストが完了するまでの間にリリースタグを `RC` として付け、テストが成功した場合にのみ正式なバージョンに変更するプロセスを追加します。

以下のような手順でパイプラインを更新します：

1. **RCタグの付与とコミット:**
   - パッケージのバージョンを更新し、RCタグを付けた状態でコミットします。

2. **テストの実行:**
   - パッケージのバージョンを `RC` としてテストを実行します。

3. **テストの成功確認後、正式バージョンへ変更:**
   - テストが成功した場合にのみ、正式なバージョンに変更し、再度コミットおよびタグを付けます。

以下は、上記のステップを含む YAML ファイルの例です：

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x' # Adjust to the version of .NET SDK you're using
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'

- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions to RC"
    git tag "v$(Build.BuildId)-RC"
    git push origin "v$(Build.BuildId)-RC"
    git push
  displayName: 'Commit and tag as RC'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

- script: |
    if [ $? -eq 0 ]; then
      git tag -d "v$(Build.BuildId)-RC"
      git tag "v$(Build.BuildId)"
      git push origin "v$(Build.BuildId)"
    fi
  displayName: 'Promote to final version if tests pass'

- task: CopyFiles@2
  inputs:
    contents: '**/bin/$(buildConfiguration)/**'
    targetFolder: '$(Build.ArtifactStagingDirectory)'

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'

- task: GitHubRelease@1
  inputs:
    gitHubConnection: 'YourGitHubConnection'
    repositoryName: 'your-repo-name'
    target: '$(Build.SourceBranch)'
    tagSource: 'gitTag'
    tag: 'v$(Build.BuildId)'
    title: 'New release'
    assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

このパイプラインでは、パッケージのバージョンを更新した後、RCタグを付けてコミットし、テストを実行します。テストが成功した場合にのみ、正式なバージョンとしてタグを変更し、リリースを行います。これにより、テストが完了するまでの間はRCとして管理し、テストが成功した場合にのみ正式なバージョンとしてリリースすることができます。

### user — 2024-08-03T14:15:43.759521+00:00

RCを正式版とする処理を追加する
これは管理者の承認をもっておこなう

### assistant — 2024-08-03T14:16:05.941546+00:00

The user wants to manage versions as Release Candidates (RC) until testing is complete, and then promote them to the official release version upon administrator approval.

### tool — 2024-08-03T14:16:05.941659+00:00

Model set context updated.

### assistant — 2024-08-03T14:16:05.941748+00:00

Azure DevOpsのパイプラインに管理者の承認を追加し、RCを正式版に昇格する処理を行うには、次の手順を行います。

1. **パイプラインに承認を追加:**
   - パイプラインで承認を必要とする段階を作成し、管理者が承認するまで待機します。

2. **承認後に正式版としてタグを付ける:**
   - 管理者が承認した後、RCタグを正式版に変更し、リリースを実行します。

以下は、管理者の承認を含むYAMLファイルの例です：

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x' # Adjust to the version of .NET SDK you're using
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'

- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions to RC"
    git tag "v$(Build.BuildId)-RC"
    git push origin "v$(Build.BuildId)-RC"
    git push
  displayName: 'Commit and tag as RC'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

# Approval stage
stages:
- stage: Approval
  jobs:
  - job: WaitForApproval
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: echo "Waiting for approval..."
    displayName: 'Waiting for approval'

    approval:
      timeoutInMinutes: 4320 # Set timeout as needed (e.g., 3 days)
      reviewers:
        - name: '[[REDACTED_EMAIL]]' # Replace with your admin's email or Azure DevOps user

# Post-approval steps
- stage: PostApproval
  dependsOn: Approval
  condition: succeeded()

  jobs:
  - job: PromoteToRelease
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        git tag -d "v$(Build.BuildId)-RC"
        git tag "v$(Build.BuildId)"
        git push origin "v$(Build.BuildId)"
      displayName: 'Promote to final version if tests pass'

    - task: CopyFiles@2
      inputs:
        contents: '**/bin/$(buildConfiguration)/**'
        targetFolder: '$(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'YourGitHubConnection'
        repositoryName: 'your-repo-name'
        target: '$(Build.SourceBranch)'
        tagSource: 'gitTag'
        tag: 'v$(Build.BuildId)'
        title: 'New release'
        assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

この設定では、RCタグを付けた後にテストを実行し、次の段階で管理者の承認を待ちます。承認が得られた場合にのみ、正式版としてタグを付け、リリースを行います。これにより、管理者の承認をもってRCを正式版に昇格するプロセスが確立されます。

### user — 2024-08-03T14:17:17.085380+00:00

RC版はartifactsから削除する処理を追加

### assistant — 2024-08-03T14:17:34.051422+00:00

_(empty)_

### assistant — 2024-08-03T14:17:34.051501+00:00

RC版のアーティファクトを削除する処理を追加するには、パイプラインの一部としてRC版のアーティファクトを削除するステップを追加します。

以下は、RC版のアーティファクトを削除する処理を追加したYAMLファイルの例です：

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x' # Adjust to the version of .NET SDK you're using
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'

- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions to RC"
    git tag "v$(Build.BuildId)-RC"
    git push origin "v$(Build.BuildId)-RC"
    git push
  displayName: 'Commit and tag as RC'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

# Approval stage
stages:
- stage: Approval
  jobs:
  - job: WaitForApproval
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: echo "Waiting for approval..."
    displayName: 'Waiting for approval'

    approval:
      timeoutInMinutes: 4320 # Set timeout as needed (e.g., 3 days)
      reviewers:
        - name: '[[REDACTED_EMAIL]]' # Replace with your admin's email or Azure DevOps user

# Post-approval steps
- stage: PostApproval
  dependsOn: Approval
  condition: succeeded()

  jobs:
  - job: PromoteToRelease
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        git tag -d "v$(Build.BuildId)-RC"
        git tag "v$(Build.BuildId)"
        git push origin "v$(Build.BuildId)"
      displayName: 'Promote to final version if tests pass'

    - task: DeleteFiles@1
      inputs:
        SourceFolder: '$(Build.ArtifactStagingDirectory)'
        Contents: '**/*'
      displayName: 'Delete RC artifacts'

    - task: CopyFiles@2
      inputs:
        contents: '**/bin/$(buildConfiguration)/**'
        targetFolder: '$(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'YourGitHubConnection'
        repositoryName: 'your-repo-name'
        target: '$(Build.SourceBranch)'
        tagSource: 'gitTag'
        tag: 'v$(Build.BuildId)'
        title: 'New release'
        assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

この設定では、承認が得られた後にRC版のアーティファクトを削除する `DeleteFiles` タスクを追加しています。このタスクは、指定されたディレクトリ（ここでは `$(Build.ArtifactStagingDirectory)`）内のすべてのファイルを削除します。その後、正式版のアーティファクトを生成し、リリースを行います。

### user — 2024-08-03T14:17:58.629494+00:00

この流れを説明する文書を作成

### assistant — 2024-08-03T14:18:33.569622+00:00

### Azure DevOps パイプラインフローの概要

この文書では、Azure DevOps パイプラインを使用して依存関係を管理し、Release Candidate（RC）版を正式版に昇格するプロセスを説明します。パイプラインは、依存パッケージの更新、RC版としてのタグ付け、テストの実行、管理者の承認を経て、正式版への昇格およびアーティファクトのリリースを行います。

#### パイプラインフローの手順

1. **パイプラインのトリガー**
   - `main` ブランチへのプッシュをトリガーとしてパイプラインが開始されます。

2. **ビルド環境の設定**
   - 最新の .NET SDK と NuGet をインストールします。

3. **依存パッケージのリストア**
   - ソリューションファイルから依存パッケージをリストアします。

4. **プロジェクトのビルド**
   - 指定された構成（`Release`）でプロジェクトをビルドします。

5. **NuGet パッケージの更新**
   - `NuGetCommand` タスクを使用して、プロジェクト内のパッケージを最新バージョンに更新します。

6. **パッケージバージョンの更新スクリプトの実行**
   - カスタムスクリプト `Update-PackageVersions.sh` を実行して、`csproj` ファイルのパッケージバージョンを更新します。

7. **RC版としてコミットおよびタグ付け**
   - パッケージバージョンを更新した後、コミットを行い、RC版としてタグ付け (`v<BuildId>-RC`) します。

8. **テストの実行**
   - ビルドされたプロジェクトに対してテストを実行します。

9. **承認ステージ**
   - テストが成功した場合、管理者の承認を待機します。管理者は指定された時間内に承認を行います。

10. **RCアーティファクトの削除**
    - 承認が得られた後、RC版のアーティファクトを削除します。

11. **正式版への昇格およびタグ付け**
    - RCタグを削除し、正式版として新しいタグを付け (`v<BuildId>`) 、コミットします。

12. **アーティファクトのコピーと公開**
    - 正式版のアーティファクトを生成し、指定されたディレクトリにコピーします。
    - 生成されたアーティファクトを Azure DevOps のビルドアーティファクトとして公開します。

13. **GitHub リリースの作成**
    - 正式版のタグで GitHub リリースを作成し、アーティファクトをリリースアセットとして添付します。

#### YAML ファイルの例

以下は、上記のフローを実装した YAML ファイルの例です：

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x' # Adjust to the version of .NET SDK you're using
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'

- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions to RC"
    git tag "v$(Build.BuildId)-RC"
    git push origin "v$(Build.BuildId)-RC"
    git push
  displayName: 'Commit and tag as RC'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

# Approval stage
stages:
- stage: Approval
  jobs:
  - job: WaitForApproval
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: echo "Waiting for approval..."
    displayName: 'Waiting for approval'

    approval:
      timeoutInMinutes: 4320 # Set timeout as needed (e.g., 3 days)
      reviewers:
        - name: '[[REDACTED_EMAIL]]' # Replace with your admin's email or Azure DevOps user

# Post-approval steps
- stage: PostApproval
  dependsOn: Approval
  condition: succeeded()

  jobs:
  - job: PromoteToRelease
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        git tag -d "v$(Build.BuildId)-RC"
        git tag "v$(Build.BuildId)"
        git push origin "v$(Build.BuildId)"
      displayName: 'Promote to final version if tests pass'

    - task: DeleteFiles@1
      inputs:
        SourceFolder: '$(Build.ArtifactStagingDirectory)'
        Contents: '**/*'
      displayName: 'Delete RC artifacts'

    - task: CopyFiles@2
      inputs:
        contents: '**/bin/$(buildConfiguration)/**'
        targetFolder: '$(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'YourGitHubConnection'
        repositoryName: 'your-repo-name'
        target: '$(Build.SourceBranch)'
        tagSource: 'gitTag'
        tag: 'v$(Build.BuildId)'
        title: 'New release'
        assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

この文書は、Azure DevOps パイプラインの設定および運用フローを理解しやすくするための参考資料です。設定をカスタマイズし、プロジェクトの要件に応じて適宜調整してください。

### user — 2024-08-03T14:19:15.271515+00:00

この流れを事前にテストするための構成を示せ

### assistant — 2024-08-03T14:19:40.032846+00:00

事前にこのパイプラインをテストするための構成を作成するには、以下のステップを含む構成が考えられます。これにより、実際のリリースプロセスを模倣しつつ、テスト環境で検証することができます。

### 事前テスト用のパイプライン構成

1. **分岐環境の設定**
   - テスト用のブランチを作成し、そのブランチに対してパイプラインを実行します。

2. **テスト環境の設定**
   - テスト用のAzure DevOpsサービス接続、テスト用のNuGetフィード、テスト用のGitHubリリースなどを設定します。

3. **仮のパッケージ更新スクリプト**
   - 実際のパッケージ更新処理を模倣するスクリプトを使用します。

4. **承認フローのシミュレーション**
   - 実際の承認者の代わりに自動承認ステップを追加して、承認フローをテストします。

以下に、テスト用のパイプライン構成の例を示します：

```yaml
trigger:
- test-branch

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  testBranch: 'test-branch'

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x'
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'
    nugetConfigPath: '$(Build.SourcesDirectory)/nuget.config' # テスト用NuGetフィードを指定

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'

- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions to RC"
    git tag "v$(Build.BuildId)-RC"
    git push origin "v$(Build.BuildId)-RC"
    git push
  displayName: 'Commit and tag as RC'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

# Approval stage - 自動承認のシミュレーション
stages:
- stage: Approval
  jobs:
  - job: SimulateApproval
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: echo "Simulating approval..."
      displayName: 'Simulating approval'

# Post-approval steps
- stage: PostApproval
  dependsOn: Approval
  condition: succeeded()

  jobs:
  - job: PromoteToRelease
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        git tag -d "v$(Build.BuildId)-RC"
        git tag "v$(Build.BuildId)"
        git push origin "v$(Build.BuildId)"
      displayName: 'Promote to final version if tests pass'

    - task: DeleteFiles@1
      inputs:
        SourceFolder: '$(Build.ArtifactStagingDirectory)'
        Contents: '**/*'
      displayName: 'Delete RC artifacts'

    - task: CopyFiles@2
      inputs:
        contents: '**/bin/$(buildConfiguration)/**'
        targetFolder: '$(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'YourTestGitHubConnection'
        repositoryName: 'your-test-repo-name'
        target: '$(Build.SourceBranch)'
        tagSource: 'gitTag'
        tag: 'v$(Build.BuildId)'
        title: 'New test release'
        assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

### 構成のポイント

- **テスト用ブランチ:** 本番環境とは別の `test-branch` ブランチを作成し、そこへのプッシュをトリガーにしてパイプラインを実行します。
- **テスト用フィード:** NuGetの `nuget.config` ファイルを利用して、テスト用のNuGetフィードを設定します。
- **自動承認:** 承認ステージでは、実際の承認者ではなく、承認をシミュレーションするための自動スクリプトを使用します。
- **GitHubリリース:** テスト用のGitHubリリースを設定し、本番環境とは別のリポジトリまたはリリース設定を使用します。

この設定により、本番環境に影響を与えずに、パイプラインの全体的な流れをテストすることができます。

### user — 2024-08-03T14:20:00.208340+00:00

管理者の承認はteamsへ通知をおこなう機能を追加

### assistant — 2024-08-03T14:20:24.660847+00:00

Azure DevOpsのパイプラインに管理者の承認を要求するステップがあり、その承認をTeamsに通知する機能を追加するには、TeamsのWebhookを使用して通知を送信することができます。

以下の手順でパイプラインにTeams通知機能を追加します。

1. **TeamsのWebhook URLを取得:**
   - Microsoft Teamsのチャンネルで「コネクタ」を選択し、「Incoming Webhook」を追加して、Webhook URLを取得します。

2. **パイプラインにTeams通知のステップを追加:**
   - Webhook URLを使用して、Teamsに通知を送信するためのステップを追加します。

以下に、Teams通知を含むYAMLファイルの例を示します：

```yaml
trigger:
- test-branch

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  testBranch: 'test-branch'
  teamsWebhookUrl: 'https://outlook.office.com/webhook/your-webhook-url' # Teams Webhook URL

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '6.x.x'
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 'latest'

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(Build.SourcesDirectory)/YourSolution.sln'
    feedsToUse: 'select'
    nugetConfigPath: '$(Build.SourcesDirectory)/nuget.config' # テスト用NuGetフィードを指定

- script: |
    dotnet build --configuration $(buildConfiguration)
  displayName: 'Build project'

- task: NuGetCommand@2
  displayName: 'Update NuGet packages'
  inputs:
    command: 'update'
    packagesDirectory: '$(Build.SourcesDirectory)'

- script: |
    dotnet restore
  displayName: 'Restore NuGet packages'

- script: |
    chmod +x Update-PackageVersions.sh
    ./Update-PackageVersions.sh
  displayName: 'Update package versions'

- script: |
    git config --global user.email "[[REDACTED_EMAIL]]"
    git config --global user.name "Your Name"
    git add .
    git commit -m "Auto-update package versions to RC"
    git tag "v$(Build.BuildId)-RC"
    git push origin "v$(Build.BuildId)-RC"
    git push
  displayName: 'Commit and tag as RC'

- script: |
    dotnet test --configuration $(buildConfiguration)
  displayName: 'Run tests'

# Approval stage
stages:
- stage: Approval
  jobs:
  - job: WaitForApproval
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: echo "Waiting for approval..."
      displayName: 'Waiting for approval'
    
    - script: |
        curl -H 'Content-Type: application/json' -d '{
          "text": "Build $(Build.BuildId) requires approval. Please review and approve the release at $(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
        }' $(teamsWebhookUrl)
      displayName: 'Notify Teams for approval'

    approval:
      timeoutInMinutes: 4320 # Set timeout as needed (e.g., 3 days)
      reviewers:
        - name: '[[REDACTED_EMAIL]]' # Replace with your admin's email or Azure DevOps user

# Post-approval steps
- stage: PostApproval
  dependsOn: Approval
  condition: succeeded()

  jobs:
  - job: PromoteToRelease
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        git tag -d "v$(Build.BuildId)-RC"
        git tag "v$(Build.BuildId)"
        git push origin "v$(Build.BuildId)"
      displayName: 'Promote to final version if tests pass'

    - task: DeleteFiles@1
      inputs:
        SourceFolder: '$(Build.ArtifactStagingDirectory)'
        Contents: '**/*'
      displayName: 'Delete RC artifacts'

    - task: CopyFiles@2
      inputs:
        contents: '**/bin/$(buildConfiguration)/**'
        targetFolder: '$(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'YourTestGitHubConnection'
        repositoryName: 'your-test-repo-name'
        target: '$(Build.SourceBranch)'
        tagSource: 'gitTag'
        tag: 'v$(Build.BuildId)'
        title: 'New test release'
        assets: '$(Build.ArtifactStagingDirectory)/**/*.zip'
```

### 構成のポイント

- **Teams Webhook URL:** `teamsWebhookUrl` 変数にTeamsのWebhook URLを設定します。
- **Teams通知のステップ:** 承認待ちのステップで、`curl` コマンドを使用してTeamsに通知を送信します。この通知には、ビルドIDと承認URLが含まれます。
- **承認フロー:** 承認ステージに管理者の承認を待機する設定を追加します。承認が得られるまで次のステップに進みません。

この構成により、ビルドが承認待ちの状態になったときにTeamsに通知が送信され、管理者が承認できるようになります。
