---
conversation_id: "68eb91de-8ab8-8321-b15c-fd6fa609dfa8"
title: "監視ワーカー実装計画"
create_time: 1760268769.045383
update_time: 1760268827.739677
language_guess: "en"
num_messages: 11
part_index: 1
part_count: 1
---

### system — 2025-10-12T11:32:49.045383+00:00

_(empty)_

### system — 2025-10-12T11:32:49.045383+00:00

_(empty)_

### user — 2025-10-12T11:32:49.531000+00:00

# 変更計画: _1s_rows 監視ワーカー導入

## 背景
- CTAS Tumbling (EMIT FINAL) では _1s_final の changelog が出力されず、既存のブリッジで _1s_rows を維持できなくなった。
- ToQuery により生成される _1s_rows をランタイム側で継続監視し、下流（上位タイムフレーム、ヘルスチェックなど）へ安定供給する必要がある。

## スコープ
1. Runtime 層に _1s_rows 監視クラスを追加し、バックグラウンドタスクで ForEachAsync を常駐実行する。
2. MappingRegistry から主キー情報を解決し、RowEvent として配信する。
3. ToQuery の Tumbling 設定からグレース秒数を取得し、遅延監視やログへ反映する。
4. モニターのライフサイクルをブートストラップに組み込み、開始・停止を制御する。
5. 観測ロジックを複数コンポーネントに配布できるようサブスク仕組みを整える（内部 API）。
6. ドキュメント / diff_log での周知。

## ステップ
1. **RowMonitor 実装**
   - Runtime 名前空間に RowMonitor<T1sRow> を新規追加。
   - Start() で TaskFactory.StartNew(..., TaskCreationOptions.LongRunning, TaskScheduler.Default) を起動。
   - ForEachAsync ハンドラー内で RowEvent を生成し、購読者へ非同期配信。
   - StopAsync() で CancellationTokenSource をキャンセルしタスク終了を待機。

2. **Key / Grace 解決**
   - MappingRegistry.GetMapping(typeof(T1sRow)) で主キー構造を取得し、RowEvent へ格納。
   - EntityModel.AdditionalSettings["graceSeconds"] から TimeSpan を生成（未設定時は標準値にフォールバックしログ出力）。

3. **ブートストラップ統合**
   - KsqlContext もしくは既存の HubStreamBridgeController に監視起動処理を追加。
   - _1s_rows エンティティを特定し、アプリ起動時にモニターを登録。
   - Dispose / StopAsync 経路で確実に停止するようハンドル。

4. **購読 API**
   - 内部用に Subscribe(Func<RowEvent, Task>) を公開し、上位フレーム変換やメトリクス取得が利用できるようにする。
   - スレッドセーフな登録・解除方法（ConcurrentBag など）を採用。

5. **エラーハンドリング / 観測**
   - ErrorHandlingContext を利用したリトライと DLQ 連携を確認。
   - 監視タスクが落ちた場合の再起動戦略（ContinueWith でログ + オプション再起動）。
   - 遅延 (lag) が GraceWindow を超えた場合のログ／メトリクス整備。

6. **テスト / ドキュメント**
   - ユニットテストでキー抽出・グレース設定・購読通知を検証。
   - docs/chart-ddl.md と docs/diff_log に仕様変更を追記。

## 依存関係 / 留意点
- 既存 ForEachAsync が CancellationToken を尊重することを確認（必要ならガード追加）。
- 監視タスクは単一インスタンスに限定し、重複起動を防止。
- グレース設定が ToQuery 側から供給されないケースを想定したフォールバック動作を明示。

## 成果物
- src/Runtime/RowMonitor.cs (仮)
- ブートストラップへの統合変更
- テストコード（	ests/Runtime/RowMonitorTests.cs など）
- 更新済みドキュメント / diff_log

### system — 2025-10-12T11:32:52.047817+00:00

_(empty)_

### system — 2025-10-12T11:32:52.053877+00:00

_(empty)_

### assistant — 2025-10-12T11:32:52.056903+00:00

_(empty)_

### assistant — 2025-10-12T11:32:52.227636+00:00

_(empty)_

### assistant — 2025-10-12T11:33:04.017907+00:00

司令、いい計画です。実装に直行できるよう、**最小API面・ライフサイクル・エラー処理・計測・受け入れ基準**まで詰めました。擬似コードは避け、**C#の具体インターフェース**で提示します。

# 仕様確定案（最終化して実装OK）

## 1) 型・イベント定義（Runtime）
- `RowEvent<T1sRow>`
  - `T1sRow Row`
  - `string Topic`
  - `int Partition`
  - `long Offset`
  - `DateTime MessageTimestampUtc`  // Kafka MessageTimestamp（必須）
  - `string[] KeyNames`
  - `object[] KeyValues`
  - `TimeSpan IngestLag`             // `UtcNow - MessageTimestampUtc`
  - `TimeSpan GraceWindow`           // 設定から解決
- `IRowMonitor<T1sRow>`
  - `Task StartAsync(CancellationToken ct)`
  - `Task StopAsync(CancellationToken ct)`
  - `IDisposable Subscribe(Func<RowEvent<T1sRow>, Task> handler)`  
    - スレッドセーフ、複数購読可。Disposeで解除。
- `IGraceProvider`
  - `TimeSpan ResolveGraceFor(Type entityType)`  
    - `EntityModel.AdditionalSettings["graceSeconds"]` を最優先  
    - 無ければ `IOptions<RuntimeOptions>.DefaultGraceSeconds` フォールバック＋Warnログ

## 2) 実装方針
- クラス：`RowMonitor<T1sRow> : BackgroundService, IRowMonitor<T1sRow>`
  - **BackgroundService** 採用（.NET 8標準の長寿命タスク／停止フローが安定。`TaskFactory.StartNew(LongRunning)`は不要）
  - 依存：
    - `IRowsSource<T1sRow>`（既存の `_1s_rows` を `ForEachAsync` で流す抽象）
    - `IGraceProvider`
    - `IMappingRegistry`（主キー抽出）
    - `ILogger<RowMonitor<T1sRow>>`
    - `ErrorHandlingContext`（リトライ/DLQ方針の委譲）
  - 起動時に**単一インスタンス**を保証：`IHostedService` としてDI 1登録＋`IHostApplicationLifetime`連携
  - `ExecuteAsync(ct)` 内で `IRowsSource<T1sRow>.ForEachAsync(async (msg, meta, ct) => { ... })`
    - `meta` から `Topic/Partition/Offset/MessageTimestampUtc` を取得（**Timestamp拡張を既定に**）
    - `IMappingRegistry.GetMapping(typeof(T1sRow))` で `KeyNames/KeyValues` を抽出  
      - 既存の「ForEachAsyncがMessaging Timestampを拾えない」課題は、**`IRowsSource`のメタ情報契約にMessageTimestampを必須化**して解消
    - `IngestLag = UtcNow - MessageTimestampUtc`
    - `GraceWindow = IGraceProvider.ResolveGraceFor(typeof(T1sRow))`
    - `RowEvent` を構築し、**全購読者へ `Task.WhenAll` で非同期配信**
      - 個別ハンドラ失敗は**集計**し、`ErrorHandlingContext` に渡してポリシー（再試行／DLQ）を適用
- 購読者管理
  - 内部：`ConcurrentDictionary<Guid, Func<RowEvent<T1sRow>, Task>>`
  - `Subscribe()` は `Guid` を払い出し、`IDisposable` で解除
- 自己監視・復帰
  - `ForEachAsync` ループ外側を `ErrorHandlingContext` に包む（戻り不能例外時：**ログ＋指数バックオフで再起動**）
- ラグ監視
  - `IngestLag > GraceWindow` で
    - `Logger.LogWarning`（1分あたり1回程度に**RateLimit**）
    - `Meter` で `lag_exceeded` カウンタ
- キャンセル尊重
  - `ForEachAsync`／各ハンドラは `ct` を必ず受け渡し
  - `StopAsync` は `BackgroundService` 既定＋内部のソースキャンセルで穏やかに終結

## 3) DI & ブートストラップ
- 設定
  - `RuntimeOptions { int DefaultGraceSeconds = 3; }`
- 登録（例：ASP.NET Core / Generic Host）
  ```csharp
  services.Configure<RuntimeOptions>(config.GetSection("Runtime"));
  services.AddSingleton<IGraceProvider, GraceProvider>();
  services.AddSingleton(typeof(IRowMonitor<>), typeof(RowMonitor<>)); // 実体はHostedService
  services.AddHostedService(provider => 
      (RowMonitor<OneSecondRow>)provider.GetRequiredService<IRowMonitor<OneSecondRow>>());
  ```
  - **単一インスタンス**保証：`AddSingleton`＋`AddHostedService`で同一インスタンスをHostedServiceとして起動
- 起動箇所
  - `KsqlContext` 初期化完了後に `_1s_rows` の `IRowsSource<OneSecondRow>` が利用可になるよう依存順序を整理
  - 既存 `HubStreamBridgeController` を使うなら、そのコンストラクタで `IRowMonitor<OneSecondRow>` を受け、上位フレーム変換やヘルスチェックに **Subscribe** 登録

## 4) 公開（内部）API：購読
- 例：上位タイムフレーム変換側
  ```csharp
  private IDisposable? _sub;

  public void Start(IRowMonitor<OneSecondRow> monitor) {
      _sub = monitor.Subscribe(async ev => {
          // PKごとのアキュムレータにpush、Timer/Graceでロールアップ
          await _aggregator.OnRowAsync(ev, CancellationToken.None);
      });
  }

  public void Stop() => _sub?.Dispose();
  ```

## 5) 計測（System.Diagnostics.Metrics）
- `Meter Name = "Kafka.Ksql.Linq.Runtime"`
  - `Counter<long> rows_received`
  - `Counter<long> handlers_failed`
  - `Counter<long> lag_exceeded`
  - `UpDownCounter<int> active_subscribers`
  - `Histogram<double> ingest_lag_ms`
- ログ粒度
  - 起動／停止は `Information`
  - リスタート／ラグ超過は `Warning`
  - ハンドラ例外詳細は `Debug`（PII/ペイロードは抑制）

## 6) エラーハンドリング
- `ErrorHandlingContext` ポリシー例
  - ハンドラ例外：最大3回指数バックオフ（100ms→400ms→1.6s）、以降DLQ（RowEventをシリアライズ）
  - ストリーム断：`ForEachAsync`からの伝播例外を捕捉し、**5s→10s→20s** の指数で再購読
  - DLQは**任意**（Kafkaトピック or ローカル永続）だが、**RowEvent + 例外情報**は必ず残す

## 7) グレース解決
- 優先順：
  1. `EntityModel.AdditionalSettings["graceSeconds"]`（ToQuery由来）
  2. `RuntimeOptions.DefaultGraceSeconds`（appsettings）
- 未設定時：
  - `DefaultGraceSeconds` を適用し `Logger.LogWarning("GraceSeconds not configured for {Entity}, fallback={Default}")`

## 8) 並行・重複起動ガード
- `RowMonitor<T>` 内に `int _started`（`Interlocked.Exchange`）で二重起動防止
- DIはSingleton＋HostedServiceで原則一意だが、**直接`StartAsync`を呼ばれても**安全

## 9) テスト観点（`tests/Runtime/RowMonitorTests.cs`）
- **キー抽出**：`IMappingRegistry`のモックで `KeyNames/KeyValues` が期待通り `RowEvent` に入る
- **グレース**：AdditionalSettingsあり／なしで `GraceWindow` が切り替わる
- **購読配信**：複数購読者に全件届く／解除で届かなくなる
- **キャンセル**：`StopAsync` 後に `ForEachAsync` が終了する（`CancellationToken`尊重）
- **ラグ超過**：`MessageTimestampUtc` を過去にして `IngestLag > GraceWindow` でWarning & `lag_exceeded++`
- **ハンドラ失敗**：1購読者のみ失敗しても他へは配信継続／`handlers_failed++`
- **再起動**：`IRowsSource` を一度例外で落として、指数バックオフ後に再購読される

## 10) ドキュメント更新（最小差分）
- `docs/chart-ddl.md`
  - **「_1s_rowsはRuntimeのRowMonitorで常時監視し下流へ配信」**のアーキ変更図・文言を追加
  - Tumbling(EMIT FINAL)の**changelog非出力**に触れ、**アプリ側監視に責務シフト**を明記
- `docs/diff_log.md`
  - 変更理由／影響範囲／移行手順（既存Bridge→RowMonitor購読への置換）
  - 運用：「Grace設定をToQueryから供給。なければappsettingsのDefaultを適用」

## 11) 成果物（パス確定）
- `src/Runtime/RowMonitor.cs`
- `src/Runtime/Abstractions/IRowMonitor.cs`
- `src/Runtime/Abstractions/IGraceProvider.cs`
- `src/Runtime/Options/RuntimeOptions.cs`
- `tests/Runtime/RowMonitorTests.cs`
- `docs/chart-ddl.md` / `docs/diff_log.md` 更新

---

# 受け入れ基準（Acceptance Criteria）

1. **常時監視**：アプリ起動後、`RowMonitor<OneSecondRow>` が起動し、`rows_received` が増加する  
2. **キー配信**：`RowEvent` に `KeyNames/KeyValues` が正しく入る  
3. **Grace反映**：ToQuery設定がある場合その秒数、無い場合は既定値が `RowEvent.GraceWindow` に入る  
4. **購読API**：2つ以上の購読者が同時に受け取れる。解除で配信停止  
5. **遅延警告**：`IngestLag > GraceWindow` でWarningログ＋メトリクス増分  
6. **強制停止**：`StopAsync` 実行で監視タスクが**30秒以内**に停止（ハングしない）  
7. **自己回復**：`IRowsSource` が一時的に例外を投げても、指数バックオフで**自動復帰**  
8. **単一インスタンス**：重複起動せず、ログに二重起動警告が出ない  
9. **ドキュメント**：`docs/chart-ddl.md` と `docs/diff_log.md` に変更事実と手順が記載済み

---

必要なら、この仕様をそのまま**PRテンプレ**と**タスクリスト**（GitHub Issues）に展開します。次の指示が無ければ `RowMonitor<T>` を `.NET 8 BackgroundService` で実装する前提で進めます。

—  
送信日時（JST）: [[REDACTED_PHONE]]:33

### assistant — 2025-10-12T11:33:04.075058+00:00

_(empty)_

### user — 2025-10-12T11:33:47.708033+00:00

_(empty)_
