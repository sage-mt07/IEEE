---
conversation_id: "68c8e434-caf0-832e-a4c3-7900074e6f43"
title: "C# FIDOサーバーパッケージ"
create_time: 1757996183.784008
update_time: 1757996309.541647
language_guess: "en"
num_messages: 13
part_index: 1
part_count: 1
---

### user — 2025-09-16T04:16:23.310929+00:00

C# でfidoのサーバ側を作る
おすすめパッケージは何か?

### assistant — 2025-09-16T04:16:23.696117+00:00

search("C# \u3067fido\u306e\u30b5\u30fc\u30d0\u5074\u3092\u4f5c\u308b\n\u304a\u3059\u3059\u3081\u30d1\u30c3\u30b1\u30fc\u30b8\u306f\u4f55\u304b?")

### assistant — 2025-09-16T04:16:23.699859+00:00

_(empty)_

### system — 2025-09-16T04:16:23.784008+00:00

_(empty)_

### user — 2025-09-16T04:16:23.784008+00:00

_(empty)_

### system — 2025-09-16T04:16:23.784008+00:00

_(empty)_

### system — 2025-09-16T04:16:25.008838+00:00

_(empty)_

### tool — 2025-09-16T04:16:26.187540+00:00

_(empty)_

### tool — 2025-09-16T04:16:26.201387+00:00

_(empty)_

### assistant — 2025-09-16T04:16:27.888626+00:00

C#／.NETで FIDO（特に WebAuthn / FIDO2）サーバー／リライイングパーティーを実装するなら、かなり使えるライブラリ／パッケージがあります。要件（例：商用か OSS、サポートするバージョン、機能／拡張の必要性など）によって選択肢が変わるので、まず特徴を整理してからおすすめを挙げます。必要なら比較もできます。以下、2025年9月時点での情報です。  

---

## チェックしておきたいポイント

サーバー側で FIDO2 / WebAuthn を実装する際、主に以下点を確認すると後で苦労しにくいです：

| 項目 | 理由 |
|---|---|
| WebAuthn spec のバージョン対応（Level 2 /拡張機能／Level 3 等） | 最新の認証器・ブラウザが使う拡張・アルゴリズムに対応していないと使えないことがある |
| アテステーション形式のサポート（packed, tpm, u2f, Android SafetyNet／Key, Apple, etc.） | 色々な種類の認証デバイスに対応できるほうが実用性が高い |
| タイムスタンプ・チャレンジの検証やドリフト対応 | セキュリティ上・ユーザビリティ上重要 |
| ストレージ（認証情報の保存）やユーザー管理との統合の容易さ | 既存のユーザー DB との統合を考える必要がある |
| 拡張機能／カスタマイズ性 | 特定の拡張（例 Credential Protection, Large Blob, Extensions）や企業ポリシーに合わせたいことがあるため |
| ドキュメント・デモコード・コミュニティの活発性 | トラブルシュートしやすい／アップデートも期待できる |

---

## 主なおすすめライブラリ／パッケージ

以下、C#／.NET 環境で使いやすいものをいくつか挙げます。

| ライブラリ名 | 特長・良い点 | 注意点／限界 |
|---|---|---|
| **fido2-net-lib**（Anders Åberg のプロジェクト） | 非常によく使われてる定番。登録（attestation）／認証（assertion）の処理が揃っている。ASP.NET Core との統合例もあり、拡張性・互換性が高い。 citeturn0search0turn0search9turn0search8 | 最新の拡張機能全部には未対応のことがあるので、使いたいアテステーション形式・拡張があればそれを試しておく必要あり。ドキュメントは英語中心。 |
| **WebAuthn.Net** | fido2-net-lib を参考にして作られているもの。ストレージの複数サポート（SQL Server, PostgreSQL, MySQL など）、拡張性が高く設計されている。例として metrics やオプションの構成がしやすい。 citeturn0search2 | 比較的新しめなので、コミュニティの成熟度・バグが見つかる可能性あり。ドキュメントをよく読む必要あり。 |
| **IPWorks WebAuthn**（商用） | パーティー利用のためのサポート・ API が整っており、クリーンな API デザイン。認証器、ブラウザ互換性がよい。商用サポートがあるので、企業利用時に良い。 citeturn0search15 | ライセンス費用がかかる可能性がある。OSS のものほどコミュニティからのフィードバックが自由ではないことがある。 |
| **.NET の組み込み / ASP.NET Core Identity の Passkeys サポート** | 最近の .NET では Identity フレームワークに WebAuthn / Passkeys を統合する機能が追加されてきていて、既存の Identity 基盤を使っているなら統合が比較的スムーズ。 citeturn0search12 | 柔軟性（たとえば非標準の認証器、拡張機能など）では他のライブラリより劣ることがあり、カスタム要件があるなら独自実装／拡張が必要になる。 |

---

## 推奨のスタート地点

「まずはこれで試してみて後から拡張」という観点でのスタート地点を挙げると：

- **fido2-net-lib** を使う（NuGet パッケージとして “Fido2”, “Fido2.AspNet” など） → 登録 & 認証フローを動かしてみる。既存のユーザー DB やストレージと接続する。 citeturn0search0turn0search10turn0search9  
- ブラウザ側（クライアント）のテストを Chrome／Firefox／Safari／Edge で行い、使いたい種類の認証器を用意して検証する。  
- 必要であれば WebAuthn の拡張（Large Blob, Credential Protection 等）や複数アテステーション形式が要るかを要件で定め、それらがライブラリでサポートされているかを確認する。  

---

もしよければ、「商用利用か」「どの .NET バージョンを使っているか」「対象の認証器（例：セキュリティキー、プラットフォーム認証器、モバイルなど）」を教えてくれれば、貴方の環境に最適なライブラリを具体的に絞れます。

---

**送信日時（日本時間）**: 2025/09/16 18:25

### user — 2025-09-16T04:18:11.408840+00:00

ストレージはファイルとしたい

### assistant — 2025-09-16T04:18:11.594415+00:00

なるほど！ストレージを **ファイルベース** にしたいのですね。  
FIDO2 サーバ側では「ユーザーごとの Credential（公開鍵・認証器ID・カウンタ・オプション情報など）」を保存する必要があります。通常は DB（SQL Server, PostgreSQL, etc.）を使いますが、シンプルにファイルへ保存することも可能です 👍  

---

## ファイルストレージでの実装方針

### 1. fido2-net-lib を利用する場合
- `IFido2Store` というインターフェースは標準では用意されていませんが、  
  **Credential データを保存する部分**を自作するのが一般的です。  
- Credential 情報（`StoredCredential` オブジェクトなど）を **JSON ファイルにシリアライズ**して保存するのが簡単です。

例イメージ:

```csharp
public class FileCredentialStore
{
    private readonly string _filePath;

    public FileCredentialStore(string filePath)
    {
        _filePath = filePath;
        if (!File.Exists(_filePath))
        {
            File.WriteAllText(_filePath, "[]");
        }
    }

    public List<StoredCredential> LoadAll()
    {
        var json = File.ReadAllText(_filePath);
        return JsonSerializer.Deserialize<List<StoredCredential>>(json) ?? new List<StoredCredential>();
    }

    public void Save(StoredCredential credential)
    {
        var list = LoadAll();
        list.RemoveAll(c => c.Descriptor.Id.SequenceEqual(credential.Descriptor.Id));
        list.Add(credential);
        var json = JsonSerializer.Serialize(list, new JsonSerializerOptions { WriteIndented = true });
        File.WriteAllText(_filePath, json);
    }

    public StoredCredential? Find(byte[] credentialId)
    {
        return LoadAll().FirstOrDefault(c => c.Descriptor.Id.SequenceEqual(credentialId));
    }
}
```

- `StoredCredential` は fido2-net-lib が提供する認証情報のモデル。  
- ユーザーIDごとにファイルを分けるか、ひとつのファイルに全ユーザー分を保持するかは要件次第。  

---

### 2. WebAuthn.Net を利用する場合
- デフォルトで EF Core 向けストレージ実装が用意されていますが、**`ICredentialStore` インターフェースを実装**すればファイル保存に切り替え可能です。  
- 実装イメージは上と同じで、`ICredentialStore` の `StoreAsync` / `FindByIdAsync` / `FindByUserHandleAsync` を JSON ファイルで実現できます。  

---

### 3. ファイルストレージの注意点
- **同時アクセス**（複数リクエストが並行してファイルを書き換えると壊れる可能性がある）  
  → 対策: `lock` で排他、あるいはファイルロックを使う  
- **スケーラビリティ**（サーバを複数台構成する場合に不向き）  
  → 単一サーバの簡易認証基盤なら十分  
- **バックアップ／復旧**の仕組みを忘れずに  
- **セキュリティ**（ファイルのパーミッションで保護、暗号化を検討）  

---

## まとめ

- **おすすめパッケージは `fido2-net-lib`**（一番実績がある）  
- ストレージは **JSON ファイルにシリアライズするクラスを自作**すればOK  
- サンプルとして上記 `FileCredentialStore` のように実装できる  

---

司令のユースケース（PoC／個人開発／単一サーバ運用）なら、まずは JSON ファイル保存で十分そうです。  
もし「ファイルを Avro／SQLite／暗号化Zip で持ちたい」など別フォーマットの希望もありますか？  

---

**送信日時（日本時間）**: 2025/09/16 18:36
