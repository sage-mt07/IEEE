---
conversation_id: "68ecb082-d1c0-8324-b4b1-0a457353c823"
title: "匿名型の解決方法"
create_time: 1760342164.960266
update_time: 1760342276.216875
language_guess: "en"
num_messages: 11
part_index: 1
part_count: 1
---

### system — 2025-10-13T07:56:04.960266+00:00

_(empty)_

### system — 2025-10-13T07:56:04.960266+00:00

_(empty)_

### user — 2025-10-13T07:56:07.334000+00:00

アイデアください
ありがとうございます。原因を特定しました。ポイントは「WindowGrouping<TKey,TElement> のインスタンス化」が匿名型キーで失敗していることです。

事象

MissingMethodException: WindowGrouping<AnonKey, Rate> のコンストラクタが見つからない
発生箇所: RowMonitor.CreateWindowGrouping → Activator.CreateInstance(...)
なぜ起きるか

GroupBy のキーが匿名型（new { Broker, Symbol }）で、RowMonitor は WindowGrouping<TKey,TSource> を反射で生成しています。
クラスは internal sealed かつジェネリックで、匿名型は別アセンブリ（Tests.Integration）に属するため、通常のコンストラクタ解決が不安定になりがちです。
すでに non-public を含む BindingFlags に切り替える対策を入れましたが、キー型が匿名型のケースで稀に解決に失敗します。
具体的な対策（推奨）

CreateFlushEnvelope のフォールバック強化
WindowGrouping の生成や DynamicInvoke に失敗した場合（MissingMethodException, ArgumentException, TargetParameterCountException 等）は、
GroupByのキー情報（Broker, Symbol）を匿名型から反射で読み出す
elements（Rate）の Bid/Close から OHLC を再計算
BucketStart は grouping.WindowStart を使用
これらで TRows（bar_1s_rows 互換の行）を直接構築して返す
これにより WindowGrouping の生成や投影の型一致に依存せず、秒行を確実に出力できます。
代替（必要なら）
SelectProjection 側を Final1sStream 用に「WindowGrouping → 行」の式に統一する（派生パイプライン側で組み立てる）。
こちらは式木生成のコストがあり、1) よりも改修量が大きいため次段階で検討。
ログ改善（参考）

受信ログの key 表示に匿名型の ToString() が出て可読性が低いので、DescribeGroupKey で匿名型から Broker/Symbol を抽出する（プロパティ名を既知キーとして読む）修正も併せて行うと追跡が容易になります。
次に進める内容

ご希望あれば、上記 1) のフォールバック実装（BuildRowViaReflection と例外キャッチ範囲の追加）を RowMonitor に反映します。これで当該 MissingMethodException は収束し、bar_1s_rows への flush が進みます。
匿名型をRuntimeの内部型に変換すればいいのでは？


結論: 匿名型を別の「ランタイム内部型」に置き換えるアプローチは理論上可能ですが、SelectProjection（LINQ式）が匿名型に静的にバインドされているため、キー型だけ差し替えると投影側との型不一致が発生します。安全にやるには「GroupBy のキー型」だけでなく「SelectProjection が受け取る WindowGrouping<TKey,T> の TKey」も同時に差し替える必要があり、式ツリーの再書き換えが必須になります。実装コストが高く、リスクも大きめです。

まずは最短で安定させる修正を提案します（匿名型のままで通す）

直接原因: WindowGrouping<TKey,T> インスタンス生成の反射が失敗
既定の Activator.CreateInstance は internal な型/コンストラクタの解決に失敗しやすいケースがあります（特に TKey が匿名型でテストアセンブリ由来）。
解決策（簡易・堅実）
明示的にコンストラクタを取得して呼び出す:
var groupingType = typeof(WindowGrouping<,>).MakeGenericType(_groupKeyType, typeof(TSource));
var paramTypes = new[] { _groupKeyType, typeof(DateTime), typeof(DateTime), typeof(IReadOnlyList<>).MakeGenericType(typeof(TSource)) };
var ctor = groupingType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, binder: null, types: paramTypes, modifiers: null);
var inst = ctor!.Invoke(new object[] { groupKey, bucketStartUtc, bucketEndUtc, elements });
これで「コンストラクタが見つからない」MissingMethodException は回避できます。匿名型のまま WindowGrouping<匿名型,T> を生成できるので、既存の SelectProjection（WindowGrouping を引数にとる LINQ 式）とも整合します。
それでもなお投影側と型が嚙み合わないケースに備える保険（任意）

RowMonitor にフォールバック投影を追加
DynamicInvoke/WindowGrouping 生成に失敗したとき:
groupKey から Broker/Symbol を反射で取得
elements（Rate）の Bid/Close から OHLC を再計算
BucketStart=WindowStart をセット
行（TRow）をリフレクションで組み立てて返す
これで rows を確実に吐けるようになります（最小限の要件担保）。
ご希望の「匿名型をランタイム内部型に変換」案を採る場合の実装方針（コスト高）

RuntimeKeyFactory を作って、匿名型のプロパティスキーマ（名前・型）から内部 public 型を動的生成（Reflection.Emit）。
GroupBy のキーセレクタを式ツリー再書き換えで「匿名型 → 内部型」の new に差し替え。
併せて SelectProjection の引数 WindowGrouping<匿名型,T> を WindowGrouping<内部型,T> に差し替える（ジェネリック引数書き換えの ExpressionVisitor が必要）。
この経路は「全部置換」になるので、まずは前述のコンストラクタ解決の明示化＋フォールバック投影の方を先に適用するのが現実的です。
次の一手

まず RowMonitor.CreateWindowGrouping を上記の ConstructorInfo.Invoke 方式に修正（簡易・安全）。
その上で症状が残る場合に限り、フォールバック投影（OHLC の再計算）を追加します。
この順で進めれば、ログの「Constructor not found」および後続の sweep 失敗は止まる見込みです。実装に入って良ければ、そのパッチを当てます。

### system — 2025-10-13T07:56:08.838639+00:00

_(empty)_

### system — 2025-10-13T07:56:08.847349+00:00

_(empty)_

### assistant — 2025-10-13T07:56:08.874873+00:00

_(empty)_

### assistant — 2025-10-13T07:56:09.908300+00:00

_(empty)_

### assistant — 2025-10-13T07:56:36.237680+00:00

やあ、いらっしゃい！司令、原因切り分けナイスです。匿名型キー × 反射生成の不安定さに対して、短期安定→中期整理→長期最適化の三段でいけるアイデアを置いておきます。

## 短期（今すぐ安定）
1) **Ctor 取得の厳密化＋キャッシュ**
- 既に提示の `GetConstructor(..., BindingFlags.NonPublic|Public)` で特定→`ConstructorInfo.Invoke` に統一。
- `ConcurrentDictionary<(Type keyType, Type elemType), ConstructorInfo>` でキャッシュし、例外時は即フォールバックへ。
- 例外種別は `MissingMethodException | TargetInvocationException | MemberAccessException | MethodAccessException` まで広げる。

2) **フォールバック投影（最小要件担保）**
- 司令案どおり：匿名型から `Broker/Symbol` を反射で取り出し、`elements` から OHLC 再計算→`TRow` を直組み。
- 匿名型の `ToString()` 汚れる問題は、**プロパティ名が既知キー**である前提で `DescribeGroupKey()` を実装（PropertyInfo を型別にキャッシュ）。
- これで「秒行は必ず吐く」状態をまず確保。

3) **匿名型アクセサの“型別キャッシュ”**
- 匿名型 `T` ごとに `(PropertyInfo brokerProp, symbolProp)` を一度だけ解析して `RuntimePropertyAccessor` をキャッシュ。
- 取り出しは `obj => (string)brokerProp.GetValue(obj)!` のデリゲート化（`Expression` でコンパイル）でオーバーヘッドを削減。

## 中期（整理と性能）
4) **コンストラクタ呼び出しの“安全デリゲート化”**
- 一度だけ `Expression.New(ctor, args)` を組んで `Func<object, DateTime, DateTime, IReadOnlyList<TSource>, object>` を `Compile()`。  
  ※ 匿名型が **別アセンブリ internal** の場合でも、**コンストラクタは反射で掴んだうえで `Expression.New(ctor, …)`** を使えば通るケースが多く、毎回 `Invoke` より速い。
- ダメなランタイム環境向けに自動で `Invoke` にフォールバック。

5) **IWindowGrouping 非ジェネリック面の導入**
- `WindowGrouping<TKey,T>` の**共通面**（`KeyObj`, `WindowStart`, `WindowEnd`, `ElementsObj`）を `IWindowGrouping` に寄せる。  
- 生成は相変わらず型付きを頑張るが、**投影フェーズでは IWindowGrouping 側を読める**ようにして、匿名型周りの厳密一致依存を薄める。

6) **型境界の“ゆる接続”**
- RowMonitor から先の **SelectProjection 実行部のみ**、`DynamicInvoke` → 事前バインドの `Delegate`（`LambdaExpression.Update` で引数差し替え）に置換。  
- 失敗時のみ **フォールバック投影**に切り替える“二段クラッチ”。

## 長期（構造最適化・匿名型卒業の道）
7) **Key 仕様の“公開・安定型”への移行計画**
- 生成 DSL が `new { Broker, Symbol }` を検知できるなら、**式ツリー書換え**で `ValueTuple<string,string>` か `readonly record struct BrokerSymbol(string Broker, string Symbol)` へ**限定的に**置換。  
- 置換は **GroupBy の `KeySelector` と `WindowGrouping<TKey,T>` の TKey 部**だけに留め、**下流の SelectProjection で TKey を使わない**よう IWindowGrouping 経由に誘導すれば、全面書換えを回避可能。

8) **RuntimeKeyFactory（将来案）**
- 匿名型のシグネチャ（プロパティ名・型）から **内部 public キー型**を `Reflection.Emit` で生成。  
- ただし Emit 管理コストが高いので、まずは 7) の `ValueTuple`/`record struct` で十分なはず。

## 運用・観測
9) **観測ポイントの追加**
- 「Ctor 解決 → 失敗 → フォールバックへ」の**回数と割合**をメトリクス化（`EventCounters` か簡易カウンタ）。  
- 匿名型 Type 名（`IsAnonymousType` 判定）とアセンブリ名、`BindingFlags` の実行結果を DEBUG ログに記録。

10) **テスト**
- 「匿名型が**別アセンブリ**にいる」ことを再現する IT を 1 本追加。  
- さらに **Key:ValueTuple 版** と **record struct 版**も並走で回して、将来移行の安全網に。

---

### すぐの実装順（提案）
1. Ctor 明示取得＋キャッシュ（例外種別拡大）。  
2. 匿名型アクセサの型別キャッシュ（DescribeGroupKey を含む）。  
3. 失敗時フォールバック（OHLC 再計算で秒行直組み）。  
4. パスが安定したら、Ctor 呼び出しのデリゲート化で微最適化。  
5. 余力で IWindowGrouping 面を導入して SelectProjection 依存を緩める。  
6. 将来タスクとして、限定的な式ツリー書換え（ValueTuple/record struct 置換）を PoC。

> ポイント：**「吐けない」をゼロにするフォールバックを先に**、次いで**反射コストと型厳密性の依存を徐々に剥がす**、の二段構えが安全です。

必要なら、`RowMonitor.CreateWindowGrouping` とフォールバック実装の差分パッチ、`DescribeGroupKey` の実装雛形をすぐ出します。  

——  
送信日時（日本時間）: [[REDACTED_PHONE]]:56:36

### assistant — 2025-10-13T07:56:37.265084+00:00

_(empty)_

### user — 2025-10-13T07:57:26.232562+00:00

_(empty)_
