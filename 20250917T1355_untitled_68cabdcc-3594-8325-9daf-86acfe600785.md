---
conversation_id: "68cabdcc-3594-8325-9daf-86acfe600785"
title: "マーケットスケジュール対応足"
create_time: 1758117325.312452
update_time: 1758117509.407782
language_guess: "en"
num_messages: 23
part_index: 1
part_count: 1
---

### user — 2025-09-17T13:55:21.179000+00:00

これにサポート機能としてマーケットスケジュールに従った足の作成を入れたい

### system — 2025-09-17T13:55:25.312452+00:00

_(empty)_

### system — 2025-09-17T13:55:25.312452+00:00

_(empty)_

### system — 2025-09-17T13:55:27.400104+00:00

_(empty)_

### system — 2025-09-17T13:55:27.413652+00:00

_(empty)_

### tool — 2025-09-17T13:55:27.416015+00:00

_(empty)_

### tool — 2025-09-17T13:55:27.416373+00:00

Make sure to include fileciteturn0file0 in your response to cite this file. 
# <img src="LinqKsql-logo.png" alt="LinqKsql" width="100" height="100" style="vertical-align:middle;margin-right:8px;"/> &nbsp;
&nbsp; Kafka.Ksql.Linq &nbsp;&nbsp;<img src="experimental.png" alt="Experimental"  height="30" style="vertical-align:middle;margin-right:8px;"/>

> LINQ-style C# DSL for type-safe Kafka/ksqlDB operations.

---

## Overview

Kafka.Ksql.Linq is a C# library that unifies Kafka/ksqlDB and Avro/Schema Registry usage. It lets you control Kafka Streams and ksqlDB in a LINQ style and offers the following capabilities.

- Operate Kafka and ksqlDB through a LINQ-based DSL.
- Design type-safe schemas with Avro and Schema Registry.
- Detect Streams/Tables and Pull/Push modes automatically.
- Support operations with DLQ, retry, and commit helpers.

---

## Quick start

### ✅ Send one message and receive it within 10 seconds

- **Prerequisites**: .NET 8, Kafka, ksqlDB, Schema Registry
- **Install**:

```sh
dotnet add package Kafka.Ksql.Linq
```

- **Code sample**: Send one Hello World message, receive it instantly, and print it.

```csharp
await using var context = new HelloKafkaContext(configuration, LoggerFactory.Create(b => b.AddConsole()));
var message = new HelloMessage
{
    Id = Random.Shared.Next(),
    Text = "Hello World"
};
await context.HelloMessages.AddAsync(message);
await context.HelloMessages.ForEachAsync(m =>
{
    Console.WriteLine($"Received: {m.Text}");
    return Task.CompletedTask;
});
```

---

## Architecture snapshot

The diagram below shows how Kafka.Ksql.Linq connects to your Kafka environment and processes data.

### End-to-end architecture

```mermaid
flowchart TB
    subgraph App["C# application"]
        A[LINQ / DSL invocation]
    end

    A --> B[DSL]
    B --> C[Query Builder]
    C --> D[KSQL generator]
    D -->|DDL/CSAS/CTAS| E[ksqlDB]
    E -->|Read/Write| F[(Kafka topics)]

    %% Supporting components
    subgraph Schema["Schema management"]
        SR[(Schema Registry)]
        AV[Avro serializer/deserializer]
    end

    D --> SR
    SR --- AV
    AV --- F

    %% Operations and modes
    subgraph Ops["Operational features"]
        EH[DLQ / Retry / Commit]
        MODE[Streaming mode\nPush / Pull]
    end

    E ---> EH
    E ---> MODE

    %% Cache layer
    subgraph Cache["Local cache"]
        ST[Streamiz]
        RDB[(RocksDB)]
    end
    ST --- RDB
    ST -. State store .- E
```

---

## 📘 Examples

Review the representative samples below. Every example is cataloged in [`docs/examples/index.md`](docs/examples/index.md).

- Basics: `AddAsync` / `ForEachAsync`
- Query basics: LINQ-to-KSQL conversion samples
- Windowing: time windows and aggregations
- Error handling: DLQ / Retry / Commit
- OnModelCreating: [`docs/onmodelcreating_samples.md`](docs/onmodelcreating_samples.md)

---

## 📚 Documentation

### 👩‍💻 User guides

- SQL Server to Kafka: [`sqlserver-to-kafka-guide.md`](docs/sqlserver-to-kafka-guide.md)
- API reference: [`api_reference.md`](docs/api_reference.md)
- Configuration guide: [`configuration_reference.md`](docs/configuration_reference.md)

### ⚙️ Under the hood

- Extension rules and design intent: [`advanced_rules.md`](docs/advanced_rules.md)

---

## 🧭 License and roadmap

- License: [MIT License](./LICENSE)
- Documentation: portions will adopt [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)
- Planned work (examples):
  - Expand examples
  - Prepare for .NET 10 support

---

## 🤝 Acknowledgements

This library was built under the theme of "AI and human co-creation" with support from the Amagi, Naruse, Shion, Kyouka, Kusunoki, Jinto, Hiromu, and Hazuki AI agents. See [Acknowledgements.md](./docs/acknowledgements.md) for details.

---

### tool — 2025-09-17T13:55:27.416698+00:00

All the files uploaded by the user have been fully loaded. Searching won't provide additional information.

### assistant — 2025-09-17T13:55:27.416874+00:00

_(empty)_

### assistant — 2025-09-17T13:55:27.788113+00:00

_(empty)_

### assistant — 2025-09-17T13:56:02.297497+00:00

やあ、司令！いいね、その方向。READMEの機能一覧に「マーケットスケジュール準拠のOHLC足生成」を“サポート機能”として追加しつつ、使い方を最小構成で示す差分を用意したよ（英語README想定）。そのままコピペで入れられるように diff 形式にしてある。

---

# 提案差分（README 追記）

```diff
--- a/README.md
+++ b/README.md
@@ -9,6 +9,12 @@
 Kafka.Ksql.Linq is a C# library that unifies Kafka/ksqlDB and Avro/Schema Registry usage. It lets you control Kafka Streams and ksqlDB in a LINQ style and offers the following capabilities.

 - Operate Kafka and ksqlDB through a LINQ-based DSL.
 - Design type-safe schemas with Avro and Schema Registry.
 - Detect Streams/Tables and Pull/Push modes automatically.
 - Support operations with DLQ, retry, and commit helpers.
+ - **Market-schedule–aware OHLC bars (support feature):**
+   Generate OHLC bars (e.g., 1s/1m/5m/15m/1h) strictly aligned to exchange trading sessions.
+   The engine skips closed hours and holidays, handles DST correctly, and offers gap policies
+   (skip, carry-forward close, or emit sentinel). Pre-/post-market can be toggled per schedule.

@@ -78,6 +84,67 @@
 - Error handling: DLQ / Retry / Commit
 - OnModelCreating: [`docs/onmodelcreating_samples.md`](docs/onmodelcreating_samples.md)

+### 📈 Market-schedule–aware bars (support feature)
+
+This feature creates OHLC bars aligned to a **MarketSchedule** (e.g., NYSE, JPX).
+Bars are emitted only within defined sessions; closed hours and holidays are respected.
+Time zone and DST are handled at the schedule layer before window bucketing.
+
+**Key concepts**
+- `IMarketSchedule`: encapsulates open/close sessions, holidays, time zone, and pre/post toggles.
+- `BarWindowPlan`: declares bar periods (e.g., 1s → 1m → 5m …) and roll-up strategy.
+- `GapPolicy`: how to treat gaps across closed periods: `SkipClosed` (default),
+  `CarryForwardClose`, or `EmitSentinel`.
+- `BoundaryPolicy`: e.g., `OpenInclusiveCloseExclusive` for session-edge alignment.
+
+**Minimal example**
+```csharp
+// 1) Define a market schedule (example: JPX cash session)
+public sealed class JpxCash2025 : IMarketSchedule
+{
+    public string MarketId => "JPX";
+    public TimeZoneInfo TimeZone => TimeZoneInfo.FindSystemTimeZoneById("Asia/Tokyo");
+    public IEnumerable<(TimeOnly Open, TimeOnly Close)> RegularSessions => new[]
+    {
+        (new TimeOnly(9, 0),  new TimeOnly(11, 30)),
+        (new TimeOnly(12, 30), new TimeOnly(15, 0))
+    };
+    public IEnumerable<DateOnly> Holidays => JpxHolidayCalendar.For(2025);
+    public bool UsePreMarket => false;
+    public bool UsePostMarket => false;
+}
+
+// 2) Wire it into your context
+protected override void OnModelCreating(KsqlModelBuilder modelBuilder)
+{
+    modelBuilder
+        .UseMarketSchedule(new JpxCash2025())
+        .UseBarWindowPlan(BarWindowPlan.Create(
+            Period.Seconds(1),
+            Period.Minutes(1),
+            Period.Minutes(5),
+            Period.Minutes(15),
+            Period.Hours(1)))
+        .UseGapPolicy(GapPolicy.SkipClosed)                   // default
+        .UseBoundaryPolicy(BoundaryPolicy.OpenInclCloseExcl); // default
+
+    // Example: Ticks -> 1s final (TABLE) -> 1s stream -> 1m/5m live (TABLE)
+    modelBuilder.Entity<Bar1sFinal>()
+        .ToQuery(q => q.From<Tick>()
+            .Tumbling(t => t.TimestampUtc, new Windows { Seconds = new[] { 1 } })
+            .AlignToMarketSessions()); // schedule-aware bucketing
+}
+```
+
+**DDL shape (outline)**
+- The generated KSQL/ksqlDB artifacts are filtered by session windows derived from the schedule.
+- 1s “final” TABLE is materialized only inside sessions; downstream bars roll up from it.
+- Internally, timestamps are converted to the schedule’s time zone before bucket assignment.
+
+**Configuration knobs**
+- `IMarketSchedule`: supply your own calendar provider (e.g., REST/embedded list).
+- `GapPolicy`: `SkipClosed` | `CarryForwardClose` | `EmitSentinel`.
+- `BoundaryPolicy`: `OpenInclusiveCloseExclusive` (default) or `OpenExclusiveCloseInclusive`.
+- `UsePreMarket` / `UsePostMarket`: include extended sessions when `true`.
+
 ---
 
 ## 📚 Documentation
```

---

## 実装メモ（エンジン側の要点）

- **スケジュール前処理**：入力 Tick の UTC → `MarketSchedule.TimeZone` に変換 → セッション判定 → セッション外は「未対象」扱い（`GapPolicy`に従う）。  
- **1s 最終テーブル**：従来どおり `TABLE bar_1s_final` を中核にし、`AlignToMarketSessions()` で「セッション内のみ」集計。  
- **ロールアップ**：`bar_1s_final_s (STREAM)` を唯一の親として 1m/5m/… に段階集約。  
- **DST/祝日**：`IMarketSchedule` に閉場日一覧と TZ を持たせ、バケットの境界演算は必ずローカル時間で行う。  
- **ギャップ処理**：  
  - `SkipClosed`…閉場時間帯はバー自体を出さない（デフォルト）。  
  - `CarryForwardClose`…再開初バーの Open に直前 Close を繰り越す。  
  - `EmitSentinel`…欠損を特別値で明示（分析向け）。  

この差分を入れると、「サポート機能」としての位置付けを崩さず、README冒頭の機能一覧と Examples の間に最小限の導入を置けるはず。細かい API 名はあなたの実装に合わせて微調整してね。README の現在構成はここ（Overview/Examples/Docs 等）を参照：fileciteturn0file0

---

必要なら、英日両対応のドキュメント断片や `IMarketSchedule` の既定実装（JPX/NYSE サンプル実装）もすぐ用意するよ。  

送信日時 (JST): [[REDACTED_PHONE]]:56

### assistant — 2025-09-17T13:56:38.741295+00:00

_(empty)_

### assistant — 2025-09-17T13:56:40.094635+00:00

_(empty)_

### user — 2025-09-17T13:58:08.102952+00:00

_(empty)_

### user — 2025-09-17T13:58:11.389000+00:00

サンプルへのリンクをつける

### system — 2025-09-17T13:58:14.504553+00:00

_(empty)_

### assistant — 2025-09-17T13:58:14.526047+00:00

{"queries": ["MarketSchedule sample", "IMarketSchedule example", "bars sample code", "ohlc sample code"], "source_filter": ["files_uploaded_in_conversation"]}

### system — 2025-09-17T13:58:14.561326+00:00

_(empty)_

### tool — 2025-09-17T13:58:17.042984+00:00

_(empty)_

### assistant — 2025-09-17T13:58:17.784327+00:00

README の中にはすでに「📘 Examples」セクションがあり、代表的なサンプルがまとめられていて、その全体インデックスは [`docs/examples/index.md`](docs/examples/index.md) にリンクされています【20:0†README.md†L97-L99】【20:1†README.md†L45-L53】。  

なので、「マーケットスケジュール準拠の足生成」機能の紹介にサンプルへのリンクを自然に組み込むなら、次のような差分にするとよさそうです。

---

### 差分（README）

```diff
+**Minimal example**
+[See more in: `docs/examples/marketschedule_bars.md`](docs/examples/marketschedule_bars.md)
+
 ```csharp
 // 1) Define a market schedule (example: JPX cash session)
 public sealed class JpxCash2025 : IMarketSchedule
```

---

つまり、追加説明の直後に「Minimal example」の見出しを残しつつ、詳細版サンプルを `docs/examples/marketschedule_bars.md` へ誘導する形。これなら他のサンプル群と一貫性があり、ユーザーが「一覧は index.md → 個別ファイル参照」という流れで辿れるようになります。  

---

司令、このリンク先ファイル（`docs/examples/marketschedule_bars.md`）を新規に作って、実装サンプル全文を入れておきますか？それとも README にある最小例だけで十分にしておきますか？  

送信日時 (JST): [[REDACTED_PHONE]]:02

### tool — 2025-09-17T13:58:17.784521+00:00

_(empty)_

### system — 2025-09-17T13:58:17.804406+00:00

_(empty)_
