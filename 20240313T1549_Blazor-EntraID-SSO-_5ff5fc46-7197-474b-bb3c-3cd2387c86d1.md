---
conversation_id: "5ff5fc46-7197-474b-bb3c-3cd2387c86d1"
title: "Blazor EntraID SSO の実装"
create_time: 1710344986.154626
update_time: 1710351756.719941
language_guess: "en"
num_messages: 12
part_index: 1
part_count: 1
---

### system — 2024-03-13T15:49:46.154626+00:00

_(empty)_

### user — 2024-03-13T15:49:46.155132+00:00

BlazorでEntraIDを使用することをぜんていとしてSSOにんしょうのコードをしめせ

### assistant — 2024-03-13T15:51:56.972881+00:00

BlazorでEntraID（以前のMicrosoft Identity Platform）を使用してシングルサインオン（SSO）認証を実装する方法について説明します。EntraIDを使った認証は、Azure Active Directory（Azure AD）を利用して安全にユーザー認証を行うことができます。以下の手順では、Blazor WebAssembly アプリケーションでの実装に焦点を当てます。

### 前提条件

- Azure AD テナント
- Azure AD に登録されたアプリケーション（クライアントIDとテナントIDが必要）

### ステップ1: Blazor WebAssembly プロジェクトの作成

Visual Studio または .NET CLI を使用して新しい Blazor WebAssembly アプリケーションを作成します。.NET CLIの場合は以下のコマンドを使用します。

```bash
dotnet new blazorwasm -o BlazorSSODemo --auth Individual
```

### ステップ2: Microsoft Authentication Library (MSAL) の追加

プロジェクトに `Microsoft.Authentication.WebAssembly.Msal` パッケージを追加します。.NET CLIを使用する場合は以下のコマンドです。

```bash
dotnet add package Microsoft.Authentication.WebAssembly.Msal
```

### ステップ3: Azure AD 認証の設定

`wwwroot/appsettings.json` ファイルを編集し、Azure AD の設定を追加します。

```json
{
  "AzureAd": {
    "Authority": "https://login.microsoftonline.com/{テナントID}",
    "ClientId": "{クライアントID}",
    "ValidateAuthority": true
  }
}
```

### ステップ4: プログラムの設定

`Program.cs` または `Startup.cs` ファイルで、Azure AD 認証をアプリケーションに追加します。

```csharp
builder.Services.AddMsalAuthentication(options =>
{
    builder.Configuration.Bind("AzureAd", options.ProviderOptions.Authentication);
    options.ProviderOptions.DefaultAccessTokenScopes.Add("https://graph.microsoft.com/User.Read");
});
```

### ステップ5: 認証の使用

Blazor コンポーネント内で認証状態をチェックし、ユーザー情報を表示します。

```csharp
@page "/auth-info"
@using Microsoft.AspNetCore.Components.Authorization
@inject AuthenticationStateProvider AuthenticationStateProvider

@code {
    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity.IsAuthenticated)
        {
            // 認証されたユーザーの情報を表示
        }
        else
        {
            // ログインページへのリダイレクトなど、認証されていないユーザーの処理
        }
    }
}
```

これらのステップを完了することで、Blazor WebAssembly アプリケーションにおいて、EntraIDを使用したシングルサインオン認証が実装されます。ユーザーはAzure ADを通じてアプリケーションにログインできるようになり、セキュリティが強化されます。

### user — 2024-03-13T16:32:00.069477+00:00

context.User.Identity?.IsAuthenticatedが毎回falseになる場合の対策

### assistant — 2024-03-13T16:33:41.094725+00:00

`context.User.Identity?.IsAuthenticated` が毎回 `false` になる場合、認証が正しく行われていないか、認証情報が適切に設定されていない可能性があります。この問題に対処するための一般的なステップを以下に示します。

### 1. 認証設定の確認

- **アプリケーションの登録:** Azure AD でアプリケーションが正しく登録されているか確認してください。リダイレクトURIがアプリケーションの実際のURLと一致している必要があります。
- **クライアントIDとテナントID:** `appsettings.json` または環境変数に設定されているクライアントIDとテナントIDが正しいか確認してください。

### 2. 認証サービスの設定の確認

`Program.cs`（または `Startup.cs`）で、認証サービスが正しく設定されているか確認します。特に、認証のスキーム名やオプションが正しく設定されている必要があります。

### 3. ミドルウェアの確認

認証ミドルウェアがリクエストパイプラインに正しく追加されているか確認してください。`UseAuthentication` と `UseAuthorization` ミドルウェアが `Configure` メソッド内で適切な順序で呼び出されている必要があります。

```csharp
app.UseAuthentication();
app.UseAuthorization();
```

### 4. 認証チャレンジの確認

ユーザーが認証されていない場合に認証チャレンジ（ログインプロセス）が適切にトリガーされているか確認してください。Blazor アプリケーションの場合、`<AuthorizeView>` コンポーネントや `[Authorize]` 属性を適切に使用して、未認証のユーザーに対して認証を要求しているか確認します。

### 5. トークン検証の確認

受信トークンが正しく検証されているか確認します。これには、トークンの署名、発行者、有効期限などが適切に検証されていることが含まれます。不正なトークンや期限切れのトークンは、認証が失敗する原因となります。

### 6. ログの確認

アプリケーションのログを確認して、認証プロセス中に発生している可能性のあるエラーや警告を特定します。ログは、問題の原因を特定するのに役立つ重要な手がかりを提供することがあります。

### 7. ドキュメントとサポート

Microsoft のドキュメントやコミュニティフォーラムを参照して、類似の問題に対する解決策を探します。場合によっては、特定の設定やバージョンの問題が原因である可能性があり、他のユーザーが同様の問題を報告していることがあります。

これらのステップを通じても問題が解決しない場合は、具体的なエラーメッセージ

### user — 2024-03-13T16:44:04.536412+00:00

SSO環境ではcontext.User.Identity?.IsAuthenticated がつねにtrueになるのか

### assistant — 2024-03-13T16:45:39.400915+00:00

シングルサインオン（SSO）環境において、`context.User.Identity?.IsAuthenticated` が常に `true` になるわけではありません。このプロパティが `true` になるかどうかは、ユーザーが認証されているかどうかに依存します。SSO環境は、複数のアプリケーションまたはサービス間でユーザー認証情報を共有するメカニズムを提供しますが、ユーザーが認証プロセスを完了していない場合、またはセッションがタイムアウトした場合など、`IsAuthenticated` が `false` になる状況は存在します。

### `IsAuthenticated` の動作

- **`true` の場合:** ユーザーが正しく認証され、認証トークン（例: セッションクッキー、JWTトークンなど）が有効であると認識される場合、`context.User.Identity?.IsAuthenticated` は `true` を返します。これは、ユーザーがログインプロセスを成功裏に完了し、認証トークンが生成されたことを示します。
- **`false` の場合:** ユーザーがログインしていない、セッションが切れている、または何らかの理由で認証トークンが無効になっている場合に `false` を返します。これは、ユーザーが認証プロセスをまだ完了していないか、認証セッションが無効になったことを意味します。

### SSO環境での認証状態管理

SSOを実装する際、認証状態（`IsAuthenticated` の値）は、SSOメカニズムによって正しく管理される必要があります。例えば、ユーザーが一つのアプリケーションで認証された後、同じSSOセッションを使用して他のアプリケーションにアクセスする場合、認証状態は維持され、`IsAuthenticated` は `true` のままになります。しかし、ユーザーがログアウトするかセッションがタイムアウトすると、認証状態は失われ、`IsAuthenticated` は `false` に戻ります。

### 結論

SSO環境においても、`context.User.Identity?.IsAuthenticated` の値はユーザーの認証状態に基づいて変化します。ユーザーが正しく認証されている場合にのみ `true` を返し、認証されていないかセッションが無効になった場合は `false` を返します。したがって、アプリケーションはこのプロパティを使用して、ユーザーが認証されているかどうかを確認し、適切なアクセス制御やユーザー体験を提供する必要があります。

### user — 2024-03-13T17:39:06.544534+00:00

webassemblyでlocalstorageにユーザーIDが自動的に入ることはあるのか

### assistant — 2024-03-13T17:40:14.419469+00:00

WebAssembly 自体が直接 LocalStorage にデータを保存する機能を持っているわけではありませんが、WebAssembly を利用するアプリケーション、特に Blazor WebAssembly などのフレームワークを使った場合、JavaScript インターオペラビリティ（JSInterop）を通じて LocalStorage にアクセスし、データ（例えばユーザーID）を保存することが可能です。

LocalStorage にユーザーIDが「自動的に」保存されるかどうかは、アプリケーションの設計に依存します。アプリケーションがユーザーの認証情報や状態をクライアントサイドで管理するために LocalStorage を使用する場合、ログイン処理の一環としてユーザーIDをLocalStorageに保存するコードが実装されている可能性があります。

### LocalStorage へのデータ保存方法

Blazor WebAssembly で LocalStorage へのアクセスを行う例を挙げます。

1. **JavaScript インターオペラビリティ（JSInterop）の使用:** Blazor アプリケーションでは、JSInterop を使って JavaScript コードを呼び出し、LocalStorage にデータを保存することができます。

2. **専用のライブラリ:** Blazor 用の LocalStorage 操作を簡単にするライブラリ（例：`Blazored.LocalStorage`）を使用すると、直接 C# コードから LocalStorage にアクセスしてデータを保存することができます。

### サンプルコード

```csharp
// Blazored.LocalStorage を使用して LocalStorage にデータを保存
@inject Blazored.LocalStorage.ILocalStorageService localStorage

@code {
    protected override async Task OnInitializedAsync()
    {
        await localStorage.SetItemAsync("userId", "ユーザーID");
    }
}
```

この例では、`Blazored.LocalStorage` ライブラリを使用して、ユーザーIDを LocalStorage に保存しています。このような操作が「自動的に」行われるかどうかは、アプリケーションのコードに依存します。つまり、開発者がアプリケーションの認証フローの一部として、明示的にこのようなデータ保存のコードを書く必要があります。

結論として、LocalStorage にユーザーIDが自動的に保存されるかどうかは、アプリケーションがユーザー認証や状態管理のためにそのような機能を実装しているかによります。WebAssembly や Blazor はそのメカニズムを提供するツールですが、具体的な実装はアプリケーションの設計に委ねられています。

### user — 2024-03-13T17:41:12.882138+00:00

webassemblyを前提としてアプリケーション間でにんしょうじょうほうを共有する方法

### assistant — 2024-03-13T17:42:36.714047+00:00

WebAssemblyを前提としたアプリケーション間で認証情報を共有する方法は、主にウェブ技術とセキュリティのプラクティスに依存します。共有の方法は、シングルサインオン（SSO）やトークンベースの認証など、様々なアプローチがあります。以下に、一般的な方法を紹介します。

### 1. シングルサインオン（SSO）

SSOは、ユーザーが一度のログインで複数の関連するが独立したソフトウェアシステムにアクセスできるようにする認証スキームです。SSOを実装する一般的な方法には、OAuth、SAML、OpenID Connectなどがあります。これらのプロトコルを使用すると、認証情報を安全に共有し、ユーザーが複数のアプリケーション間でシームレスに移動できるようになります。

### 2. JWT（JSON Web Tokens）

JWTは、JSONオブジェクトを使用して、ユーザーの認証情報やその他の情報を安全に伝達する方法を提供します。JWTは、サーバーによって署名され、オプションで暗号化されます。クライアント（WebAssemblyアプリケーション）は、JWTを受け取り、それを使用して他のサービスへのリクエストを認証します。JWTは、ヘッダー、ペイロード、署名の3部分から構成されます。ペイロードには、ユーザーの認証情報や権限などの情報が含まれています。

### 3. クロスオリジンリソースシェアリング（CORS）

WebAssemblyアプリケーションはブラウザ内で実行されるため、異なるオリジン間でのリソース共有を行う場合、CORSポリシーに注意が必要です。認証情報を含むリクエストを安全に他のオリジンに送信するためには、サーバー側で適切なCORSヘッダーを設定し、認証情報を共有することが許可されていることを確認する必要があります。

### 4. Web Storage APIとCookies

ウェブストレージAPI（ローカルストレージとセッションストレージ）やクッキーを使用して、認証トークンやユーザーIDなどの情報をクライアントサイドに保存し、アプリケーション間で共有することができます。ただし、セキュリティ上のリスクを最小限に抑えるために、HTTPS接続を使用し、セキュアなクッキーを設定することが重要です。また、クロスサイトスクリプティング（XSS）攻撃に対する脆弱性を避けるために、保存するデータに対して適切なサニタイゼーションとバリデーションを行う必要があります。

### 5. サービスワーカー

サービスワーカーは、ネットワークリクエストをインターセプトし、カスタム応答を提供することができるウェブ技術です。サービスワーカーを使用して、認証トークンをリクエストに追加することで、
