---
conversation_id: "ddf9159e-34ee-44bb-87c6-121fa7b0f99e"
title: "Create .NET 8 gRPC."
create_time: 1711507498.530625
update_time: 1711509667.872472
language_guess: "en"
num_messages: 18
part_index: 1
part_count: 1
---

### system — 2024-03-27T02:44:58.530625+00:00

_(empty)_

### user — 2024-03-27T02:44:58.531223+00:00

.net8でGRPCサーバのサンプル

### assistant — 2024-03-27T02:45:07.446680+00:00

.NET 8でgRPCサーバのサンプルを作成する方法を示します。以下は、C#を使用してgRPCサーバを作成する基本的な手順です。

1. Visual Studio 2022またはVisual Studio CodeなどのIDEを使用して新しい.NET Coreプロジェクトを作成します。

2. gRPCサービス定義ファイル（.protoファイル）を作成します。たとえば、"greeter.proto"という名前のファイルを作成し、以下のような内容を記述します。

```protobuf
syntax = "proto3";

option csharp_namespace = "GrpcGreeter";

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

3. .protoファイルからC#クラスを生成します。これには、次のコマンドを使用します。

```bash
protoc greeter.proto --csharp_out=. --grpc_out=. --plugin=protoc-gen-grpc=/path/to/grpc_csharp_plugin
```

`/path/to/grpc_csharp_plugin`は、gRPC C#用のプラグインのパスに置き換えてください。

4. 生成されたC#コードをプロジェクトに追加します。

5. gRPCサービスの実装を行います。生成された`GreeterBase`クラスを継承し、サービスのロジックを実装します。

```csharp
using Grpc.Core;
using System.Threading.Tasks;

namespace GrpcGreeter
{
    public class GreeterService : Greeter.GreeterBase
    {
        public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
        {
            return Task.FromResult(new HelloReply
            {
                Message = "Hello " + request.Name
            });
        }
    }
}
```

6. gRPCサーバを起動するコードを作成します。

```csharp
using Grpc.Core;
using System;

namespace GrpcGreeter
{
    class Program
    {
        static void Main(string[] args)
        {
            const int Port = 50051;
            Server server = new Server
            {
                Services = { Greeter.BindService(new GreeterService()) },
                Ports = { new ServerPort("localhost", Port, ServerCredentials.Insecure) }
            };
            server.Start();

            Console.WriteLine("Greeter server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();

            server.ShutdownAsync().Wait();
        }
    }
}
```

7. プロジェクトをビルドし、実行します。

これで、.NET 8を使用してgRPCサーバを作成し、実行する準備が整いました。

### user — 2024-03-27T02:46:10.894100+00:00

kestrelを利用する条件を追加

### assistant — 2024-03-27T02:46:18.570807+00:00

.NET Core/.NET 5以降の場合、KestrelはデフォルトのWebサーバーです。Kestrelを使用してgRPCサーバーをホストする場合、いくつかの追加手順が必要です。

1. `Grpc.AspNetCore` パッケージをプロジェクトに追加します。

2. gRPCサービスの実装とKestrelの設定を行います。

```csharp
using Grpc.Core;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System;

namespace GrpcGreeter
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddGrpc();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseRouting();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapGrpcService<GreeterService>();
            });
        }
    }

    public class GreeterService : Greeter.GreeterBase
    {
        public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
        {
            return Task.FromResult(new HelloReply
            {
                Message = "Hello " + request.Name
            });
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                    webBuilder.ConfigureKestrel(options =>
                    {
                        options.ListenAnyIP(50051, listenOptions =>
                        {
                            listenOptions.Protocols = HttpProtocols.Http2;
                        });
                    });
                });
    }
}
```

この例では、`Startup` クラスを使用して gRPC サービスを設定し、`Program` クラスの `CreateHostBuilder` メソッド内で Kestrel を構成しています。また、`UseKestrel()` ではなく `ConfigureKestrel()` を使用して、より詳細なKestrelの設定を行っています。

3. プロジェクトをビルドし、実行します。

これで、Kestrelを利用して.NET 8でgRPCサーバーを実行する準備が整いました。

### user — 2024-03-27T02:47:19.278700+00:00

このサービスを呼び出す側をC#で示せ

### assistant — 2024-03-27T02:47:26.164509+00:00

gRPCサービスを呼び出すC#クライアントを作成する手順を示します。

1. gRPCサービスの定義と同じプロジェクトに、クライアント用のC#コードを作成します。この例では、`GreeterClient` クラスを使用してサービスを呼び出します。

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

namespace GrpcGreeter
{
    public class GreeterClient
    {
        private readonly Greeter.GreeterClient _client;

        public GreeterClient(Channel channel)
        {
            _client = new Greeter.GreeterClient(channel);
        }

        public async Task<string> SayHelloAsync(string name)
        {
            var request = new HelloRequest { Name = name };
            var reply = await _client.SayHelloAsync(request);
            return reply.Message;
        }
    }

    class Program
    {
        static async Task Main(string[] args)
        {
            const string target = "localhost:50051";
            Channel channel = new Channel(target, ChannelCredentials.Insecure);
            var client = new GreeterClient(channel);

            string user = "world";
            var reply = await client.SayHelloAsync(user);
            Console.WriteLine("Greeting: " + reply);

            await channel.ShutdownAsync();
        }
    }
}
```

2. サービスを呼び出すために、`GreeterClient` クラスを使用します。`Main` メソッド内で、クライアントを作成し、gRPCサービスにリクエストを送信します。

3. プロジェクトをビルドし、実行します。これにより、gRPCサービスが呼び出され、応答がコンソールに表示されます。

このようにして、C#クライアントを使用してgRPCサービスを呼び出すことができます。

### user — 2024-03-27T02:48:11.099858+00:00

サービス側にCallback形式のI/Fを実装し、クライアントから呼び出すコードを追加

### assistant — 2024-03-27T02:48:23.334292+00:00

理解しやすいように、サービス側でコールバック形式のインターフェースを実装し、クライアントからそれを呼び出す例を示します。

まず、サービス側でコールバック形式のI/Fを実装します。

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

namespace GrpcGreeter
{
    public class GreeterService : Greeter.GreeterBase
    {
        public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
        {
            return Task.FromResult(new HelloReply
            {
                Message = "Hello " + request.Name
            });
        }

        public override Task<HelloReply> SayHelloWithCallback(HelloRequest request, ServerCallContext context)
        {
            Action<string> callback = request.Callback;

            // Do some processing here...

            callback?.Invoke("Hello from server!");
            
            return Task.FromResult(new HelloReply());
        }
    }
}
```

上記のように、`SayHelloWithCallback` メソッドは、クライアントから渡されたコールバックを呼び出しています。

次に、クライアント側でこのコールバックを使用してサービスを呼び出すコードを追加します。

```csharp
using Grpc.Core;
using System;
using System.Threading.Tasks;

namespace GrpcGreeter
{
    public class GreeterClient
    {
        private readonly Greeter.GreeterClient _client;

        public GreeterClient(Channel channel)
        {
            _client = new Greeter.GreeterClient(channel);
        }

        public async Task<string> SayHelloAsync(string name)
        {
            var request = new HelloRequest { Name = name };
            var reply = await _client.SayHelloAsync(request);
            return reply.Message;
        }

        public async Task<string> SayHelloWithCallbackAsync(string name)
        {
            var tcs = new TaskCompletionSource<string>();

            var request = new HelloRequest
            {
                Name = name,
                Callback = message => tcs.SetResult(message)
            };

            await _client.SayHelloWithCallbackAsync(request);

            return await tcs.Task;
        }
    }

    class Program
    {
        static async Task Main(string[] args)
        {
            const string target = "localhost:50051";
            Channel channel = new Channel(target, ChannelCredentials.Insecure);
            var client = new GreeterClient(channel);

            string user = "world";
            var reply = await client.SayHelloAsync(user);
            Console.WriteLine("Greeting: " + reply);

            var callbackReply = await client.SayHelloWithCallbackAsync(user);
            Console.WriteLine("Callback Greeting: " + callbackReply);

            await channel.ShutdownAsync();
        }
    }
}
```

上記のコードでは、`SayHelloWithCallbackAsync` メソッドを使用して、サービスのコールバックメソッドを呼び出し、その結果を非同期的に取得しています。

これで、サービス側でコールバック形式のI/Fを実装し、クライアントからそれを呼び出すためのC#コードが追加されました。

### user — 2024-03-27T02:49:31.982334+00:00

このcallbackは複数のクライアントから接続がある場合、同時にcallbackを受け付けるのか

### assistant — 2024-03-27T02:49:38.588059+00:00

gRPCサービスはデフォルトで各要求に対して新しいスレッドを使用します。そのため、複数のクライアントからの要求が同時に到着した場合、それぞれの要求は独自のスレッド上で処理されます。

したがって、複数のクライアントからの要求が同時に到着した場合、サービスはそれらの要求を同時に処理し、それぞれの要求に対して個別のコールバックを実行します。これは、各クライアントが独立してサービスに接続し、それぞれの要求が個別のスレッド上で処理されるためです。

ただし、注意すべき点があります。コールバックが同期的に長時間実行される場合や、非同期的な操作（例：データベースクエリの実行など）を行う場合、サービスのスレッドプールが適切に管理されていない場合には、多数の同時リクエストがサービスに対して発生した場合にスケーラビリティの問題が発生する可能性があります。そのため、コールバックの処理が長時間かかる場合や、外部のリソースへの非同期アクセスが必要な場合には、適切なスケーリング戦略を検討する必要があります。

### user — 2024-03-27T02:52:35.967934+00:00

このcallback i/fをkestrelでホストする前提を追加

### assistant — 2024-03-27T02:52:45.969087+00:00

KestrelでホストされるgRPCサービスにおいても、同じように複数のクライアントからの要求が同時に到着した場合、それぞれの要求は個別のスレッド上で処理されます。したがって、複数のクライアントからの要求が同時に到着した場合でも、それぞれの要求に対して個別のコールバックが実行されることに変わりはありません。

KestrelでgRPCサービスをホストする場合、基本的な構造は前述の通りですが、Kestrelの設定に注意する必要があります。以下のコードは、Kestrelを使用してgRPCサービスをホストし、同時に複数のクライアントからの要求を処理する方法を示しています。

```csharp
using Grpc.Core;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System;

namespace GrpcGreeter
{
    public class GreeterService : Greeter.GreeterBase
    {
        public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
        {
            return Task.FromResult(new HelloReply
            {
                Message = "Hello " + request.Name
            });
        }

        public override Task<HelloReply> SayHelloWithCallback(HelloRequest request, ServerCallContext context)
        {
            Action<string> callback = request.Callback;

            // Do some processing here...

            callback?.Invoke("Hello from server!");

            return Task.FromResult(new HelloReply());
        }
    }

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddGrpc();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseRouting();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapGrpcService<GreeterService>();
            });
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                    webBuilder.ConfigureKestrel(options =>
                    {
                        options.ListenAnyIP(50051, listenOptions =>
                        {
                            listenOptions.Protocols = HttpProtocols.Http2;
                        });
                    });
                });
    }
}
```

このコードでは、Kestrelを使用してgRPCサービスをホストし、複数のクライアントからの要求を処理する準備が整っています。 KestrelはデフォルトでHTTP/2をサポートしており、それによってgRPCの通信も可能になります。

### user — 2024-03-27T02:53:24.738022+00:00

.net8はデフォルトでstartupクラスを使用しなしため、startupクラスを利用しない前提を追加

### assistant — 2024-03-27T02:53:32.024226+00:00

.NET 8では、ASP.NET CoreのMinimal APIsを使用して、よりシンプルなアプリケーションの構築が可能です。この場合、Startupクラスを使用せずに、アプリケーションの構成を行います。

以下は、Minimal APIsを使用してKestrelでgRPCサービスをホストし、コールバックI/Fを実装するサンプルコードです。

```csharp
using Grpc.Core;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.Threading.Tasks;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddGrpc();

var app = builder.Build();

app.MapGrpcService<GreeterService>();

app.Run();

public class GreeterService : Greeter.GreeterBase
{
    public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
    {
        return Task.FromResult(new HelloReply
        {
            Message = "Hello " + request.Name
        });
    }

    public override Task<HelloReply> SayHelloWithCallback(HelloRequest request, ServerCallContext context)
    {
        Action<string> callback = request.Callback;

        // Do some processing here...

        callback?.Invoke("Hello from server!");

        return Task.FromResult(new HelloReply());
    }
}

```

このコードでは、`WebApplication` を使用してアプリケーションを構築し、`AddGrpc()` メソッドを使用して gRPC サービスを登録しています。その後、`MapGrpcService` メソッドを使用して、`GreeterService` をマッピングしています。

`Run()` メソッドは、アプリケーションを開始し、HTTP リクエストの待ち受けを行います。

このようにして、Minimal APIsを使用して.NET 8でKestrelでgRPCサービスをホストし、Startupクラスを使用しないコードを実装しました。

### user — 2024-03-27T03:20:59.603021+00:00

kestrelでgrpcを利用し、http3を選択、SSLは未使用の前提を追加

### assistant — 2024-03-27T03:21:07.868554+00:00

.NET 8とKestrelを使用して、gRPCをHTTP/3で実行し、SSLを使用しない場合のサンプルコードを示します。ただし、gRPC自体はHTTP/2またはHTTP/3を使用できますが、KestrelはまだHTTP/3を正式にサポートしていないため、HTTP/2で動作します。これは将来のバージョンで変更される可能性がありますので、最新の情報を確認してください。

まず、必要なパッケージをインストールします。これには、`Microsoft.AspNetCore.Server.Kestrel.Core` パッケージが含まれます。

次に、HTTP/3を有効にし、SSLを無効にする必要があります。以下のコードでは、HTTP/3は無効になっていますが、HTTP/2で動作します。

```csharp
using Grpc.Core;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.Threading.Tasks;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddGrpc();

var app = builder.Build();

app.MapGrpcService<GreeterService>();

app.Run();

public class GreeterService : Greeter.GreeterBase
{
    public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
    {
        return Task.FromResult(new HelloReply
        {
            Message = "Hello " + request.Name
        });
    }

    public override Task<HelloReply> SayHelloWithCallback(HelloRequest request, ServerCallContext context)
    {
        Action<string> callback = request.Callback;

        // Do some processing here...

        callback?.Invoke("Hello from server!");

        return Task.FromResult(new HelloReply());
    }
}
```

このコードでは、HTTP/3を有効にするための明示的な設定は行っていません。Kestrelは現在HTTP/3をサポートしていないため、デフォルトではHTTP/2が使用されます。SSLを使用せずにKestrelを実行する場合、アプリケーションをHTTP/2で実行することになります。

しかし、HTTP/3のサポートは将来のKestrelのバージョンで変更される可能性がありますので、最新の情報を確認することをお勧めします。
